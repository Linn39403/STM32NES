; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_hal_sd.o --depend=stm32nes\stm32f4xx_hal_sd.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_hal_sd.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_sd.c]
                          THUMB

                          AREA ||i.HAL_SD_Abort||, CODE, READONLY, ALIGN=1

                  HAL_SD_Abort PROC
;;;2167     */
;;;2168   HAL_StatusTypeDef HAL_SD_Abort(SD_HandleTypeDef *hsd)
000000  b570              PUSH     {r4-r6,lr}
;;;2169   {
000002  4604              MOV      r4,r0
;;;2170     HAL_SD_CardStateTypeDef CardState;
;;;2171     
;;;2172     /* DIsable All interrupts */
;;;2173     __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
000004  6820              LDR      r0,[r4,#0]
000006  6bc0              LDR      r0,[r0,#0x3c]
000008  f420709d          BIC      r0,r0,#0x13a
00000c  6821              LDR      r1,[r4,#0]
00000e  63c8              STR      r0,[r1,#0x3c]
;;;2174                              SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);
;;;2175     
;;;2176     /* Clear All flags */
;;;2177     __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
000010  f24050ff          MOV      r0,#0x5ff
000014  6821              LDR      r1,[r4,#0]
000016  6388              STR      r0,[r1,#0x38]
;;;2178     
;;;2179     if((hsd->hdmatx != NULL) || (hsd->hdmarx != NULL))
000018  6c20              LDR      r0,[r4,#0x40]
00001a  b908              CBNZ     r0,|L1.32|
00001c  6be0              LDR      r0,[r4,#0x3c]
00001e  b178              CBZ      r0,|L1.64|
                  |L1.32|
;;;2180     {
;;;2181       /* Disable the SD DMA request */
;;;2182       hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
000020  6820              LDR      r0,[r4,#0]
000022  6ac0              LDR      r0,[r0,#0x2c]
000024  f0200008          BIC      r0,r0,#8
000028  6821              LDR      r1,[r4,#0]
00002a  62c8              STR      r0,[r1,#0x2c]
;;;2183       
;;;2184       /* Abort the SD DMA Tx Stream */
;;;2185       if(hsd->hdmatx != NULL)
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  b110              CBZ      r0,|L1.54|
;;;2186       {
;;;2187         HAL_DMA_Abort(hsd->hdmatx);
000030  6c20              LDR      r0,[r4,#0x40]
000032  f7fffffe          BL       HAL_DMA_Abort
                  |L1.54|
;;;2188       }
;;;2189       /* Abort the SD DMA Rx Stream */
;;;2190       if(hsd->hdmarx != NULL)
000036  6be0              LDR      r0,[r4,#0x3c]
000038  b110              CBZ      r0,|L1.64|
;;;2191       {
;;;2192         HAL_DMA_Abort(hsd->hdmarx);
00003a  6be0              LDR      r0,[r4,#0x3c]
00003c  f7fffffe          BL       HAL_DMA_Abort
                  |L1.64|
;;;2193       }
;;;2194     }
;;;2195     
;;;2196     hsd->State = HAL_SD_STATE_READY;
000040  2001              MOVS     r0,#1
000042  f8840034          STRB     r0,[r4,#0x34]
;;;2197     CardState = HAL_SD_GetCardState(hsd);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       HAL_SD_GetCardState
00004c  4605              MOV      r5,r0
;;;2198     if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
00004e  2d06              CMP      r5,#6
000050  d001              BEQ      |L1.86|
000052  2d05              CMP      r5,#5
000054  d103              BNE      |L1.94|
                  |L1.86|
;;;2199     {
;;;2200       hsd->ErrorCode = SDMMC_CmdStopTransfer(hsd->Instance);
000056  6820              LDR      r0,[r4,#0]
000058  f7fffffe          BL       SDMMC_CmdStopTransfer
00005c  63a0              STR      r0,[r4,#0x38]
                  |L1.94|
;;;2201     }
;;;2202     if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
00005e  6ba0              LDR      r0,[r4,#0x38]
000060  b108              CBZ      r0,|L1.102|
;;;2203     {
;;;2204       return HAL_ERROR;
000062  2001              MOVS     r0,#1
                  |L1.100|
;;;2205     }
;;;2206     return HAL_OK;
;;;2207   }
000064  bd70              POP      {r4-r6,pc}
                  |L1.102|
000066  2000              MOVS     r0,#0                 ;2206
000068  e7fc              B        |L1.100|
;;;2208   
                          ENDP


                          AREA ||i.HAL_SD_AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_AbortCallback PROC
;;;1693     */
;;;1694   __weak void HAL_SD_AbortCallback(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;1695   {
;;;1696     /* Prevent unused argument(s) compilation warning */
;;;1697     UNUSED(hsd);
;;;1698    
;;;1699     /* NOTE : This function should not be modified, when the callback is needed,
;;;1700               the HAL_SD_ErrorCallback can be implemented in the user file
;;;1701      */ 
;;;1702   }
;;;1703   
                          ENDP


                          AREA ||i.HAL_SD_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_SD_Abort_IT PROC
;;;2214     */
;;;2215   HAL_StatusTypeDef HAL_SD_Abort_IT(SD_HandleTypeDef *hsd)
000000  b570              PUSH     {r4-r6,lr}
;;;2216   {
000002  4604              MOV      r4,r0
;;;2217     HAL_SD_CardStateTypeDef CardState;
;;;2218       
;;;2219     /* DIsable All interrupts */
;;;2220     __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
000004  6820              LDR      r0,[r4,#0]
000006  6bc0              LDR      r0,[r0,#0x3c]
000008  f420709d          BIC      r0,r0,#0x13a
00000c  6821              LDR      r1,[r4,#0]
00000e  63c8              STR      r0,[r1,#0x3c]
;;;2221                              SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);
;;;2222     
;;;2223     /* Clear All flags */
;;;2224     __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
000010  f24050ff          MOV      r0,#0x5ff
000014  6821              LDR      r1,[r4,#0]
000016  6388              STR      r0,[r1,#0x38]
;;;2225     
;;;2226     if((hsd->hdmatx != NULL) || (hsd->hdmarx != NULL))
000018  6c20              LDR      r0,[r4,#0x40]
00001a  b908              CBNZ     r0,|L3.32|
00001c  6be0              LDR      r0,[r4,#0x3c]
00001e  b1d8              CBZ      r0,|L3.88|
                  |L3.32|
;;;2227     {
;;;2228       /* Disable the SD DMA request */
;;;2229       hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
000020  6820              LDR      r0,[r4,#0]
000022  6ac0              LDR      r0,[r0,#0x2c]
000024  f0200008          BIC      r0,r0,#8
000028  6821              LDR      r1,[r4,#0]
00002a  62c8              STR      r0,[r1,#0x2c]
;;;2230       
;;;2231       /* Abort the SD DMA Tx Stream */
;;;2232       if(hsd->hdmatx != NULL)
00002c  6c20              LDR      r0,[r4,#0x40]
00002e  b140              CBZ      r0,|L3.66|
;;;2233       {
;;;2234         hsd->hdmatx->XferAbortCallback =  SD_DMATxAbort;
000030  4817              LDR      r0,|L3.144|
000032  6c21              LDR      r1,[r4,#0x40]
000034  6508              STR      r0,[r1,#0x50]
;;;2235         if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
000036  6c20              LDR      r0,[r4,#0x40]
000038  f7fffffe          BL       HAL_DMA_Abort_IT
00003c  b108              CBZ      r0,|L3.66|
;;;2236         {
;;;2237           hsd->hdmatx = NULL;
00003e  2000              MOVS     r0,#0
000040  6420              STR      r0,[r4,#0x40]
                  |L3.66|
;;;2238         }
;;;2239       }
;;;2240       /* Abort the SD DMA Rx Stream */
;;;2241       if(hsd->hdmarx != NULL)
000042  6be0              LDR      r0,[r4,#0x3c]
000044  b140              CBZ      r0,|L3.88|
;;;2242       {
;;;2243         hsd->hdmarx->XferAbortCallback =  SD_DMARxAbort;
000046  4813              LDR      r0,|L3.148|
000048  6be1              LDR      r1,[r4,#0x3c]
00004a  6508              STR      r0,[r1,#0x50]
;;;2244         if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
00004c  6be0              LDR      r0,[r4,#0x3c]
00004e  f7fffffe          BL       HAL_DMA_Abort_IT
000052  b108              CBZ      r0,|L3.88|
;;;2245         {
;;;2246           hsd->hdmarx = NULL;
000054  2000              MOVS     r0,#0
000056  63e0              STR      r0,[r4,#0x3c]
                  |L3.88|
;;;2247         }
;;;2248       }
;;;2249     }
;;;2250     
;;;2251     /* No transfer ongoing on both DMA channels*/
;;;2252     if((hsd->hdmatx == NULL) && (hsd->hdmarx == NULL))
000058  6c20              LDR      r0,[r4,#0x40]
00005a  b9b8              CBNZ     r0,|L3.140|
00005c  6be0              LDR      r0,[r4,#0x3c]
00005e  b9a8              CBNZ     r0,|L3.140|
;;;2253     {
;;;2254       CardState = HAL_SD_GetCardState(hsd);
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       HAL_SD_GetCardState
000066  4605              MOV      r5,r0
;;;2255       hsd->State = HAL_SD_STATE_READY;
000068  2001              MOVS     r0,#1
00006a  f8840034          STRB     r0,[r4,#0x34]
;;;2256       if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
00006e  2d06              CMP      r5,#6
000070  d001              BEQ      |L3.118|
000072  2d05              CMP      r5,#5
000074  d103              BNE      |L3.126|
                  |L3.118|
;;;2257       {
;;;2258         hsd->ErrorCode = SDMMC_CmdStopTransfer(hsd->Instance);
000076  6820              LDR      r0,[r4,#0]
000078  f7fffffe          BL       SDMMC_CmdStopTransfer
00007c  63a0              STR      r0,[r4,#0x38]
                  |L3.126|
;;;2259       }
;;;2260       if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
00007e  6ba0              LDR      r0,[r4,#0x38]
000080  b108              CBZ      r0,|L3.134|
;;;2261       {
;;;2262         return HAL_ERROR;
000082  2001              MOVS     r0,#1
                  |L3.132|
;;;2263       }
;;;2264       else
;;;2265       {
;;;2266         HAL_SD_AbortCallback(hsd);
;;;2267       }
;;;2268     }
;;;2269     
;;;2270     return HAL_OK;
;;;2271   }
000084  bd70              POP      {r4-r6,pc}
                  |L3.134|
000086  4620              MOV      r0,r4                 ;2266
000088  f7fffffe          BL       HAL_SD_AbortCallback
                  |L3.140|
00008c  2000              MOVS     r0,#0                 ;2270
00008e  e7f9              B        |L3.132|
;;;2272   
                          ENDP

                  |L3.144|
                          DCD      SD_DMATxAbort
                  |L3.148|
                          DCD      SD_DMARxAbort

                          AREA ||i.HAL_SD_ConfigWideBusOperation||, CODE, READONLY, ALIGN=1

                  HAL_SD_ConfigWideBusOperation PROC
;;;2072     */
;;;2073   HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
000000  b570              PUSH     {r4-r6,lr}
;;;2074   {
000002  b08a              SUB      sp,sp,#0x28
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2075     SDIO_InitTypeDef Init;
;;;2076     uint32_t errorstate = HAL_SD_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;2077     
;;;2078     /* Check the parameters */
;;;2079     assert_param(IS_SDIO_BUS_WIDE(WideMode));
;;;2080     
;;;2081     /* Chnage Satte */
;;;2082     hsd->State = HAL_SD_STATE_BUSY;
00000a  2003              MOVS     r0,#3
00000c  f8840034          STRB     r0,[r4,#0x34]
;;;2083     
;;;2084     if(hsd->SdCard.CardType != CARD_SECURED) 
000010  6c60              LDR      r0,[r4,#0x44]
000012  2803              CMP      r0,#3
000014  d020              BEQ      |L4.88|
;;;2085     {
;;;2086       if(WideMode == SDIO_BUS_WIDE_8B)
000016  f5b55f80          CMP      r5,#0x1000
00001a  d104              BNE      |L4.38|
;;;2087       {
;;;2088         hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
00001c  6ba0              LDR      r0,[r4,#0x38]
00001e  f0405080          ORR      r0,r0,#0x10000000
000022  63a0              STR      r0,[r4,#0x38]
000024  e01c              B        |L4.96|
                  |L4.38|
;;;2089       }
;;;2090       else if(WideMode == SDIO_BUS_WIDE_4B)
000026  f5b56f00          CMP      r5,#0x800
00002a  d107              BNE      |L4.60|
;;;2091       {
;;;2092         errorstate = SD_WideBus_Enable(hsd);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SD_WideBus_Enable
000032  4606              MOV      r6,r0
;;;2093         
;;;2094         hsd->ErrorCode |= errorstate;
000034  6ba0              LDR      r0,[r4,#0x38]
000036  4330              ORRS     r0,r0,r6
000038  63a0              STR      r0,[r4,#0x38]
00003a  e011              B        |L4.96|
                  |L4.60|
;;;2095       }
;;;2096       else if(WideMode == SDIO_BUS_WIDE_1B)
00003c  b93d              CBNZ     r5,|L4.78|
;;;2097       {
;;;2098         errorstate = SD_WideBus_Disable(hsd);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       SD_WideBus_Disable
000044  4606              MOV      r6,r0
;;;2099         
;;;2100         hsd->ErrorCode |= errorstate;
000046  6ba0              LDR      r0,[r4,#0x38]
000048  4330              ORRS     r0,r0,r6
00004a  63a0              STR      r0,[r4,#0x38]
00004c  e008              B        |L4.96|
                  |L4.78|
;;;2101       }
;;;2102       else
;;;2103       {
;;;2104         /* WideMode is not a valid argument*/
;;;2105         hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
00004e  6ba0              LDR      r0,[r4,#0x38]
000050  f0406000          ORR      r0,r0,#0x8000000
000054  63a0              STR      r0,[r4,#0x38]
000056  e003              B        |L4.96|
                  |L4.88|
;;;2106       }
;;;2107     }  
;;;2108     else
;;;2109     {
;;;2110       /* MMC Card does not support this feature */
;;;2111       hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
000058  6ba0              LDR      r0,[r4,#0x38]
00005a  f0405080          ORR      r0,r0,#0x10000000
00005e  63a0              STR      r0,[r4,#0x38]
                  |L4.96|
;;;2112     }
;;;2113     
;;;2114     if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
000060  6ba0              LDR      r0,[r4,#0x38]
000062  b140              CBZ      r0,|L4.118|
;;;2115     {
;;;2116       /* Clear all the static flags */
;;;2117       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
000064  f24050ff          MOV      r0,#0x5ff
000068  6821              LDR      r1,[r4,#0]
00006a  6388              STR      r0,[r1,#0x38]
;;;2118       hsd->State = HAL_SD_STATE_READY;
00006c  2001              MOVS     r0,#1
00006e  f8840034          STRB     r0,[r4,#0x34]
                  |L4.114|
;;;2119       return HAL_ERROR;
;;;2120     }
;;;2121     else
;;;2122     {
;;;2123       /* Configure the SDIO peripheral */
;;;2124       Init.ClockEdge           = hsd->Init.ClockEdge;
;;;2125       Init.ClockBypass         = hsd->Init.ClockBypass;
;;;2126       Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
;;;2127       Init.BusWide             = WideMode;
;;;2128       Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
;;;2129       Init.ClockDiv            = hsd->Init.ClockDiv;
;;;2130       SDIO_Init(hsd->Instance, Init);
;;;2131     }
;;;2132   
;;;2133     /* Change State */
;;;2134     hsd->State = HAL_SD_STATE_READY;
;;;2135     
;;;2136     return HAL_OK;
;;;2137   }
000072  b00a              ADD      sp,sp,#0x28
000074  bd70              POP      {r4-r6,pc}
                  |L4.118|
000076  6860              LDR      r0,[r4,#4]            ;2124
000078  9004              STR      r0,[sp,#0x10]         ;2124
00007a  68a0              LDR      r0,[r4,#8]            ;2125
00007c  9005              STR      r0,[sp,#0x14]         ;2125
00007e  68e0              LDR      r0,[r4,#0xc]          ;2126
000080  9006              STR      r0,[sp,#0x18]         ;2126
000082  9507              STR      r5,[sp,#0x1c]         ;2127
000084  6960              LDR      r0,[r4,#0x14]         ;2128
000086  9008              STR      r0,[sp,#0x20]         ;2128
000088  69a0              LDR      r0,[r4,#0x18]         ;2129
00008a  9009              STR      r0,[sp,#0x24]         ;2129
00008c  a807              ADD      r0,sp,#0x1c           ;2130
00008e  c807              LDM      r0,{r0-r2}            ;2130
000090  e88d0007          STM      sp,{r0-r2}            ;2130
000094  6820              LDR      r0,[r4,#0]            ;2130
000096  a904              ADD      r1,sp,#0x10           ;2130
000098  c90e              LDM      r1,{r1-r3}            ;2130
00009a  f7fffffe          BL       SDIO_Init
00009e  2001              MOVS     r0,#1                 ;2134
0000a0  f8840034          STRB     r0,[r4,#0x34]         ;2134
0000a4  2000              MOVS     r0,#0                 ;2136
0000a6  e7e4              B        |L4.114|
;;;2138   
                          ENDP


                          AREA ||i.HAL_SD_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_SD_DeInit PROC
;;;410      */
;;;411    HAL_StatusTypeDef HAL_SD_DeInit(SD_HandleTypeDef *hsd)
000000  b510              PUSH     {r4,lr}
;;;412    {
000002  4604              MOV      r4,r0
;;;413      /* Check the SD handle allocation */
;;;414      if(hsd == NULL)
000004  b90c              CBNZ     r4,|L5.10|
;;;415      {
;;;416        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L5.8|
;;;417      }
;;;418      
;;;419      /* Check the parameters */
;;;420      assert_param(IS_SDIO_ALL_INSTANCE(hsd->Instance));
;;;421    
;;;422      hsd->State = HAL_SD_STATE_BUSY;
;;;423      
;;;424      /* Set SD power state to off */ 
;;;425      SD_PowerOFF(hsd);
;;;426      
;;;427      /* De-Initialize the MSP layer */
;;;428      HAL_SD_MspDeInit(hsd);
;;;429      
;;;430      hsd->ErrorCode = HAL_SD_ERROR_NONE;
;;;431      hsd->State = HAL_SD_STATE_RESET;
;;;432      
;;;433      return HAL_OK;
;;;434    }
000008  bd10              POP      {r4,pc}
                  |L5.10|
00000a  2003              MOVS     r0,#3                 ;422
00000c  f8840034          STRB     r0,[r4,#0x34]         ;422
000010  4620              MOV      r0,r4                 ;425
000012  f7fffffe          BL       SD_PowerOFF
000016  4620              MOV      r0,r4                 ;428
000018  f7fffffe          BL       HAL_SD_MspDeInit
00001c  2000              MOVS     r0,#0                 ;430
00001e  63a0              STR      r0,[r4,#0x38]         ;430
000020  f8840034          STRB     r0,[r4,#0x34]         ;431
000024  bf00              NOP                            ;433
000026  e7ef              B        |L5.8|
;;;435    
                          ENDP


                          AREA ||i.HAL_SD_Erase||, CODE, READONLY, ALIGN=1

                  HAL_SD_Erase PROC
;;;1305     */
;;;1306   HAL_StatusTypeDef HAL_SD_Erase(SD_HandleTypeDef *hsd, uint32_t BlockStartAdd, uint32_t BlockEndAdd)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1307   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;1308     uint32_t errorstate = HAL_SD_ERROR_NONE;
00000a  2500              MOVS     r5,#0
;;;1309     
;;;1310     if(hsd->State == HAL_SD_STATE_READY)
00000c  f8940034          LDRB     r0,[r4,#0x34]
000010  2801              CMP      r0,#1
000012  d17c              BNE      |L6.270|
;;;1311     {
;;;1312       hsd->ErrorCode = HAL_DMA_ERROR_NONE;
000014  2000              MOVS     r0,#0
000016  63a0              STR      r0,[r4,#0x38]
;;;1313       
;;;1314       if(BlockEndAdd < BlockStartAdd)
000018  42be              CMP      r6,r7
00001a  d206              BCS      |L6.42|
;;;1315       {
;;;1316         hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
00001c  6ba0              LDR      r0,[r4,#0x38]
00001e  f0406000          ORR      r0,r0,#0x8000000
000022  63a0              STR      r0,[r4,#0x38]
;;;1317         return HAL_ERROR;
000024  2001              MOVS     r0,#1
                  |L6.38|
;;;1318       }
;;;1319       
;;;1320       if(BlockEndAdd > (hsd->SdCard.LogBlockNbr))
;;;1321       {
;;;1322         hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;1323         return HAL_ERROR;
;;;1324       }
;;;1325       
;;;1326       hsd->State = HAL_SD_STATE_BUSY;
;;;1327       
;;;1328       /* Check if the card command class supports erase command */
;;;1329       if(((hsd->SdCard.Class) & SDIO_CCCC_ERASE) == 0U)
;;;1330       {
;;;1331         /* Clear all the static flags */
;;;1332         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;1333         hsd->ErrorCode |= HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
;;;1334         hsd->State = HAL_SD_STATE_READY;
;;;1335         return HAL_ERROR;
;;;1336       }
;;;1337       
;;;1338       if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
;;;1339       {
;;;1340         /* Clear all the static flags */
;;;1341         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);  
;;;1342         hsd->ErrorCode |= HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
;;;1343         hsd->State = HAL_SD_STATE_READY;
;;;1344         return HAL_ERROR;
;;;1345       }
;;;1346       
;;;1347       /* Get start and end block for high capacity cards */
;;;1348       if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;1349       {
;;;1350         BlockStartAdd *= 512U;
;;;1351         BlockEndAdd   *= 512U;
;;;1352       }
;;;1353       
;;;1354       /* According to sd-card spec 1.0 ERASE_GROUP_START (CMD32) and erase_group_end(CMD33) */
;;;1355       if(hsd->SdCard.CardType != CARD_SECURED)
;;;1356       {
;;;1357         /* Send CMD32 SD_ERASE_GRP_START with argument as addr  */
;;;1358         errorstate = SDMMC_CmdSDEraseStartAdd(hsd->Instance, BlockStartAdd);
;;;1359         if(errorstate != HAL_SD_ERROR_NONE)
;;;1360         {
;;;1361           /* Clear all the static flags */
;;;1362           __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1363           hsd->ErrorCode |= errorstate;
;;;1364           hsd->State = HAL_SD_STATE_READY;
;;;1365           return HAL_ERROR;
;;;1366         }
;;;1367         
;;;1368         /* Send CMD33 SD_ERASE_GRP_END with argument as addr  */
;;;1369         errorstate = SDMMC_CmdSDEraseEndAdd(hsd->Instance, BlockEndAdd);
;;;1370         if(errorstate != HAL_SD_ERROR_NONE)
;;;1371         {
;;;1372           /* Clear all the static flags */
;;;1373           __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1374           hsd->ErrorCode |= errorstate;
;;;1375           hsd->State = HAL_SD_STATE_READY;
;;;1376           return HAL_ERROR;
;;;1377         }
;;;1378       }
;;;1379       
;;;1380       /* Send CMD38 ERASE */
;;;1381       errorstate = SDMMC_CmdErase(hsd->Instance);
;;;1382       if(errorstate != HAL_SD_ERROR_NONE)
;;;1383       {
;;;1384         /* Clear all the static flags */
;;;1385         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1386         hsd->ErrorCode |= errorstate;
;;;1387         hsd->State = HAL_SD_STATE_READY;
;;;1388         return HAL_ERROR;
;;;1389       }
;;;1390       
;;;1391       hsd->State = HAL_SD_STATE_READY;
;;;1392       
;;;1393       return HAL_OK;
;;;1394     }
;;;1395     else
;;;1396     {
;;;1397       return HAL_BUSY;
;;;1398     }
;;;1399   }
000026  e8bd81f0          POP      {r4-r8,pc}
                  |L6.42|
00002a  6de0              LDR      r0,[r4,#0x5c]         ;1320
00002c  42b0              CMP      r0,r6                 ;1320
00002e  d205              BCS      |L6.60|
000030  6ba0              LDR      r0,[r4,#0x38]         ;1322
000032  f0407000          ORR      r0,r0,#0x2000000      ;1322
000036  63a0              STR      r0,[r4,#0x38]         ;1322
000038  2001              MOVS     r0,#1                 ;1323
00003a  e7f4              B        |L6.38|
                  |L6.60|
00003c  2003              MOVS     r0,#3                 ;1326
00003e  f8840034          STRB     r0,[r4,#0x34]         ;1326
000042  204c              MOVS     r0,#0x4c              ;1329
000044  5d00              LDRB     r0,[r0,r4]            ;1329
000046  f0000020          AND      r0,r0,#0x20           ;1329
00004a  b958              CBNZ     r0,|L6.100|
00004c  f24050ff          MOV      r0,#0x5ff             ;1332
000050  6821              LDR      r1,[r4,#0]            ;1332
000052  6388              STR      r0,[r1,#0x38]         ;1332
000054  6ba0              LDR      r0,[r4,#0x38]         ;1333
000056  f0406080          ORR      r0,r0,#0x4000000      ;1333
00005a  63a0              STR      r0,[r4,#0x38]         ;1333
00005c  2001              MOVS     r0,#1                 ;1334
00005e  f8840034          STRB     r0,[r4,#0x34]         ;1334
000062  e7e0              B        |L6.38|
                  |L6.100|
000064  2100              MOVS     r1,#0                 ;1338
000066  6820              LDR      r0,[r4,#0]            ;1338
000068  f7fffffe          BL       SDIO_GetResponse
00006c  f0007000          AND      r0,r0,#0x2000000      ;1338
000070  f1b07f00          CMP      r0,#0x2000000         ;1338
000074  d10b              BNE      |L6.142|
000076  f24050ff          MOV      r0,#0x5ff             ;1341
00007a  6821              LDR      r1,[r4,#0]            ;1341
00007c  6388              STR      r0,[r1,#0x38]         ;1341
00007e  6ba0              LDR      r0,[r4,#0x38]         ;1342
000080  f4406000          ORR      r0,r0,#0x800          ;1342
000084  63a0              STR      r0,[r4,#0x38]         ;1342
000086  2001              MOVS     r0,#1                 ;1343
000088  f8840034          STRB     r0,[r4,#0x34]         ;1343
00008c  e7cb              B        |L6.38|
                  |L6.142|
00008e  6c60              LDR      r0,[r4,#0x44]         ;1348
000090  2801              CMP      r0,#1                 ;1348
000092  d001              BEQ      |L6.152|
000094  027f              LSLS     r7,r7,#9              ;1350
000096  0276              LSLS     r6,r6,#9              ;1351
                  |L6.152|
000098  6c60              LDR      r0,[r4,#0x44]         ;1355
00009a  2803              CMP      r0,#3                 ;1355
00009c  d021              BEQ      |L6.226|
00009e  4639              MOV      r1,r7                 ;1358
0000a0  6820              LDR      r0,[r4,#0]            ;1358
0000a2  f7fffffe          BL       SDMMC_CmdSDEraseStartAdd
0000a6  4605              MOV      r5,r0                 ;1358
0000a8  b155              CBZ      r5,|L6.192|
0000aa  f24050ff          MOV      r0,#0x5ff             ;1362
0000ae  6821              LDR      r1,[r4,#0]            ;1362
0000b0  6388              STR      r0,[r1,#0x38]         ;1362
0000b2  6ba0              LDR      r0,[r4,#0x38]         ;1363
0000b4  4328              ORRS     r0,r0,r5              ;1363
0000b6  63a0              STR      r0,[r4,#0x38]         ;1363
0000b8  2001              MOVS     r0,#1                 ;1364
0000ba  f8840034          STRB     r0,[r4,#0x34]         ;1364
0000be  e7b2              B        |L6.38|
                  |L6.192|
0000c0  4631              MOV      r1,r6                 ;1369
0000c2  6820              LDR      r0,[r4,#0]            ;1369
0000c4  f7fffffe          BL       SDMMC_CmdSDEraseEndAdd
0000c8  4605              MOV      r5,r0                 ;1369
0000ca  b155              CBZ      r5,|L6.226|
0000cc  f24050ff          MOV      r0,#0x5ff             ;1373
0000d0  6821              LDR      r1,[r4,#0]            ;1373
0000d2  6388              STR      r0,[r1,#0x38]         ;1373
0000d4  6ba0              LDR      r0,[r4,#0x38]         ;1374
0000d6  4328              ORRS     r0,r0,r5              ;1374
0000d8  63a0              STR      r0,[r4,#0x38]         ;1374
0000da  2001              MOVS     r0,#1                 ;1375
0000dc  f8840034          STRB     r0,[r4,#0x34]         ;1375
0000e0  e7a1              B        |L6.38|
                  |L6.226|
0000e2  6820              LDR      r0,[r4,#0]            ;1381
0000e4  f7fffffe          BL       SDMMC_CmdErase
0000e8  4605              MOV      r5,r0                 ;1381
0000ea  b15d              CBZ      r5,|L6.260|
0000ec  f24050ff          MOV      r0,#0x5ff             ;1385
0000f0  6821              LDR      r1,[r4,#0]            ;1385
0000f2  6388              STR      r0,[r1,#0x38]         ;1385
0000f4  6ba0              LDR      r0,[r4,#0x38]         ;1386
0000f6  4328              ORRS     r0,r0,r5              ;1386
0000f8  63a0              STR      r0,[r4,#0x38]         ;1386
0000fa  2001              MOVS     r0,#1                 ;1387
0000fc  f8840034          STRB     r0,[r4,#0x34]         ;1387
000100  e791              B        |L6.38|
000102  e004              B        |L6.270|
                  |L6.260|
000104  2001              MOVS     r0,#1                 ;1391
000106  f8840034          STRB     r0,[r4,#0x34]         ;1391
00010a  2000              MOVS     r0,#0                 ;1393
00010c  e78b              B        |L6.38|
                  |L6.270|
00010e  2002              MOVS     r0,#2                 ;1397
000110  e789              B        |L6.38|
;;;1400   
                          ENDP


                          AREA ||i.HAL_SD_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_ErrorCallback PROC
;;;1678     */
;;;1679   __weak void HAL_SD_ErrorCallback(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;1680   {
;;;1681     /* Prevent unused argument(s) compilation warning */
;;;1682     UNUSED(hsd);
;;;1683    
;;;1684     /* NOTE : This function should not be modified, when the callback is needed,
;;;1685               the HAL_SD_ErrorCallback can be implemented in the user file
;;;1686      */ 
;;;1687   }
;;;1688   
                          ENDP


                          AREA ||i.HAL_SD_GetCardCID||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardCID PROC
;;;1731     */
;;;1732   HAL_StatusTypeDef HAL_SD_GetCardCID(SD_HandleTypeDef *hsd, HAL_SD_CardCIDTypeDef *pCID)
000000  b510              PUSH     {r4,lr}
;;;1733   {
000002  4603              MOV      r3,r0
;;;1734     uint32_t tmp = 0U;
000004  2200              MOVS     r2,#0
;;;1735     
;;;1736     /* Byte 0 */
;;;1737     tmp = (uint8_t)((hsd->CID[0U] & 0xFF000000U) >> 24U);
000006  6f58              LDR      r0,[r3,#0x74]
000008  0e02              LSRS     r2,r0,#24
;;;1738     pCID->ManufacturerID = tmp;
00000a  700a              STRB     r2,[r1,#0]
;;;1739     
;;;1740     /* Byte 1 */
;;;1741     tmp = (uint8_t)((hsd->CID[0U] & 0x00FF0000U) >> 16U);
00000c  6f58              LDR      r0,[r3,#0x74]
00000e  f3c04207          UBFX     r2,r0,#16,#8
;;;1742     pCID->OEM_AppliID = tmp << 8U;
000012  f64f70ff          MOV      r0,#0xffff
000016  ea002002          AND      r0,r0,r2,LSL #8
00001a  8048              STRH     r0,[r1,#2]
;;;1743     
;;;1744     /* Byte 2 */
;;;1745     tmp = (uint8_t)((hsd->CID[0U] & 0x000000FF00U) >> 8U);
00001c  f8b30074          LDRH     r0,[r3,#0x74]
000020  f3c02207          UBFX     r2,r0,#8,#8
;;;1746     pCID->OEM_AppliID |= tmp;
000024  8848              LDRH     r0,[r1,#2]
000026  4310              ORRS     r0,r0,r2
000028  8048              STRH     r0,[r1,#2]
;;;1747     
;;;1748     /* Byte 3 */
;;;1749     tmp = (uint8_t)(hsd->CID[0U] & 0x000000FFU);
00002a  f8932074          LDRB     r2,[r3,#0x74]
;;;1750     pCID->ProdName1 = tmp << 24U;
00002e  0610              LSLS     r0,r2,#24
000030  6048              STR      r0,[r1,#4]
;;;1751     
;;;1752     /* Byte 4 */
;;;1753     tmp = (uint8_t)((hsd->CID[1U] & 0xFF000000U) >> 24U);
000032  6f98              LDR      r0,[r3,#0x78]
000034  0e02              LSRS     r2,r0,#24
;;;1754     pCID->ProdName1 |= tmp << 16;
000036  6848              LDR      r0,[r1,#4]
000038  ea404002          ORR      r0,r0,r2,LSL #16
00003c  6048              STR      r0,[r1,#4]
;;;1755     
;;;1756     /* Byte 5 */
;;;1757     tmp = (uint8_t)((hsd->CID[1U] & 0x00FF0000U) >> 16U);
00003e  6f98              LDR      r0,[r3,#0x78]
000040  f3c04207          UBFX     r2,r0,#16,#8
;;;1758     pCID->ProdName1 |= tmp << 8U;
000044  6848              LDR      r0,[r1,#4]
000046  ea402002          ORR      r0,r0,r2,LSL #8
00004a  6048              STR      r0,[r1,#4]
;;;1759     
;;;1760     /* Byte 6 */
;;;1761     tmp = (uint8_t)((hsd->CID[1U] & 0x0000FF00U) >> 8U);
00004c  2078              MOVS     r0,#0x78
00004e  5ac0              LDRH     r0,[r0,r3]
000050  f3c02207          UBFX     r2,r0,#8,#8
;;;1762     pCID->ProdName1 |= tmp;
000054  6848              LDR      r0,[r1,#4]
000056  4310              ORRS     r0,r0,r2
000058  6048              STR      r0,[r1,#4]
;;;1763     
;;;1764     /* Byte 7 */
;;;1765     tmp = (uint8_t)(hsd->CID[1U] & 0x000000FFU);
00005a  2078              MOVS     r0,#0x78
00005c  5cc2              LDRB     r2,[r0,r3]
;;;1766     pCID->ProdName2 = tmp;
00005e  720a              STRB     r2,[r1,#8]
;;;1767     
;;;1768     /* Byte 8 */
;;;1769     tmp = (uint8_t)((hsd->CID[2U] & 0xFF000000U) >> 24U);
000060  6fd8              LDR      r0,[r3,#0x7c]
000062  0e02              LSRS     r2,r0,#24
;;;1770     pCID->ProdRev = tmp;
000064  724a              STRB     r2,[r1,#9]
;;;1771     
;;;1772     /* Byte 9 */
;;;1773     tmp = (uint8_t)((hsd->CID[2U] & 0x00FF0000U) >> 16U);
000066  6fd8              LDR      r0,[r3,#0x7c]
000068  f3c04207          UBFX     r2,r0,#16,#8
;;;1774     pCID->ProdSN = tmp << 24U;
00006c  0610              LSLS     r0,r2,#24
00006e  60c8              STR      r0,[r1,#0xc]
;;;1775     
;;;1776     /* Byte 10 */
;;;1777     tmp = (uint8_t)((hsd->CID[2U] & 0x0000FF00U) >> 8U);
000070  207c              MOVS     r0,#0x7c
000072  5ac0              LDRH     r0,[r0,r3]
000074  f3c02207          UBFX     r2,r0,#8,#8
;;;1778     pCID->ProdSN |= tmp << 16U;
000078  68c8              LDR      r0,[r1,#0xc]
00007a  ea404002          ORR      r0,r0,r2,LSL #16
00007e  60c8              STR      r0,[r1,#0xc]
;;;1779     
;;;1780     /* Byte 11 */
;;;1781     tmp = (uint8_t)(hsd->CID[2U] & 0x000000FFU);
000080  207c              MOVS     r0,#0x7c
000082  5cc2              LDRB     r2,[r0,r3]
;;;1782     pCID->ProdSN |= tmp << 8U;
000084  68c8              LDR      r0,[r1,#0xc]
000086  ea402002          ORR      r0,r0,r2,LSL #8
00008a  60c8              STR      r0,[r1,#0xc]
;;;1783     
;;;1784     /* Byte 12 */
;;;1785     tmp = (uint8_t)((hsd->CID[3U] & 0xFF000000U) >> 24U);
00008c  2080              MOVS     r0,#0x80
00008e  58c0              LDR      r0,[r0,r3]
000090  0e02              LSRS     r2,r0,#24
;;;1786     pCID->ProdSN |= tmp;
000092  68c8              LDR      r0,[r1,#0xc]
000094  4310              ORRS     r0,r0,r2
000096  60c8              STR      r0,[r1,#0xc]
;;;1787     
;;;1788     /* Byte 13 */
;;;1789     tmp = (uint8_t)((hsd->CID[3U] & 0x00FF0000U) >> 16U);
000098  2080              MOVS     r0,#0x80
00009a  58c0              LDR      r0,[r0,r3]
00009c  f3c04207          UBFX     r2,r0,#16,#8
;;;1790     pCID->Reserved1   |= (tmp & 0xF0U) >> 4U;
0000a0  7c08              LDRB     r0,[r1,#0x10]
0000a2  ea401012          ORR      r0,r0,r2,LSR #4
0000a6  7408              STRB     r0,[r1,#0x10]
;;;1791     pCID->ManufactDate = (tmp & 0x0FU) << 8U;
0000a8  0710              LSLS     r0,r2,#28
0000aa  0d00              LSRS     r0,r0,#20
0000ac  8248              STRH     r0,[r1,#0x12]
;;;1792     
;;;1793     /* Byte 14 */
;;;1794     tmp = (uint8_t)((hsd->CID[3U] & 0x0000FF00U) >> 8U);
0000ae  2080              MOVS     r0,#0x80
0000b0  5ac0              LDRH     r0,[r0,r3]
0000b2  f3c02207          UBFX     r2,r0,#8,#8
;;;1795     pCID->ManufactDate |= tmp;
0000b6  8a48              LDRH     r0,[r1,#0x12]
0000b8  4310              ORRS     r0,r0,r2
0000ba  8248              STRH     r0,[r1,#0x12]
;;;1796     
;;;1797     /* Byte 15 */
;;;1798     tmp = (uint8_t)(hsd->CID[3U] & 0x000000FFU);
0000bc  2080              MOVS     r0,#0x80
0000be  5cc2              LDRB     r2,[r0,r3]
;;;1799     pCID->CID_CRC   = (tmp & 0xFEU) >> 1U;
0000c0  0850              LSRS     r0,r2,#1
0000c2  7508              STRB     r0,[r1,#0x14]
;;;1800     pCID->Reserved2 = 1U;
0000c4  2001              MOVS     r0,#1
0000c6  7548              STRB     r0,[r1,#0x15]
;;;1801   
;;;1802     return HAL_OK;
0000c8  2000              MOVS     r0,#0
;;;1803   }
0000ca  bd10              POP      {r4,pc}
;;;1804   
                          ENDP


                          AREA ||i.HAL_SD_GetCardCSD||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardCSD PROC
;;;1812     */
;;;1813   HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
000000  b530              PUSH     {r4,r5,lr}
;;;1814   {
000002  4603              MOV      r3,r0
;;;1815     uint32_t tmp = 0U;
000004  2200              MOVS     r2,#0
;;;1816     
;;;1817     /* Byte 0 */
;;;1818     tmp = (hsd->CSD[0U] & 0xFF000000U) >> 24U;
000006  6e58              LDR      r0,[r3,#0x64]
000008  0e02              LSRS     r2,r0,#24
;;;1819     pCSD->CSDStruct      = (uint8_t)((tmp & 0xC0U) >> 6U);
00000a  0990              LSRS     r0,r2,#6
00000c  7008              STRB     r0,[r1,#0]
;;;1820     pCSD->SysSpecVersion = (uint8_t)((tmp & 0x3CU) >> 2U);
00000e  f3c20083          UBFX     r0,r2,#2,#4
000012  7048              STRB     r0,[r1,#1]
;;;1821     pCSD->Reserved1      = tmp & 0x03U;
000014  f0020003          AND      r0,r2,#3
000018  7088              STRB     r0,[r1,#2]
;;;1822     
;;;1823     /* Byte 1 */
;;;1824     tmp = (hsd->CSD[0U] & 0x00FF0000U) >> 16U;
00001a  6e58              LDR      r0,[r3,#0x64]
00001c  f3c04207          UBFX     r2,r0,#16,#8
;;;1825     pCSD->TAAC = (uint8_t)tmp;
000020  70ca              STRB     r2,[r1,#3]
;;;1826     
;;;1827     /* Byte 2 */
;;;1828     tmp = (hsd->CSD[0U] & 0x0000FF00U) >> 8U;
000022  f8b30064          LDRH     r0,[r3,#0x64]
000026  f3c02207          UBFX     r2,r0,#8,#8
;;;1829     pCSD->NSAC = (uint8_t)tmp;
00002a  710a              STRB     r2,[r1,#4]
;;;1830     
;;;1831     /* Byte 3 */
;;;1832     tmp = hsd->CSD[0U] & 0x000000FFU;
00002c  f8932064          LDRB     r2,[r3,#0x64]
;;;1833     pCSD->MaxBusClkFrec = (uint8_t)tmp;
000030  714a              STRB     r2,[r1,#5]
;;;1834     
;;;1835     /* Byte 4 */
;;;1836     tmp = (hsd->CSD[1U] & 0xFF000000U) >> 24U;
000032  6e98              LDR      r0,[r3,#0x68]
000034  0e02              LSRS     r2,r0,#24
;;;1837     pCSD->CardComdClasses = (uint16_t)(tmp << 4U);
000036  f64f70ff          MOV      r0,#0xffff
00003a  ea001002          AND      r0,r0,r2,LSL #4
00003e  80c8              STRH     r0,[r1,#6]
;;;1838     
;;;1839     /* Byte 5 */
;;;1840     tmp = (hsd->CSD[1U] & 0x00FF0000U) >> 16U;
000040  6e98              LDR      r0,[r3,#0x68]
000042  f3c04207          UBFX     r2,r0,#16,#8
;;;1841     pCSD->CardComdClasses |= (uint16_t)((tmp & 0xF0U) >> 4U);
000046  88c8              LDRH     r0,[r1,#6]
000048  ea401012          ORR      r0,r0,r2,LSR #4
00004c  80c8              STRH     r0,[r1,#6]
;;;1842     pCSD->RdBlockLen       = (uint8_t)(tmp & 0x0FU);
00004e  f002000f          AND      r0,r2,#0xf
000052  7208              STRB     r0,[r1,#8]
;;;1843     
;;;1844     /* Byte 6 */
;;;1845     tmp = (hsd->CSD[1U] & 0x0000FF00U) >> 8U;
000054  2068              MOVS     r0,#0x68
000056  5ac0              LDRH     r0,[r0,r3]
000058  f3c02207          UBFX     r2,r0,#8,#8
;;;1846     pCSD->PartBlockRead   = (uint8_t)((tmp & 0x80U) >> 7U);
00005c  09d0              LSRS     r0,r2,#7
00005e  7248              STRB     r0,[r1,#9]
;;;1847     pCSD->WrBlockMisalign = (uint8_t)((tmp & 0x40U) >> 6U);
000060  f3c21080          UBFX     r0,r2,#6,#1
000064  7288              STRB     r0,[r1,#0xa]
;;;1848     pCSD->RdBlockMisalign = (uint8_t)((tmp & 0x20U) >> 5U);
000066  f3c21040          UBFX     r0,r2,#5,#1
00006a  72c8              STRB     r0,[r1,#0xb]
;;;1849     pCSD->DSRImpl         = (uint8_t)((tmp & 0x10U) >> 4U);
00006c  f3c21000          UBFX     r0,r2,#4,#1
000070  7308              STRB     r0,[r1,#0xc]
;;;1850     pCSD->Reserved2       = 0U; /*!< Reserved */
000072  2000              MOVS     r0,#0
000074  7348              STRB     r0,[r1,#0xd]
;;;1851          
;;;1852     if(hsd->SdCard.CardType == CARD_SDSC)
000076  6c58              LDR      r0,[r3,#0x44]
000078  2800              CMP      r0,#0
00007a  d13e              BNE      |L9.250|
;;;1853     {
;;;1854       pCSD->DeviceSize = (tmp & 0x03U) << 10U;
00007c  0790              LSLS     r0,r2,#30
00007e  0d00              LSRS     r0,r0,#20
000080  6108              STR      r0,[r1,#0x10]
;;;1855       
;;;1856       /* Byte 7 */
;;;1857       tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
000082  2068              MOVS     r0,#0x68
000084  5cc2              LDRB     r2,[r0,r3]
;;;1858       pCSD->DeviceSize |= (tmp) << 2U;
000086  6908              LDR      r0,[r1,#0x10]
000088  ea400082          ORR      r0,r0,r2,LSL #2
00008c  6108              STR      r0,[r1,#0x10]
;;;1859       
;;;1860       /* Byte 8 */
;;;1861       tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
00008e  6ed8              LDR      r0,[r3,#0x6c]
000090  0e02              LSRS     r2,r0,#24
;;;1862       pCSD->DeviceSize |= (tmp & 0xC0U) >> 6U;
000092  6908              LDR      r0,[r1,#0x10]
000094  ea401092          ORR      r0,r0,r2,LSR #6
000098  6108              STR      r0,[r1,#0x10]
;;;1863       
;;;1864       pCSD->MaxRdCurrentVDDMin = (tmp & 0x38U) >> 3U;
00009a  f3c200c2          UBFX     r0,r2,#3,#3
00009e  7508              STRB     r0,[r1,#0x14]
;;;1865       pCSD->MaxRdCurrentVDDMax = (tmp & 0x07U);
0000a0  f0020007          AND      r0,r2,#7
0000a4  7548              STRB     r0,[r1,#0x15]
;;;1866       
;;;1867       /* Byte 9 */
;;;1868       tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
0000a6  6ed8              LDR      r0,[r3,#0x6c]
0000a8  f3c04207          UBFX     r2,r0,#16,#8
;;;1869       pCSD->MaxWrCurrentVDDMin = (tmp & 0xE0U) >> 5U;
0000ac  0950              LSRS     r0,r2,#5
0000ae  7588              STRB     r0,[r1,#0x16]
;;;1870       pCSD->MaxWrCurrentVDDMax = (tmp & 0x1CU) >> 2U;
0000b0  f3c20082          UBFX     r0,r2,#2,#3
0000b4  75c8              STRB     r0,[r1,#0x17]
;;;1871       pCSD->DeviceSizeMul      = (tmp & 0x03U) << 1U;
0000b6  0790              LSLS     r0,r2,#30
0000b8  0f40              LSRS     r0,r0,#29
0000ba  7608              STRB     r0,[r1,#0x18]
;;;1872       /* Byte 10 */
;;;1873       tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
0000bc  206c              MOVS     r0,#0x6c
0000be  5ac0              LDRH     r0,[r0,r3]
0000c0  f3c02207          UBFX     r2,r0,#8,#8
;;;1874       pCSD->DeviceSizeMul |= (tmp & 0x80U) >> 7U;
0000c4  7e08              LDRB     r0,[r1,#0x18]
0000c6  ea4010d2          ORR      r0,r0,r2,LSR #7
0000ca  7608              STRB     r0,[r1,#0x18]
;;;1875       
;;;1876       hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
0000cc  6908              LDR      r0,[r1,#0x10]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  6558              STR      r0,[r3,#0x54]
;;;1877       hsd->SdCard.BlockNbr *= (1U << (pCSD->DeviceSizeMul + 2U));
0000d2  7e0c              LDRB     r4,[r1,#0x18]
0000d4  6d58              LDR      r0,[r3,#0x54]
0000d6  1ca4              ADDS     r4,r4,#2
0000d8  2501              MOVS     r5,#1
0000da  40a5              LSLS     r5,r5,r4
0000dc  4368              MULS     r0,r5,r0
0000de  6558              STR      r0,[r3,#0x54]
;;;1878       hsd->SdCard.BlockSize = 1U << (pCSD->RdBlockLen);
0000e0  7a0c              LDRB     r4,[r1,#8]
0000e2  2001              MOVS     r0,#1
0000e4  40a0              LSLS     r0,r0,r4
0000e6  6598              STR      r0,[r3,#0x58]
;;;1879   
;;;1880       hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U); 
0000e8  e9d30415          LDRD     r0,r4,[r3,#0x54]
0000ec  0a64              LSRS     r4,r4,#9
0000ee  4360              MULS     r0,r4,r0
0000f0  65d8              STR      r0,[r3,#0x5c]
;;;1881       hsd->SdCard.LogBlockSize = 512U;
0000f2  f44f7400          MOV      r4,#0x200
0000f6  661c              STR      r4,[r3,#0x60]
0000f8  e030              B        |L9.348|
                  |L9.250|
;;;1882     }
;;;1883     else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
0000fa  6c58              LDR      r0,[r3,#0x44]
0000fc  2801              CMP      r0,#1
0000fe  d121              BNE      |L9.324|
;;;1884     {
;;;1885       /* Byte 7 */
;;;1886       tmp = (uint8_t)(hsd->CSD[1U] & 0x000000FFU);
000100  2068              MOVS     r0,#0x68
000102  5cc2              LDRB     r2,[r0,r3]
;;;1887       pCSD->DeviceSize = (tmp & 0x3FU) << 16U;
000104  0690              LSLS     r0,r2,#26
000106  0a80              LSRS     r0,r0,#10
000108  6108              STR      r0,[r1,#0x10]
;;;1888       
;;;1889       /* Byte 8 */
;;;1890       tmp = (uint8_t)((hsd->CSD[2U] & 0xFF000000U) >> 24U);
00010a  6ed8              LDR      r0,[r3,#0x6c]
00010c  0e02              LSRS     r2,r0,#24
;;;1891       
;;;1892       pCSD->DeviceSize |= (tmp << 8U);
00010e  6908              LDR      r0,[r1,#0x10]
000110  ea402002          ORR      r0,r0,r2,LSL #8
000114  6108              STR      r0,[r1,#0x10]
;;;1893       
;;;1894       /* Byte 9 */
;;;1895       tmp = (uint8_t)((hsd->CSD[2U] & 0x00FF0000U) >> 16U);
000116  6ed8              LDR      r0,[r3,#0x6c]
000118  f3c04207          UBFX     r2,r0,#16,#8
;;;1896       
;;;1897       pCSD->DeviceSize |= (tmp);
00011c  6908              LDR      r0,[r1,#0x10]
00011e  4310              ORRS     r0,r0,r2
000120  6108              STR      r0,[r1,#0x10]
;;;1898       
;;;1899       /* Byte 10 */
;;;1900       tmp = (uint8_t)((hsd->CSD[2U] & 0x0000FF00U) >> 8U);
000122  206c              MOVS     r0,#0x6c
000124  5ac0              LDRH     r0,[r0,r3]
000126  f3c02207          UBFX     r2,r0,#8,#8
;;;1901       
;;;1902       hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr = (((uint64_t)pCSD->DeviceSize + 1U) * 1024U);
00012a  6908              LDR      r0,[r1,#0x10]
00012c  1c44              ADDS     r4,r0,#1
00012e  f44f6080          MOV      r0,#0x400
000132  fba40400          UMULL    r0,r4,r4,r0
000136  6558              STR      r0,[r3,#0x54]
000138  65d8              STR      r0,[r3,#0x5c]
;;;1903       hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize = 512U;
00013a  f44f7400          MOV      r4,#0x200
00013e  659c              STR      r4,[r3,#0x58]
000140  661c              STR      r4,[r3,#0x60]
000142  e00b              B        |L9.348|
                  |L9.324|
;;;1904     }
;;;1905     else
;;;1906     {
;;;1907       /* Clear all the static flags */
;;;1908       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);   
000144  f24050ff          MOV      r0,#0x5ff
000148  681c              LDR      r4,[r3,#0]
00014a  63a0              STR      r0,[r4,#0x38]
;;;1909       hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
00014c  6b98              LDR      r0,[r3,#0x38]
00014e  f0405080          ORR      r0,r0,#0x10000000
000152  6398              STR      r0,[r3,#0x38]
;;;1910       hsd->State = HAL_SD_STATE_READY;
000154  2001              MOVS     r0,#1
000156  f8830034          STRB     r0,[r3,#0x34]
                  |L9.346|
;;;1911       return HAL_ERROR;
;;;1912     }
;;;1913     
;;;1914     pCSD->EraseGrSize = (tmp & 0x40U) >> 6U;
;;;1915     pCSD->EraseGrMul  = (tmp & 0x3FU) << 1U;
;;;1916     
;;;1917     /* Byte 11 */
;;;1918     tmp = (uint8_t)(hsd->CSD[2U] & 0x000000FFU);
;;;1919     pCSD->EraseGrMul     |= (tmp & 0x80U) >> 7U;
;;;1920     pCSD->WrProtectGrSize = (tmp & 0x7FU);
;;;1921     
;;;1922     /* Byte 12 */
;;;1923     tmp = (uint8_t)((hsd->CSD[3U] & 0xFF000000U) >> 24U);
;;;1924     pCSD->WrProtectGrEnable = (tmp & 0x80U) >> 7U;
;;;1925     pCSD->ManDeflECC        = (tmp & 0x60U) >> 5U;
;;;1926     pCSD->WrSpeedFact       = (tmp & 0x1CU) >> 2U;
;;;1927     pCSD->MaxWrBlockLen     = (tmp & 0x03U) << 2U;
;;;1928     
;;;1929     /* Byte 13 */
;;;1930     tmp = (uint8_t)((hsd->CSD[3U] & 0x00FF0000U) >> 16U);
;;;1931     pCSD->MaxWrBlockLen      |= (tmp & 0xC0U) >> 6U;
;;;1932     pCSD->WriteBlockPaPartial = (tmp & 0x20U) >> 5U;
;;;1933     pCSD->Reserved3           = 0U;
;;;1934     pCSD->ContentProtectAppli = (tmp & 0x01U);
;;;1935     
;;;1936     /* Byte 14 */
;;;1937     tmp = (uint8_t)((hsd->CSD[3U] & 0x0000FF00U) >> 8U);
;;;1938     pCSD->FileFormatGrouop = (tmp & 0x80U) >> 7U;
;;;1939     pCSD->CopyFlag         = (tmp & 0x40U) >> 6U;
;;;1940     pCSD->PermWrProtect    = (tmp & 0x20U) >> 5U;
;;;1941     pCSD->TempWrProtect    = (tmp & 0x10U) >> 4U;
;;;1942     pCSD->FileFormat       = (tmp & 0x0CU) >> 2U;
;;;1943     pCSD->ECC              = (tmp & 0x03U);
;;;1944     
;;;1945     /* Byte 15 */
;;;1946     tmp = (uint8_t)(hsd->CSD[3U] & 0x000000FFU);
;;;1947     pCSD->CSD_CRC   = (tmp & 0xFEU) >> 1U;
;;;1948     pCSD->Reserved4 = 1U;
;;;1949     
;;;1950     return HAL_OK;
;;;1951   }
00015a  bd30              POP      {r4,r5,pc}
                  |L9.348|
00015c  f3c21080          UBFX     r0,r2,#6,#1           ;1914
000160  f8010f19          STRB     r0,[r1,#0x19]!        ;1914
000164  0690              LSLS     r0,r2,#26             ;1915
000166  0e40              LSRS     r0,r0,#25             ;1915
000168  7048              STRB     r0,[r1,#1]            ;1915
00016a  206c              MOVS     r0,#0x6c              ;1918
00016c  5cc2              LDRB     r2,[r0,r3]            ;1918
00016e  7848              LDRB     r0,[r1,#1]            ;1919
000170  ea4010d2          ORR      r0,r0,r2,LSR #7       ;1919
000174  7048              STRB     r0,[r1,#1]            ;1919
000176  f002007f          AND      r0,r2,#0x7f           ;1920
00017a  7088              STRB     r0,[r1,#2]            ;1920
00017c  6f18              LDR      r0,[r3,#0x70]         ;1923
00017e  0e02              LSRS     r2,r0,#24             ;1923
000180  09d0              LSRS     r0,r2,#7              ;1924
000182  70c8              STRB     r0,[r1,#3]            ;1924
000184  f3c21041          UBFX     r0,r2,#5,#2           ;1925
000188  7108              STRB     r0,[r1,#4]            ;1925
00018a  f3c20082          UBFX     r0,r2,#2,#3           ;1926
00018e  7148              STRB     r0,[r1,#5]            ;1926
000190  0790              LSLS     r0,r2,#30             ;1927
000192  0f00              LSRS     r0,r0,#28             ;1927
000194  7188              STRB     r0,[r1,#6]            ;1927
000196  6f18              LDR      r0,[r3,#0x70]         ;1930
000198  f3c04207          UBFX     r2,r0,#16,#8          ;1930
00019c  7988              LDRB     r0,[r1,#6]            ;1931
00019e  ea401092          ORR      r0,r0,r2,LSR #6       ;1931
0001a2  7188              STRB     r0,[r1,#6]            ;1931
0001a4  f3c21040          UBFX     r0,r2,#5,#1           ;1932
0001a8  71c8              STRB     r0,[r1,#7]            ;1932
0001aa  2000              MOVS     r0,#0                 ;1933
0001ac  7208              STRB     r0,[r1,#8]            ;1933
0001ae  f0020001          AND      r0,r2,#1              ;1934
0001b2  7248              STRB     r0,[r1,#9]            ;1934
0001b4  2070              MOVS     r0,#0x70              ;1937
0001b6  5ac0              LDRH     r0,[r0,r3]            ;1937
0001b8  f3c02207          UBFX     r2,r0,#8,#8           ;1937
0001bc  09d0              LSRS     r0,r2,#7              ;1938
0001be  7288              STRB     r0,[r1,#0xa]          ;1938
0001c0  f3c21080          UBFX     r0,r2,#6,#1           ;1939
0001c4  72c8              STRB     r0,[r1,#0xb]          ;1939
0001c6  f3c21040          UBFX     r0,r2,#5,#1           ;1940
0001ca  7308              STRB     r0,[r1,#0xc]          ;1940
0001cc  f3c21000          UBFX     r0,r2,#4,#1           ;1941
0001d0  7348              STRB     r0,[r1,#0xd]          ;1941
0001d2  f3c20081          UBFX     r0,r2,#2,#2           ;1942
0001d6  7388              STRB     r0,[r1,#0xe]          ;1942
0001d8  f0020003          AND      r0,r2,#3              ;1943
0001dc  73c8              STRB     r0,[r1,#0xf]          ;1943
0001de  2070              MOVS     r0,#0x70              ;1946
0001e0  5cc2              LDRB     r2,[r0,r3]            ;1946
0001e2  0850              LSRS     r0,r2,#1              ;1947
0001e4  7408              STRB     r0,[r1,#0x10]         ;1947
0001e6  2001              MOVS     r0,#1                 ;1948
0001e8  7448              STRB     r0,[r1,#0x11]         ;1948
0001ea  3919              SUBS     r1,r1,#0x19           ;1948
0001ec  2000              MOVS     r0,#0                 ;1950
0001ee  e7b4              B        |L9.346|
;;;1952   
                          ENDP


                          AREA ||i.HAL_SD_GetCardInfo||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardInfo PROC
;;;2047     */
;;;2048   HAL_StatusTypeDef HAL_SD_GetCardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypeDef *pCardInfo)
000000  4602              MOV      r2,r0
;;;2049   {
;;;2050     pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
000002  6c50              LDR      r0,[r2,#0x44]
000004  6008              STR      r0,[r1,#0]
;;;2051     pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
000006  6c90              LDR      r0,[r2,#0x48]
000008  6048              STR      r0,[r1,#4]
;;;2052     pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
00000a  6cd0              LDR      r0,[r2,#0x4c]
00000c  6088              STR      r0,[r1,#8]
;;;2053     pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
00000e  6d10              LDR      r0,[r2,#0x50]
000010  60c8              STR      r0,[r1,#0xc]
;;;2054     pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
000012  6d50              LDR      r0,[r2,#0x54]
000014  6108              STR      r0,[r1,#0x10]
;;;2055     pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
000016  6d90              LDR      r0,[r2,#0x58]
000018  6148              STR      r0,[r1,#0x14]
;;;2056     pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
00001a  6dd0              LDR      r0,[r2,#0x5c]
00001c  6188              STR      r0,[r1,#0x18]
;;;2057     pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
00001e  6e10              LDR      r0,[r2,#0x60]
000020  61c8              STR      r0,[r1,#0x1c]
;;;2058     
;;;2059     return HAL_OK;
000022  2000              MOVS     r0,#0
;;;2060   }
000024  4770              BX       lr
;;;2061   
                          ENDP


                          AREA ||i.HAL_SD_GetCardState||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardState PROC
;;;2144     */
;;;2145   HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2146   {
000002  4604              MOV      r4,r0
;;;2147     HAL_SD_CardStateTypeDef cardstate =  HAL_SD_CARD_TRANSFER;
000004  2604              MOVS     r6,#4
;;;2148     uint32_t errorstate = HAL_SD_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;2149     uint32_t resp1 = 0;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;2150     
;;;2151     errorstate = SD_SendStatus(hsd, &resp1);
00000c  4669              MOV      r1,sp
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       SD_SendStatus
000014  4605              MOV      r5,r0
;;;2152     if(errorstate != HAL_OK)
000016  b115              CBZ      r5,|L11.30|
;;;2153     {
;;;2154       hsd->ErrorCode |= errorstate;
000018  6ba0              LDR      r0,[r4,#0x38]
00001a  4328              ORRS     r0,r0,r5
00001c  63a0              STR      r0,[r4,#0x38]
                  |L11.30|
;;;2155     }
;;;2156   
;;;2157     cardstate = (HAL_SD_CardStateTypeDef)((resp1 >> 9U) & 0x0FU);
00001e  9800              LDR      r0,[sp,#0]
000020  f3c02643          UBFX     r6,r0,#9,#4
;;;2158     
;;;2159     return cardstate;
000024  4630              MOV      r0,r6
;;;2160   }
000026  bdf8              POP      {r3-r7,pc}
;;;2161   
                          ENDP


                          AREA ||i.HAL_SD_GetCardStatus||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetCardStatus PROC
;;;1959     */
;;;1960   HAL_StatusTypeDef HAL_SD_GetCardStatus(SD_HandleTypeDef *hsd, HAL_SD_CardStatusTypeDef *pStatus)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1961   {
000002  b091              SUB      sp,sp,#0x44
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;1962     uint32_t tmp = 0U;
000008  2400              MOVS     r4,#0
;;;1963     uint32_t sd_status[16U];
;;;1964     uint32_t errorstate = HAL_SD_ERROR_NONE;
00000a  2700              MOVS     r7,#0
;;;1965     
;;;1966     errorstate = SD_SendSDStatus(hsd, sd_status);
00000c  a901              ADD      r1,sp,#4
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       SD_SendSDStatus
000014  4607              MOV      r7,r0
;;;1967     if(errorstate != HAL_OK)
000016  b15f              CBZ      r7,|L12.48|
;;;1968     {
;;;1969       /* Clear all the static flags */
;;;1970       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);   
000018  f24050ff          MOV      r0,#0x5ff
00001c  6831              LDR      r1,[r6,#0]
00001e  6388              STR      r0,[r1,#0x38]
;;;1971       hsd->ErrorCode |= errorstate;
000020  6bb0              LDR      r0,[r6,#0x38]
000022  4338              ORRS     r0,r0,r7
000024  63b0              STR      r0,[r6,#0x38]
;;;1972       hsd->State = HAL_SD_STATE_READY;
000026  2001              MOVS     r0,#1
000028  f8860034          STRB     r0,[r6,#0x34]
                  |L12.44|
;;;1973       return HAL_ERROR;
;;;1974     }
;;;1975     else
;;;1976     {
;;;1977       /* Byte 0 */
;;;1978       tmp = (sd_status[0U] & 0xC0U) >> 6U;
;;;1979       pStatus->DataBusWidth = (uint8_t)tmp;
;;;1980       
;;;1981       /* Byte 0 */
;;;1982       tmp = (sd_status[0U] & 0x20U) >> 5U;
;;;1983       pStatus->SecuredMode = (uint8_t)tmp;
;;;1984       
;;;1985       /* Byte 2 */
;;;1986       tmp = (sd_status[0U] & 0x00FF0000U) >> 16U;
;;;1987       pStatus->CardType = (uint16_t)(tmp << 8U);
;;;1988       
;;;1989       /* Byte 3 */
;;;1990       tmp = (sd_status[0U] & 0xFF000000U) >> 24U;
;;;1991       pStatus->CardType |= (uint16_t)tmp;
;;;1992       
;;;1993       /* Byte 4 */
;;;1994       tmp = (sd_status[1U] & 0xFFU);
;;;1995       pStatus->ProtectedAreaSize = (uint32_t)(tmp << 24U);
;;;1996       
;;;1997       /* Byte 5 */
;;;1998       tmp = (sd_status[1U] & 0xFF00U) >> 8U;
;;;1999       pStatus->ProtectedAreaSize |= (uint32_t)(tmp << 16U);
;;;2000       
;;;2001       /* Byte 6 */
;;;2002       tmp = (sd_status[1U] & 0xFF0000U) >> 16U;
;;;2003       pStatus->ProtectedAreaSize |= (uint32_t)(tmp << 8U);
;;;2004       
;;;2005       /* Byte 7 */
;;;2006       tmp = (sd_status[1U] & 0xFF000000U) >> 24U;
;;;2007       pStatus->ProtectedAreaSize |= (uint32_t)tmp;
;;;2008       
;;;2009       /* Byte 8 */
;;;2010       tmp = (sd_status[2U] & 0xFFU);
;;;2011       pStatus->SpeedClass = (uint8_t)tmp;
;;;2012       
;;;2013       /* Byte 9 */
;;;2014       tmp = (sd_status[2U] & 0xFF00U) >> 8U;
;;;2015       pStatus->PerformanceMove = (uint8_t)tmp;
;;;2016       
;;;2017       /* Byte 10 */
;;;2018       tmp = (sd_status[2U] & 0xF00000U) >> 20U;
;;;2019       pStatus->AllocationUnitSize = (uint8_t)tmp;
;;;2020       
;;;2021       /* Byte 11 */
;;;2022       tmp = (sd_status[2U] & 0xFF000000U) >> 24U;
;;;2023       pStatus->EraseSize = (uint16_t)(tmp << 8U);
;;;2024       
;;;2025       /* Byte 12 */
;;;2026       tmp = (sd_status[3U] & 0xFFU);
;;;2027       pStatus->EraseSize |= (uint16_t)tmp;
;;;2028       
;;;2029       /* Byte 13 */
;;;2030       tmp = (sd_status[3U] & 0xFC00U) >> 10U;
;;;2031       pStatus->EraseTimeout = (uint8_t)tmp;
;;;2032       
;;;2033       /* Byte 13 */
;;;2034       tmp = (sd_status[3U] & 0x0300U) >> 8U;
;;;2035       pStatus->EraseOffset = (uint8_t)tmp;
;;;2036     }
;;;2037     
;;;2038     return HAL_OK;
;;;2039   }
00002c  b011              ADD      sp,sp,#0x44
00002e  bdf0              POP      {r4-r7,pc}
                  |L12.48|
000030  9801              LDR      r0,[sp,#4]            ;1978
000032  f3c01481          UBFX     r4,r0,#6,#2           ;1978
000036  702c              STRB     r4,[r5,#0]            ;1979
000038  9801              LDR      r0,[sp,#4]            ;1982
00003a  f3c01440          UBFX     r4,r0,#5,#1           ;1982
00003e  706c              STRB     r4,[r5,#1]            ;1983
000040  9801              LDR      r0,[sp,#4]            ;1986
000042  f3c04407          UBFX     r4,r0,#16,#8          ;1986
000046  f64f70ff          MOV      r0,#0xffff            ;1987
00004a  ea002004          AND      r0,r0,r4,LSL #8       ;1987
00004e  8068              STRH     r0,[r5,#2]            ;1987
000050  9801              LDR      r0,[sp,#4]            ;1990
000052  0e04              LSRS     r4,r0,#24             ;1990
000054  8868              LDRH     r0,[r5,#2]            ;1991
000056  4320              ORRS     r0,r0,r4              ;1991
000058  8068              STRH     r0,[r5,#2]            ;1991
00005a  9802              LDR      r0,[sp,#8]            ;1994
00005c  b2c4              UXTB     r4,r0                 ;1994
00005e  0620              LSLS     r0,r4,#24             ;1995
000060  6068              STR      r0,[r5,#4]            ;1995
000062  9802              LDR      r0,[sp,#8]            ;1998
000064  f3c02407          UBFX     r4,r0,#8,#8           ;1998
000068  6868              LDR      r0,[r5,#4]            ;1999
00006a  ea404004          ORR      r0,r0,r4,LSL #16      ;1999
00006e  6068              STR      r0,[r5,#4]            ;1999
000070  9802              LDR      r0,[sp,#8]            ;2002
000072  f3c04407          UBFX     r4,r0,#16,#8          ;2002
000076  6868              LDR      r0,[r5,#4]            ;2003
000078  ea402004          ORR      r0,r0,r4,LSL #8       ;2003
00007c  6068              STR      r0,[r5,#4]            ;2003
00007e  9802              LDR      r0,[sp,#8]            ;2006
000080  0e04              LSRS     r4,r0,#24             ;2006
000082  6868              LDR      r0,[r5,#4]            ;2007
000084  4320              ORRS     r0,r0,r4              ;2007
000086  6068              STR      r0,[r5,#4]            ;2007
000088  9803              LDR      r0,[sp,#0xc]          ;2010
00008a  b2c4              UXTB     r4,r0                 ;2010
00008c  722c              STRB     r4,[r5,#8]            ;2011
00008e  9803              LDR      r0,[sp,#0xc]          ;2014
000090  f3c02407          UBFX     r4,r0,#8,#8           ;2014
000094  726c              STRB     r4,[r5,#9]            ;2015
000096  9803              LDR      r0,[sp,#0xc]          ;2018
000098  f3c05403          UBFX     r4,r0,#20,#4          ;2018
00009c  72ac              STRB     r4,[r5,#0xa]          ;2019
00009e  9803              LDR      r0,[sp,#0xc]          ;2022
0000a0  0e04              LSRS     r4,r0,#24             ;2022
0000a2  f64f70ff          MOV      r0,#0xffff            ;2023
0000a6  ea002004          AND      r0,r0,r4,LSL #8       ;2023
0000aa  81a8              STRH     r0,[r5,#0xc]          ;2023
0000ac  9804              LDR      r0,[sp,#0x10]         ;2026
0000ae  b2c4              UXTB     r4,r0                 ;2026
0000b0  89a8              LDRH     r0,[r5,#0xc]          ;2027
0000b2  4320              ORRS     r0,r0,r4              ;2027
0000b4  81a8              STRH     r0,[r5,#0xc]          ;2027
0000b6  9804              LDR      r0,[sp,#0x10]         ;2030
0000b8  f3c02485          UBFX     r4,r0,#10,#6          ;2030
0000bc  73ac              STRB     r4,[r5,#0xe]          ;2031
0000be  9804              LDR      r0,[sp,#0x10]         ;2034
0000c0  f3c02401          UBFX     r4,r0,#8,#2           ;2034
0000c4  73ec              STRB     r4,[r5,#0xf]          ;2035
0000c6  2000              MOVS     r0,#0                 ;2038
0000c8  e7b0              B        |L12.44|
;;;2040   
                          ENDP


                          AREA ||i.HAL_SD_GetError||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetError PROC
;;;1638   */
;;;1639   uint32_t HAL_SD_GetError(SD_HandleTypeDef *hsd)
000000  4601              MOV      r1,r0
;;;1640   {
;;;1641     return hsd->ErrorCode;
000002  6b88              LDR      r0,[r1,#0x38]
;;;1642   }
000004  4770              BX       lr
;;;1643   
                          ENDP


                          AREA ||i.HAL_SD_GetState||, CODE, READONLY, ALIGN=1

                  HAL_SD_GetState PROC
;;;1627     */
;;;1628   HAL_SD_StateTypeDef HAL_SD_GetState(SD_HandleTypeDef *hsd)
000000  4601              MOV      r1,r0
;;;1629   {
;;;1630     return hsd->State;
000002  f8910034          LDRB     r0,[r1,#0x34]
;;;1631   }
000006  4770              BX       lr
;;;1632   
                          ENDP


                          AREA ||i.HAL_SD_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_SD_IRQHandler PROC
;;;1405     */
;;;1406   void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
000000  b570              PUSH     {r4-r6,lr}
;;;1407   {
000002  4604              MOV      r4,r0
;;;1408     uint32_t errorstate = HAL_SD_ERROR_NONE;
000004  2500              MOVS     r5,#0
;;;1409     
;;;1410     /* Check for SDIO interrupt flags */
;;;1411     if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DATAEND) != RESET)
000006  6820              LDR      r0,[r4,#0]
000008  6b40              LDR      r0,[r0,#0x34]
00000a  f3c02000          UBFX     r0,r0,#8,#1
00000e  2800              CMP      r0,#0
000010  d063              BEQ      |L15.218|
;;;1412     {
;;;1413       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DATAEND); 
000012  f44f7080          MOV      r0,#0x100
000016  6821              LDR      r1,[r4,#0]
000018  6388              STR      r0,[r1,#0x38]
;;;1414       
;;;1415   #ifdef SDIO_STA_STBITERR
;;;1416       __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
00001a  6820              LDR      r0,[r4,#0]
00001c  6bc0              LDR      r0,[r0,#0x3c]
00001e  f240313a          MOV      r1,#0x33a
000022  4388              BICS     r0,r0,r1
000024  6821              LDR      r1,[r4,#0]
000026  63c8              STR      r0,[r1,#0x3c]
;;;1417                                SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR | SDIO_IT_STBITERR);
;;;1418   #else /* SDIO_STA_STBITERR not defined */
;;;1419       __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
;;;1420                                SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);
;;;1421   #endif
;;;1422       
;;;1423       if((hsd->Context & SD_CONTEXT_IT) != RESET)
000028  6b20              LDR      r0,[r4,#0x30]
00002a  f0000008          AND      r0,r0,#8
00002e  b348              CBZ      r0,|L15.132|
;;;1424       {
;;;1425         if(((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != RESET) || ((hsd->Context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != RESET))
000030  6b20              LDR      r0,[r4,#0x30]
000032  f0000002          AND      r0,r0,#2
000036  b918              CBNZ     r0,|L15.64|
000038  6b20              LDR      r0,[r4,#0x30]
00003a  f0000020          AND      r0,r0,#0x20
00003e  b150              CBZ      r0,|L15.86|
                  |L15.64|
;;;1426         {
;;;1427           errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
000040  6820              LDR      r0,[r4,#0]
000042  f7fffffe          BL       SDMMC_CmdStopTransfer
000046  4605              MOV      r5,r0
;;;1428           if(errorstate != HAL_SD_ERROR_NONE)
000048  b12d              CBZ      r5,|L15.86|
;;;1429           {
;;;1430             hsd->ErrorCode |= errorstate;
00004a  6ba0              LDR      r0,[r4,#0x38]
00004c  4328              ORRS     r0,r0,r5
00004e  63a0              STR      r0,[r4,#0x38]
;;;1431             HAL_SD_ErrorCallback(hsd);
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       HAL_SD_ErrorCallback
                  |L15.86|
;;;1432           }
;;;1433         }
;;;1434         
;;;1435         /* Clear all the static flags */
;;;1436         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
000056  f24050ff          MOV      r0,#0x5ff
00005a  6821              LDR      r1,[r4,#0]
00005c  6388              STR      r0,[r1,#0x38]
;;;1437         
;;;1438         hsd->State = HAL_SD_STATE_READY;
00005e  2001              MOVS     r0,#1
000060  f8840034          STRB     r0,[r4,#0x34]
;;;1439         if(((hsd->Context & SD_CONTEXT_READ_SINGLE_BLOCK) != RESET) || ((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != RESET))
000064  6b20              LDR      r0,[r4,#0x30]
000066  f0000001          AND      r0,r0,#1
00006a  b918              CBNZ     r0,|L15.116|
00006c  6b20              LDR      r0,[r4,#0x30]
00006e  f0000002          AND      r0,r0,#2
000072  b118              CBZ      r0,|L15.124|
                  |L15.116|
;;;1440         {
;;;1441           HAL_SD_RxCpltCallback(hsd);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       HAL_SD_RxCpltCallback
                  |L15.122|
00007a  e0bc              B        |L15.502|
                  |L15.124|
;;;1442         }
;;;1443         else
;;;1444         {
;;;1445           HAL_SD_TxCpltCallback(hsd);
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       HAL_SD_TxCpltCallback
000082  e0b8              B        |L15.502|
                  |L15.132|
;;;1446         }
;;;1447       }
;;;1448       else if((hsd->Context & SD_CONTEXT_DMA) != RESET)
000084  6b20              LDR      r0,[r4,#0x30]
000086  f0000080          AND      r0,r0,#0x80
00008a  2800              CMP      r0,#0
00008c  d0f5              BEQ      |L15.122|
;;;1449       {
;;;1450         if((hsd->Context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != RESET)
00008e  6b20              LDR      r0,[r4,#0x30]
000090  f0000020          AND      r0,r0,#0x20
000094  b150              CBZ      r0,|L15.172|
;;;1451         {
;;;1452           errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
000096  6820              LDR      r0,[r4,#0]
000098  f7fffffe          BL       SDMMC_CmdStopTransfer
00009c  4605              MOV      r5,r0
;;;1453           if(errorstate != HAL_SD_ERROR_NONE)
00009e  b12d              CBZ      r5,|L15.172|
;;;1454           {
;;;1455             hsd->ErrorCode |= errorstate;
0000a0  6ba0              LDR      r0,[r4,#0x38]
0000a2  4328              ORRS     r0,r0,r5
0000a4  63a0              STR      r0,[r4,#0x38]
;;;1456             HAL_SD_ErrorCallback(hsd);
0000a6  4620              MOV      r0,r4
0000a8  f7fffffe          BL       HAL_SD_ErrorCallback
                  |L15.172|
;;;1457           }
;;;1458         }
;;;1459         if(((hsd->Context & SD_CONTEXT_READ_SINGLE_BLOCK) == RESET) && ((hsd->Context & SD_CONTEXT_READ_MULTIPLE_BLOCK) == RESET))
0000ac  6b20              LDR      r0,[r4,#0x30]
0000ae  f0000001          AND      r0,r0,#1
0000b2  2800              CMP      r0,#0
0000b4  d1e1              BNE      |L15.122|
0000b6  6b20              LDR      r0,[r4,#0x30]
0000b8  f0000002          AND      r0,r0,#2
0000bc  2800              CMP      r0,#0
0000be  d1dc              BNE      |L15.122|
;;;1460         {
;;;1461           /* Disable the DMA transfer for transmit request by setting the DMAEN bit
;;;1462           in the SD DCTRL register */
;;;1463           hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
0000c0  6820              LDR      r0,[r4,#0]
0000c2  6ac0              LDR      r0,[r0,#0x2c]
0000c4  f0200008          BIC      r0,r0,#8
0000c8  6821              LDR      r1,[r4,#0]
0000ca  62c8              STR      r0,[r1,#0x2c]
;;;1464           
;;;1465           hsd->State = HAL_SD_STATE_READY;
0000cc  2001              MOVS     r0,#1
0000ce  f8840034          STRB     r0,[r4,#0x34]
;;;1466           
;;;1467           HAL_SD_TxCpltCallback(hsd);
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       HAL_SD_TxCpltCallback
0000d8  e08d              B        |L15.502|
                  |L15.218|
;;;1468         }
;;;1469       }
;;;1470     }
;;;1471     
;;;1472     else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_TXFIFOHE) != RESET)
0000da  6820              LDR      r0,[r4,#0]
0000dc  6b40              LDR      r0,[r0,#0x34]
0000de  f3c03080          UBFX     r0,r0,#14,#1
0000e2  b138              CBZ      r0,|L15.244|
;;;1473     {
;;;1474       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_TXFIFOHE);
0000e4  f44f4080          MOV      r0,#0x4000
0000e8  6821              LDR      r1,[r4,#0]
0000ea  6388              STR      r0,[r1,#0x38]
;;;1475       
;;;1476       SD_Write_IT(hsd);
0000ec  4620              MOV      r0,r4
0000ee  f7fffffe          BL       SD_Write_IT
0000f2  e080              B        |L15.502|
                  |L15.244|
;;;1477     }
;;;1478     
;;;1479     else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_RXFIFOHF) != RESET)
0000f4  6820              LDR      r0,[r4,#0]
0000f6  6b40              LDR      r0,[r0,#0x34]
0000f8  f3c030c0          UBFX     r0,r0,#15,#1
0000fc  b138              CBZ      r0,|L15.270|
;;;1480     {
;;;1481       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_RXFIFOHF);
0000fe  f44f4000          MOV      r0,#0x8000
000102  6821              LDR      r1,[r4,#0]
000104  6388              STR      r0,[r1,#0x38]
;;;1482       
;;;1483       SD_Read_IT(hsd);
000106  4620              MOV      r0,r4
000108  f7fffffe          BL       SD_Read_IT
00010c  e073              B        |L15.502|
                  |L15.270|
;;;1484     }
;;;1485     
;;;1486   #ifdef SDIO_STA_STBITERR
;;;1487     else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR) != RESET)
00010e  6820              LDR      r0,[r4,#0]
000110  6b40              LDR      r0,[r0,#0x34]
000112  f240213a          MOV      r1,#0x23a
000116  4008              ANDS     r0,r0,r1
000118  b108              CBZ      r0,|L15.286|
00011a  2001              MOVS     r0,#1
00011c  e000              B        |L15.288|
                  |L15.286|
00011e  2000              MOVS     r0,#0
                  |L15.288|
000120  2800              CMP      r0,#0
000122  d068              BEQ      |L15.502|
;;;1488     {
;;;1489       /* Set Error code */
;;;1490       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DCRCFAIL) != RESET)
000124  6820              LDR      r0,[r4,#0]
000126  6b40              LDR      r0,[r0,#0x34]
000128  f3c00040          UBFX     r0,r0,#1,#1
00012c  b118              CBZ      r0,|L15.310|
;;;1491       {
;;;1492         hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL; 
00012e  6ba0              LDR      r0,[r4,#0x38]
000130  f0400002          ORR      r0,r0,#2
000134  63a0              STR      r0,[r4,#0x38]
                  |L15.310|
;;;1493       }
;;;1494       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DTIMEOUT) != RESET)
000136  6820              LDR      r0,[r4,#0]
000138  6b40              LDR      r0,[r0,#0x34]
00013a  f3c000c0          UBFX     r0,r0,#3,#1
00013e  b118              CBZ      r0,|L15.328|
;;;1495       {
;;;1496         hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT; 
000140  6ba0              LDR      r0,[r4,#0x38]
000142  f0400008          ORR      r0,r0,#8
000146  63a0              STR      r0,[r4,#0x38]
                  |L15.328|
;;;1497       }
;;;1498       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_RXOVERR) != RESET)
000148  6820              LDR      r0,[r4,#0]
00014a  6b40              LDR      r0,[r0,#0x34]
00014c  f3c01040          UBFX     r0,r0,#5,#1
000150  b118              CBZ      r0,|L15.346|
;;;1499       {
;;;1500         hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN; 
000152  6ba0              LDR      r0,[r4,#0x38]
000154  f0400020          ORR      r0,r0,#0x20
000158  63a0              STR      r0,[r4,#0x38]
                  |L15.346|
;;;1501       }
;;;1502       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_TXUNDERR) != RESET)
00015a  6820              LDR      r0,[r4,#0]
00015c  6b40              LDR      r0,[r0,#0x34]
00015e  f3c01000          UBFX     r0,r0,#4,#1
000162  b118              CBZ      r0,|L15.364|
;;;1503       {
;;;1504         hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN; 
000164  6ba0              LDR      r0,[r4,#0x38]
000166  f0400010          ORR      r0,r0,#0x10
00016a  63a0              STR      r0,[r4,#0x38]
                  |L15.364|
;;;1505       }
;;;1506       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_STBITERR) != RESET)
00016c  6820              LDR      r0,[r4,#0]
00016e  6b40              LDR      r0,[r0,#0x34]
000170  f3c02040          UBFX     r0,r0,#9,#1
000174  b118              CBZ      r0,|L15.382|
;;;1507       {
;;;1508         hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
000176  6ba0              LDR      r0,[r4,#0x38]
000178  f0400008          ORR      r0,r0,#8
00017c  63a0              STR      r0,[r4,#0x38]
                  |L15.382|
;;;1509       }
;;;1510   
;;;1511       /* Clear All flags */
;;;1512       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS | SDIO_FLAG_STBITERR);
00017e  f24070ff          MOV      r0,#0x7ff
000182  6821              LDR      r1,[r4,#0]
000184  6388              STR      r0,[r1,#0x38]
;;;1513       
;;;1514       /* Disable all interrupts */
;;;1515       __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
000186  6820              LDR      r0,[r4,#0]
000188  6bc0              LDR      r0,[r0,#0x3c]
00018a  f240313a          MOV      r1,#0x33a
00018e  4388              BICS     r0,r0,r1
000190  6821              LDR      r1,[r4,#0]
000192  63c8              STR      r0,[r1,#0x3c]
;;;1516                                SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR |SDIO_IT_STBITERR);
;;;1517       
;;;1518       if((hsd->Context & SD_CONTEXT_DMA) != RESET)
000194  6b20              LDR      r0,[r4,#0x30]
000196  f0000080          AND      r0,r0,#0x80
00019a  b310              CBZ      r0,|L15.482|
;;;1519       {
;;;1520         /* Abort the SD DMA Streams */
;;;1521         if(hsd->hdmatx != NULL)
00019c  6c20              LDR      r0,[r4,#0x40]
00019e  b150              CBZ      r0,|L15.438|
;;;1522         {
;;;1523           /* Set the DMA Tx abort callback */
;;;1524           hsd->hdmatx->XferAbortCallback = SD_DMATxAbort;
0001a0  4815              LDR      r0,|L15.504|
0001a2  6c21              LDR      r1,[r4,#0x40]
0001a4  6508              STR      r0,[r1,#0x50]
;;;1525           /* Abort DMA in IT mode */
;;;1526           if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
0001a6  6c20              LDR      r0,[r4,#0x40]
0001a8  f7fffffe          BL       HAL_DMA_Abort_IT
0001ac  b110              CBZ      r0,|L15.436|
;;;1527           {
;;;1528             SD_DMATxAbort(hsd->hdmatx);
0001ae  6c20              LDR      r0,[r4,#0x40]
0001b0  f7fffffe          BL       SD_DMATxAbort
                  |L15.436|
0001b4  e01f              B        |L15.502|
                  |L15.438|
;;;1529           }
;;;1530         }
;;;1531         else if(hsd->hdmarx != NULL)
0001b6  6be0              LDR      r0,[r4,#0x3c]
0001b8  b150              CBZ      r0,|L15.464|
;;;1532         {
;;;1533           /* Set the DMA Rx abort callback */
;;;1534           hsd->hdmarx->XferAbortCallback = SD_DMARxAbort;
0001ba  4810              LDR      r0,|L15.508|
0001bc  6be1              LDR      r1,[r4,#0x3c]
0001be  6508              STR      r0,[r1,#0x50]
;;;1535           /* Abort DMA in IT mode */
;;;1536           if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
0001c0  6be0              LDR      r0,[r4,#0x3c]
0001c2  f7fffffe          BL       HAL_DMA_Abort_IT
0001c6  b1b0              CBZ      r0,|L15.502|
;;;1537           {
;;;1538             SD_DMARxAbort(hsd->hdmarx);
0001c8  6be0              LDR      r0,[r4,#0x3c]
0001ca  f7fffffe          BL       SD_DMARxAbort
0001ce  e012              B        |L15.502|
                  |L15.464|
;;;1539           }
;;;1540         }
;;;1541         else
;;;1542         {
;;;1543           hsd->ErrorCode = HAL_SD_ERROR_NONE;
0001d0  2000              MOVS     r0,#0
0001d2  63a0              STR      r0,[r4,#0x38]
;;;1544           hsd->State = HAL_SD_STATE_READY;
0001d4  2001              MOVS     r0,#1
0001d6  f8840034          STRB     r0,[r4,#0x34]
;;;1545           HAL_SD_AbortCallback(hsd);
0001da  4620              MOV      r0,r4
0001dc  f7fffffe          BL       HAL_SD_AbortCallback
0001e0  e009              B        |L15.502|
                  |L15.482|
;;;1546         }
;;;1547       }
;;;1548       else if((hsd->Context & SD_CONTEXT_IT) != RESET)
0001e2  6b20              LDR      r0,[r4,#0x30]
0001e4  f0000008          AND      r0,r0,#8
0001e8  b128              CBZ      r0,|L15.502|
;;;1549       {
;;;1550         /* Set the SD state to ready to be able to start again the process */
;;;1551         hsd->State = HAL_SD_STATE_READY;
0001ea  2001              MOVS     r0,#1
0001ec  f8840034          STRB     r0,[r4,#0x34]
;;;1552         HAL_SD_ErrorCallback(hsd);
0001f0  4620              MOV      r0,r4
0001f2  f7fffffe          BL       HAL_SD_ErrorCallback
                  |L15.502|
;;;1553       }
;;;1554     }
;;;1555   #else /* SDIO_STA_STBITERR not defined */
;;;1556     else if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_TXUNDERR) != RESET)
;;;1557     {
;;;1558       /* Set Error code */
;;;1559       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DCRCFAIL) != RESET)
;;;1560       {
;;;1561         hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL; 
;;;1562       }
;;;1563       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_DTIMEOUT) != RESET)
;;;1564       {
;;;1565         hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT; 
;;;1566       }
;;;1567       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_RXOVERR) != RESET)
;;;1568       {
;;;1569         hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN; 
;;;1570       }
;;;1571       if(__HAL_SD_GET_FLAG(hsd, SDIO_IT_TXUNDERR) != RESET)
;;;1572       {
;;;1573         hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN; 
;;;1574       }
;;;1575   
;;;1576       /* Clear All flags */
;;;1577       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;1578       
;;;1579       /* Disable all interrupts */
;;;1580       __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
;;;1581                                SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);
;;;1582       
;;;1583       if((hsd->Context & SD_CONTEXT_DMA) != RESET)
;;;1584       {
;;;1585         /* Abort the SD DMA Streams */
;;;1586         if(hsd->hdmatx != NULL)
;;;1587         {
;;;1588           /* Set the DMA Tx abort callback */
;;;1589           hsd->hdmatx->XferAbortCallback = SD_DMATxAbort;
;;;1590           /* Abort DMA in IT mode */
;;;1591           if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
;;;1592           {
;;;1593             SD_DMATxAbort(hsd->hdmatx);
;;;1594           }
;;;1595         }
;;;1596         else if(hsd->hdmarx != NULL)
;;;1597         {
;;;1598           /* Set the DMA Rx abort callback */
;;;1599           hsd->hdmarx->XferAbortCallback = SD_DMARxAbort;
;;;1600           /* Abort DMA in IT mode */
;;;1601           if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
;;;1602           {
;;;1603             SD_DMARxAbort(hsd->hdmarx);
;;;1604           }
;;;1605         }
;;;1606         else
;;;1607         {
;;;1608           hsd->ErrorCode = HAL_SD_ERROR_NONE;
;;;1609           hsd->State = HAL_SD_STATE_READY;
;;;1610           HAL_SD_AbortCallback(hsd);
;;;1611         }
;;;1612       }
;;;1613       else if((hsd->Context & SD_CONTEXT_IT) != RESET)
;;;1614       {
;;;1615         /* Set the SD state to ready to be able to start again the process */
;;;1616         hsd->State = HAL_SD_STATE_READY;
;;;1617         HAL_SD_ErrorCallback(hsd);
;;;1618       }
;;;1619     }
;;;1620   #endif
;;;1621   }
0001f6  bd70              POP      {r4-r6,pc}
;;;1622   
                          ENDP

                  |L15.504|
                          DCD      SD_DMATxAbort
                  |L15.508|
                          DCD      SD_DMARxAbort

                          AREA ||i.HAL_SD_Init||, CODE, READONLY, ALIGN=1

                  HAL_SD_Init PROC
;;;306      */
;;;307    HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
000000  b510              PUSH     {r4,lr}
;;;308    {
000002  4604              MOV      r4,r0
;;;309      /* Check the SD handle allocation */
;;;310      if(hsd == NULL)
000004  b90c              CBNZ     r4,|L16.10|
;;;311      {
;;;312        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L16.8|
;;;313      }
;;;314    
;;;315      /* Check the parameters */
;;;316      assert_param(IS_SDIO_ALL_INSTANCE(hsd->Instance));
;;;317      assert_param(IS_SDIO_CLOCK_EDGE(hsd->Init.ClockEdge));
;;;318      assert_param(IS_SDIO_CLOCK_BYPASS(hsd->Init.ClockBypass));
;;;319      assert_param(IS_SDIO_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
;;;320      assert_param(IS_SDIO_BUS_WIDE(hsd->Init.BusWide));
;;;321      assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
;;;322      assert_param(IS_SDIO_CLKDIV(hsd->Init.ClockDiv));
;;;323    
;;;324      if(hsd->State == HAL_SD_STATE_RESET)
;;;325      {
;;;326        /* Allocate lock resource and initialize it */
;;;327        hsd->Lock = HAL_UNLOCKED;
;;;328        /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
;;;329        HAL_SD_MspInit(hsd);
;;;330      }
;;;331    
;;;332      hsd->State = HAL_SD_STATE_BUSY;
;;;333    
;;;334      /* Initialize the Card parameters */
;;;335      HAL_SD_InitCard(hsd);
;;;336    
;;;337      /* Initialize the error code */
;;;338      hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;339      
;;;340      /* Initialize the SD operation */
;;;341      hsd->Context = SD_CONTEXT_NONE;
;;;342                                                                                         
;;;343      /* Initialize the SD state */
;;;344      hsd->State = HAL_SD_STATE_READY;
;;;345    
;;;346      return HAL_OK;
;;;347    }
000008  bd10              POP      {r4,pc}
                  |L16.10|
00000a  f8940034          LDRB     r0,[r4,#0x34]         ;324
00000e  b920              CBNZ     r0,|L16.26|
000010  2000              MOVS     r0,#0                 ;327
000012  7720              STRB     r0,[r4,#0x1c]         ;327
000014  4620              MOV      r0,r4                 ;329
000016  f7fffffe          BL       HAL_SD_MspInit
                  |L16.26|
00001a  2003              MOVS     r0,#3                 ;332
00001c  f8840034          STRB     r0,[r4,#0x34]         ;332
000020  4620              MOV      r0,r4                 ;335
000022  f7fffffe          BL       HAL_SD_InitCard
000026  2000              MOVS     r0,#0                 ;338
000028  63a0              STR      r0,[r4,#0x38]         ;338
00002a  6320              STR      r0,[r4,#0x30]         ;341
00002c  2001              MOVS     r0,#1                 ;344
00002e  f8840034          STRB     r0,[r4,#0x34]         ;344
000032  2000              MOVS     r0,#0                 ;346
000034  e7e8              B        |L16.8|
;;;348    
                          ENDP


                          AREA ||i.HAL_SD_InitCard||, CODE, READONLY, ALIGN=2

                  HAL_SD_InitCard PROC
;;;355      */
;;;356    HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
000000  b530              PUSH     {r4,r5,lr}
;;;357    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
;;;358      uint32_t errorstate = HAL_SD_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;359      SD_InitTypeDef Init;
;;;360      
;;;361      /* Default SDIO peripheral configuration for SD card initialization */
;;;362      Init.ClockEdge           = SDIO_CLOCK_EDGE_RISING;
000008  2000              MOVS     r0,#0
00000a  9003              STR      r0,[sp,#0xc]
;;;363      Init.ClockBypass         = SDIO_CLOCK_BYPASS_DISABLE;
00000c  9004              STR      r0,[sp,#0x10]
;;;364      Init.ClockPowerSave      = SDIO_CLOCK_POWER_SAVE_DISABLE;
00000e  9005              STR      r0,[sp,#0x14]
;;;365      Init.BusWide             = SDIO_BUS_WIDE_1B;
000010  9006              STR      r0,[sp,#0x18]
;;;366      Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
000012  9007              STR      r0,[sp,#0x1c]
;;;367      Init.ClockDiv            = SDIO_INIT_CLK_DIV;
000014  2076              MOVS     r0,#0x76
000016  9008              STR      r0,[sp,#0x20]
;;;368    
;;;369      /* Initialize SDIO peripheral interface with default configuration */
;;;370      SDIO_Init(hsd->Instance, Init);
000018  a806              ADD      r0,sp,#0x18
00001a  c807              LDM      r0,{r0-r2}
00001c  e88d0007          STM      sp,{r0-r2}
000020  6820              LDR      r0,[r4,#0]
000022  a903              ADD      r1,sp,#0xc
000024  c90e              LDM      r1,{r1-r3}
000026  f7fffffe          BL       SDIO_Init
;;;371    
;;;372      /* Disable SDIO Clock */
;;;373      __HAL_SD_DISABLE(hsd); 
00002a  2000              MOVS     r0,#0
00002c  4914              LDR      r1,|L17.128|
00002e  6008              STR      r0,[r1,#0]
;;;374      
;;;375      /* Set Power State to ON */
;;;376      SDIO_PowerState_ON(hsd->Instance);
000030  6820              LDR      r0,[r4,#0]
000032  f7fffffe          BL       SDIO_PowerState_ON
;;;377      
;;;378      /* Enable SDIO Clock */
;;;379      __HAL_SD_ENABLE(hsd);
000036  2001              MOVS     r0,#1
000038  4911              LDR      r1,|L17.128|
00003a  39a0              SUBS     r1,r1,#0xa0
00003c  f8c100a0          STR      r0,[r1,#0xa0]
;;;380      
;;;381      /* Required power up waiting time before starting the SD initialization 
;;;382      sequence */
;;;383      HAL_Delay(2U);
000040  2002              MOVS     r0,#2
000042  f7fffffe          BL       HAL_Delay
;;;384      
;;;385      /* Identify card operating voltage */
;;;386      errorstate = SD_PowerON(hsd);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       SD_PowerON
00004c  4605              MOV      r5,r0
;;;387      if(errorstate != HAL_SD_ERROR_NONE)
00004e  b145              CBZ      r5,|L17.98|
;;;388      {
;;;389        hsd->State = HAL_SD_STATE_READY;
000050  2001              MOVS     r0,#1
000052  f8840034          STRB     r0,[r4,#0x34]
;;;390        hsd->ErrorCode |= errorstate;
000056  6ba0              LDR      r0,[r4,#0x38]
000058  4328              ORRS     r0,r0,r5
00005a  63a0              STR      r0,[r4,#0x38]
;;;391        return HAL_ERROR;
00005c  2001              MOVS     r0,#1
                  |L17.94|
;;;392      }
;;;393    
;;;394      /* Card initialization */
;;;395      errorstate = SD_InitCard(hsd);
;;;396      if(errorstate != HAL_SD_ERROR_NONE)
;;;397      {
;;;398        hsd->State = HAL_SD_STATE_READY;
;;;399        hsd->ErrorCode |= errorstate;
;;;400        return HAL_ERROR;
;;;401      }
;;;402    
;;;403      return HAL_OK;
;;;404    }
00005e  b009              ADD      sp,sp,#0x24
000060  bd30              POP      {r4,r5,pc}
                  |L17.98|
000062  4620              MOV      r0,r4                 ;395
000064  f7fffffe          BL       SD_InitCard
000068  4605              MOV      r5,r0                 ;395
00006a  b13d              CBZ      r5,|L17.124|
00006c  2001              MOVS     r0,#1                 ;398
00006e  f8840034          STRB     r0,[r4,#0x34]         ;398
000072  6ba0              LDR      r0,[r4,#0x38]         ;399
000074  4328              ORRS     r0,r0,r5              ;399
000076  63a0              STR      r0,[r4,#0x38]         ;399
000078  2001              MOVS     r0,#1                 ;400
00007a  e7f0              B        |L17.94|
                  |L17.124|
00007c  2000              MOVS     r0,#0                 ;403
00007e  e7ee              B        |L17.94|
;;;405    
                          ENDP

                  |L17.128|
                          DCD      0x422580a0

                          AREA ||i.HAL_SD_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_SD_MspDeInit PROC
;;;456      */
;;;457    __weak void HAL_SD_MspDeInit(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;458    {
;;;459      /* Prevent unused argument(s) compilation warning */
;;;460      UNUSED(hsd);
;;;461     
;;;462      /* NOTE : This function Should not be modified, when the callback is needed,
;;;463                the HAL_SD_MspDeInit could be implemented in the user file
;;;464       */
;;;465    }
;;;466    
                          ENDP


                          AREA ||i.HAL_SD_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_SD_MspInit PROC
;;;441      */
;;;442    __weak void HAL_SD_MspInit(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;443    {
;;;444      /* Prevent unused argument(s) compilation warning */
;;;445      UNUSED(hsd);
;;;446     
;;;447      /* NOTE : This function Should not be modified, when the callback is needed,
;;;448                the HAL_SD_MspInit could be implemented in the user file
;;;449       */
;;;450    }
;;;451    
                          ENDP


                          AREA ||i.HAL_SD_ReadBlocks||, CODE, READONLY, ALIGN=1

                  HAL_SD_ReadBlocks PROC
;;;497      */
;;;498    HAL_StatusTypeDef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks, uint32_t Timeout)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;499    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  468a              MOV      r10,r1
00000a  4690              MOV      r8,r2
00000c  461e              MOV      r6,r3
00000e  f8dd9040          LDR      r9,[sp,#0x40]
;;;500      SDIO_DataInitTypeDef config;
;;;501      uint32_t errorstate = HAL_SD_ERROR_NONE;
000012  2500              MOVS     r5,#0
;;;502      uint32_t tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  9000              STR      r0,[sp,#0]
;;;503      uint32_t count = 0U, *tempbuff = (uint32_t *)pData;
00001a  46ab              MOV      r11,r5
00001c  4657              MOV      r7,r10
;;;504      
;;;505      if(NULL == pData)
00001e  f1ba0f00          CMP      r10,#0
000022  d107              BNE      |L20.52|
;;;506      {
;;;507        hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
000024  6ba0              LDR      r0,[r4,#0x38]
000026  f0406000          ORR      r0,r0,#0x8000000
00002a  63a0              STR      r0,[r4,#0x38]
;;;508        return HAL_ERROR;
00002c  2001              MOVS     r0,#1
                  |L20.46|
;;;509      }
;;;510     
;;;511      if(hsd->State == HAL_SD_STATE_READY)
;;;512      {
;;;513        hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;514        
;;;515        if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;516        {
;;;517          hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;518          return HAL_ERROR;
;;;519        }
;;;520        
;;;521        hsd->State = HAL_SD_STATE_BUSY;
;;;522        
;;;523        /* Initialize data control register */
;;;524        hsd->Instance->DCTRL = 0U;
;;;525        
;;;526        if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;527        {
;;;528          BlockAdd *= 512U;
;;;529        }
;;;530          
;;;531        /* Set Block Size for Card */
;;;532        errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;533        if(errorstate != HAL_SD_ERROR_NONE)
;;;534        {
;;;535          /* Clear all the static flags */
;;;536          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);      
;;;537          hsd->ErrorCode |= errorstate;
;;;538          hsd->State = HAL_SD_STATE_READY;
;;;539          return HAL_ERROR;
;;;540        }
;;;541        
;;;542        /* Configure the SD DPSM (Data Path State Machine) */
;;;543        config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;544        config.DataLength    = NumberOfBlocks * BLOCKSIZE;
;;;545        config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;546        config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;547        config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;548        config.DPSM          = SDIO_DPSM_ENABLE;
;;;549        SDIO_ConfigData(hsd->Instance, &config);
;;;550        
;;;551        /* Read block(s) in polling mode */
;;;552        if(NumberOfBlocks > 1U)
;;;553        {
;;;554          hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
;;;555          
;;;556          /* Read Multi Block command */ 
;;;557          errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, BlockAdd);
;;;558        }
;;;559        else
;;;560        {
;;;561          hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
;;;562          
;;;563          /* Read Single Block command */
;;;564          errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, BlockAdd);
;;;565        }
;;;566        if(errorstate != HAL_SD_ERROR_NONE)
;;;567        {
;;;568          /* Clear all the static flags */
;;;569          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;570          hsd->ErrorCode |= errorstate;
;;;571          hsd->State = HAL_SD_STATE_READY;
;;;572          return HAL_ERROR;
;;;573        }
;;;574          
;;;575        /* Poll on SDIO flags */
;;;576    #ifdef SDIO_STA_STBITERR
;;;577        while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_STA_STBITERR))
;;;578    #else /* SDIO_STA_STBITERR not defined */
;;;579        while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
;;;580    #endif /* SDIO_STA_STBITERR */
;;;581        {
;;;582          if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
;;;583          {
;;;584            /* Read data from SDIO Rx FIFO */
;;;585            for(count = 0U; count < 8U; count++)
;;;586            {
;;;587              *(tempbuff + count) = SDIO_ReadFIFO(hsd->Instance);
;;;588            }
;;;589            tempbuff += 8U;
;;;590          }
;;;591          
;;;592          if((Timeout == 0U)||((HAL_GetTick()-tickstart) >=  Timeout))
;;;593          {
;;;594            /* Clear all the static flags */
;;;595            __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;596            hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
;;;597            hsd->State= HAL_SD_STATE_READY;
;;;598            return HAL_TIMEOUT;
;;;599          }
;;;600        }
;;;601        
;;;602        /* Send stop transmission command in case of multiblock read */
;;;603        if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
;;;604        {    
;;;605          if(hsd->SdCard.CardType != CARD_SECURED)
;;;606          {
;;;607            /* Send stop transmission command */
;;;608            errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
;;;609            if(errorstate != HAL_SD_ERROR_NONE)
;;;610            {
;;;611              /* Clear all the static flags */
;;;612              __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;613              hsd->ErrorCode |= errorstate;
;;;614              hsd->State = HAL_SD_STATE_READY;
;;;615              return HAL_ERROR;
;;;616            }
;;;617          }
;;;618        }
;;;619        
;;;620        /* Get error state */
;;;621        if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;622        {
;;;623          /* Clear all the static flags */
;;;624          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;625          hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
;;;626          hsd->State = HAL_SD_STATE_READY;
;;;627          return HAL_ERROR;
;;;628        }
;;;629        else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;630        {
;;;631          /* Clear all the static flags */
;;;632          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;633          hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
;;;634          hsd->State = HAL_SD_STATE_READY;
;;;635          return HAL_ERROR;
;;;636        }
;;;637        else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
;;;638        {
;;;639          /* Clear all the static flags */
;;;640          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;641          hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
;;;642          hsd->State = HAL_SD_STATE_READY;
;;;643          return HAL_ERROR;
;;;644        }
;;;645        
;;;646        /* Empty FIFO if there is still any data */
;;;647        while ((__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)))
;;;648        {
;;;649          *tempbuff = SDIO_ReadFIFO(hsd->Instance);
;;;650          tempbuff++;
;;;651          
;;;652          if((Timeout == 0U)||((HAL_GetTick()-tickstart) >=  Timeout))
;;;653          {
;;;654            /* Clear all the static flags */
;;;655            __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);        
;;;656            hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
;;;657            hsd->State= HAL_SD_STATE_READY;
;;;658            return HAL_ERROR;
;;;659          }
;;;660        }
;;;661        
;;;662        /* Clear all the static flags */
;;;663        __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;664        
;;;665        hsd->State = HAL_SD_STATE_READY;
;;;666        
;;;667        return HAL_OK;
;;;668      }
;;;669      else
;;;670      {
;;;671        hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
;;;672        return HAL_ERROR;
;;;673      }
;;;674    }
00002e  b007              ADD      sp,sp,#0x1c
000030  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.52|
000034  f8940034          LDRB     r0,[r4,#0x34]         ;511
000038  2801              CMP      r0,#1                 ;511
00003a  d17d              BNE      |L20.312|
00003c  2000              MOVS     r0,#0                 ;513
00003e  63a0              STR      r0,[r4,#0x38]         ;513
000040  eb080106          ADD      r1,r8,r6              ;515
000044  6de0              LDR      r0,[r4,#0x5c]         ;515
000046  4281              CMP      r1,r0                 ;515
000048  d905              BLS      |L20.86|
00004a  6ba0              LDR      r0,[r4,#0x38]         ;517
00004c  f0407000          ORR      r0,r0,#0x2000000      ;517
000050  63a0              STR      r0,[r4,#0x38]         ;517
000052  2001              MOVS     r0,#1                 ;518
000054  e7eb              B        |L20.46|
                  |L20.86|
000056  2003              MOVS     r0,#3                 ;521
000058  f8840034          STRB     r0,[r4,#0x34]         ;521
00005c  2000              MOVS     r0,#0                 ;524
00005e  6821              LDR      r1,[r4,#0]            ;524
000060  62c8              STR      r0,[r1,#0x2c]         ;524
000062  6c60              LDR      r0,[r4,#0x44]         ;526
000064  2801              CMP      r0,#1                 ;526
000066  d001              BEQ      |L20.108|
000068  ea4f2848          LSL      r8,r8,#9              ;528
                  |L20.108|
00006c  f44f7100          MOV      r1,#0x200             ;532
000070  6820              LDR      r0,[r4,#0]            ;532
000072  f7fffffe          BL       SDMMC_CmdBlockLength
000076  4605              MOV      r5,r0                 ;532
000078  b155              CBZ      r5,|L20.144|
00007a  f24050ff          MOV      r0,#0x5ff             ;536
00007e  6821              LDR      r1,[r4,#0]            ;536
000080  6388              STR      r0,[r1,#0x38]         ;536
000082  6ba0              LDR      r0,[r4,#0x38]         ;537
000084  4328              ORRS     r0,r0,r5              ;537
000086  63a0              STR      r0,[r4,#0x38]         ;537
000088  2001              MOVS     r0,#1                 ;538
00008a  f8840034          STRB     r0,[r4,#0x34]         ;538
00008e  e7ce              B        |L20.46|
                  |L20.144|
000090  f04f30ff          MOV      r0,#0xffffffff        ;543
000094  9001              STR      r0,[sp,#4]            ;543
000096  0270              LSLS     r0,r6,#9              ;544
000098  9002              STR      r0,[sp,#8]            ;544
00009a  2090              MOVS     r0,#0x90              ;545
00009c  9003              STR      r0,[sp,#0xc]          ;545
00009e  2002              MOVS     r0,#2                 ;546
0000a0  9004              STR      r0,[sp,#0x10]         ;546
0000a2  2000              MOVS     r0,#0                 ;547
0000a4  9005              STR      r0,[sp,#0x14]         ;547
0000a6  2001              MOVS     r0,#1                 ;548
0000a8  9006              STR      r0,[sp,#0x18]         ;548
0000aa  a901              ADD      r1,sp,#4              ;549
0000ac  6820              LDR      r0,[r4,#0]            ;549
0000ae  f7fffffe          BL       SDIO_ConfigData
0000b2  2e01              CMP      r6,#1                 ;552
0000b4  d907              BLS      |L20.198|
0000b6  2002              MOVS     r0,#2                 ;554
0000b8  6320              STR      r0,[r4,#0x30]         ;554
0000ba  4641              MOV      r1,r8                 ;557
0000bc  6820              LDR      r0,[r4,#0]            ;557
0000be  f7fffffe          BL       SDMMC_CmdReadMultiBlock
0000c2  4605              MOV      r5,r0                 ;557
0000c4  e006              B        |L20.212|
                  |L20.198|
0000c6  2001              MOVS     r0,#1                 ;561
0000c8  6320              STR      r0,[r4,#0x30]         ;561
0000ca  4641              MOV      r1,r8                 ;564
0000cc  6820              LDR      r0,[r4,#0]            ;564
0000ce  f7fffffe          BL       SDMMC_CmdReadSingleBlock
0000d2  4605              MOV      r5,r0                 ;564
                  |L20.212|
0000d4  b155              CBZ      r5,|L20.236|
0000d6  f24050ff          MOV      r0,#0x5ff             ;569
0000da  6821              LDR      r1,[r4,#0]            ;569
0000dc  6388              STR      r0,[r1,#0x38]         ;569
0000de  6ba0              LDR      r0,[r4,#0x38]         ;570
0000e0  4328              ORRS     r0,r0,r5              ;570
0000e2  63a0              STR      r0,[r4,#0x38]         ;570
0000e4  2001              MOVS     r0,#1                 ;571
0000e6  f8840034          STRB     r0,[r4,#0x34]         ;571
0000ea  e7a0              B        |L20.46|
                  |L20.236|
0000ec  e02a              B        |L20.324|
                  |L20.238|
0000ee  6820              LDR      r0,[r4,#0]            ;582
0000f0  6b40              LDR      r0,[r0,#0x34]         ;582
0000f2  f4004000          AND      r0,r0,#0x8000         ;582
0000f6  b168              CBZ      r0,|L20.276|
0000f8  f04f0b00          MOV      r11,#0                ;585
0000fc  e006              B        |L20.268|
                  |L20.254|
0000fe  6820              LDR      r0,[r4,#0]            ;587
000100  f7fffffe          BL       SDIO_ReadFIFO
000104  f847002b          STR      r0,[r7,r11,LSL #2]    ;587
000108  f10b0b01          ADD      r11,r11,#1            ;585
                  |L20.268|
00010c  f1bb0f08          CMP      r11,#8                ;585
000110  d3f5              BCC      |L20.254|
000112  3720              ADDS     r7,r7,#0x20           ;589
                  |L20.276|
000114  f1b90f00          CMP      r9,#0                 ;592
000118  d005              BEQ      |L20.294|
00011a  f7fffffe          BL       HAL_GetTick
00011e  9900              LDR      r1,[sp,#0]            ;592
000120  1a40              SUBS     r0,r0,r1              ;592
000122  4548              CMP      r0,r9                 ;592
000124  d30e              BCC      |L20.324|
                  |L20.294|
000126  f24050ff          MOV      r0,#0x5ff             ;595
00012a  6821              LDR      r1,[r4,#0]            ;595
00012c  6388              STR      r0,[r1,#0x38]         ;595
00012e  6ba0              LDR      r0,[r4,#0x38]         ;596
000130  f0404000          ORR      r0,r0,#0x80000000     ;596
000134  63a0              STR      r0,[r4,#0x38]         ;596
000136  e000              B        |L20.314|
                  |L20.312|
000138  e082              B        |L20.576|
                  |L20.314|
00013a  2001              MOVS     r0,#1                 ;597
00013c  f8840034          STRB     r0,[r4,#0x34]         ;597
000140  2003              MOVS     r0,#3                 ;598
000142  e774              B        |L20.46|
                  |L20.324|
000144  6820              LDR      r0,[r4,#0]            ;577
000146  6b40              LDR      r0,[r0,#0x34]         ;577
000148  f240312a          MOV      r1,#0x32a             ;577
00014c  4008              ANDS     r0,r0,r1              ;577
00014e  2800              CMP      r0,#0                 ;577
000150  d0cd              BEQ      |L20.238|
000152  6820              LDR      r0,[r4,#0]            ;603
000154  6b40              LDR      r0,[r0,#0x34]         ;603
000156  f4007080          AND      r0,r0,#0x100          ;603
00015a  b1a0              CBZ      r0,|L20.390|
00015c  2e01              CMP      r6,#1                 ;603
00015e  d912              BLS      |L20.390|
000160  6c60              LDR      r0,[r4,#0x44]         ;605
000162  2803              CMP      r0,#3                 ;605
000164  d00f              BEQ      |L20.390|
000166  6820              LDR      r0,[r4,#0]            ;608
000168  f7fffffe          BL       SDMMC_CmdStopTransfer
00016c  4605              MOV      r5,r0                 ;608
00016e  b155              CBZ      r5,|L20.390|
000170  f24050ff          MOV      r0,#0x5ff             ;612
000174  6821              LDR      r1,[r4,#0]            ;612
000176  6388              STR      r0,[r1,#0x38]         ;612
000178  6ba0              LDR      r0,[r4,#0x38]         ;613
00017a  4328              ORRS     r0,r0,r5              ;613
00017c  63a0              STR      r0,[r4,#0x38]         ;613
00017e  2001              MOVS     r0,#1                 ;614
000180  f8840034          STRB     r0,[r4,#0x34]         ;614
000184  e753              B        |L20.46|
                  |L20.390|
000186  6820              LDR      r0,[r4,#0]            ;621
000188  6b40              LDR      r0,[r0,#0x34]         ;621
00018a  f0000008          AND      r0,r0,#8              ;621
00018e  b158              CBZ      r0,|L20.424|
000190  f24050ff          MOV      r0,#0x5ff             ;624
000194  6821              LDR      r1,[r4,#0]            ;624
000196  6388              STR      r0,[r1,#0x38]         ;624
000198  6ba0              LDR      r0,[r4,#0x38]         ;625
00019a  f0400008          ORR      r0,r0,#8              ;625
00019e  63a0              STR      r0,[r4,#0x38]         ;625
0001a0  2001              MOVS     r0,#1                 ;626
0001a2  f8840034          STRB     r0,[r4,#0x34]         ;626
0001a6  e742              B        |L20.46|
                  |L20.424|
0001a8  6820              LDR      r0,[r4,#0]            ;629
0001aa  6b40              LDR      r0,[r0,#0x34]         ;629
0001ac  f0000002          AND      r0,r0,#2              ;629
0001b0  b158              CBZ      r0,|L20.458|
0001b2  f24050ff          MOV      r0,#0x5ff             ;632
0001b6  6821              LDR      r1,[r4,#0]            ;632
0001b8  6388              STR      r0,[r1,#0x38]         ;632
0001ba  6ba0              LDR      r0,[r4,#0x38]         ;633
0001bc  f0400002          ORR      r0,r0,#2              ;633
0001c0  63a0              STR      r0,[r4,#0x38]         ;633
0001c2  2001              MOVS     r0,#1                 ;634
0001c4  f8840034          STRB     r0,[r4,#0x34]         ;634
0001c8  e731              B        |L20.46|
                  |L20.458|
0001ca  6820              LDR      r0,[r4,#0]            ;637
0001cc  6b40              LDR      r0,[r0,#0x34]         ;637
0001ce  f0000020          AND      r0,r0,#0x20           ;637
0001d2  b158              CBZ      r0,|L20.492|
0001d4  f24050ff          MOV      r0,#0x5ff             ;640
0001d8  6821              LDR      r1,[r4,#0]            ;640
0001da  6388              STR      r0,[r1,#0x38]         ;640
0001dc  6ba0              LDR      r0,[r4,#0x38]         ;641
0001de  f0400020          ORR      r0,r0,#0x20           ;641
0001e2  63a0              STR      r0,[r4,#0x38]         ;641
0001e4  2001              MOVS     r0,#1                 ;642
0001e6  f8840034          STRB     r0,[r4,#0x34]         ;642
0001ea  e720              B        |L20.46|
                  |L20.492|
0001ec  e019              B        |L20.546|
                  |L20.494|
0001ee  6820              LDR      r0,[r4,#0]            ;649
0001f0  f7fffffe          BL       SDIO_ReadFIFO
0001f4  6038              STR      r0,[r7,#0]            ;649
0001f6  1d3f              ADDS     r7,r7,#4              ;650
0001f8  f1b90f00          CMP      r9,#0                 ;652
0001fc  d005              BEQ      |L20.522|
0001fe  f7fffffe          BL       HAL_GetTick
000202  9900              LDR      r1,[sp,#0]            ;652
000204  1a40              SUBS     r0,r0,r1              ;652
000206  4548              CMP      r0,r9                 ;652
000208  d30b              BCC      |L20.546|
                  |L20.522|
00020a  f24050ff          MOV      r0,#0x5ff             ;655
00020e  6821              LDR      r1,[r4,#0]            ;655
000210  6388              STR      r0,[r1,#0x38]         ;655
000212  6ba0              LDR      r0,[r4,#0x38]         ;656
000214  f0404000          ORR      r0,r0,#0x80000000     ;656
000218  63a0              STR      r0,[r4,#0x38]         ;656
00021a  2001              MOVS     r0,#1                 ;657
00021c  f8840034          STRB     r0,[r4,#0x34]         ;657
000220  e705              B        |L20.46|
                  |L20.546|
000222  6820              LDR      r0,[r4,#0]            ;647
000224  6b40              LDR      r0,[r0,#0x34]         ;647
000226  f4001000          AND      r0,r0,#0x200000       ;647
00022a  2800              CMP      r0,#0                 ;647
00022c  d1df              BNE      |L20.494|
00022e  f24050ff          MOV      r0,#0x5ff             ;663
000232  6821              LDR      r1,[r4,#0]            ;663
000234  6388              STR      r0,[r1,#0x38]         ;663
000236  2001              MOVS     r0,#1                 ;665
000238  f8840034          STRB     r0,[r4,#0x34]         ;665
00023c  2000              MOVS     r0,#0                 ;667
00023e  e6f6              B        |L20.46|
                  |L20.576|
000240  6ba0              LDR      r0,[r4,#0x38]         ;671
000242  f0405000          ORR      r0,r0,#0x20000000     ;671
000246  63a0              STR      r0,[r4,#0x38]         ;671
000248  2001              MOVS     r0,#1                 ;672
00024a  e6f0              B        |L20.46|
;;;675    
                          ENDP


                          AREA ||i.HAL_SD_ReadBlocks_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SD_ReadBlocks_DMA PROC
;;;1074     */
;;;1075   HAL_StatusTypeDef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1076   {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4616              MOV      r6,r2
00000c  461d              MOV      r5,r3
;;;1077     SDIO_DataInitTypeDef config;
;;;1078     uint32_t errorstate = HAL_SD_ERROR_NONE;
00000e  2700              MOVS     r7,#0
;;;1079     
;;;1080     if(NULL == pData)
000010  f1b80f00          CMP      r8,#0
000014  d107              BNE      |L21.38|
;;;1081     {
;;;1082       hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
000016  6ba0              LDR      r0,[r4,#0x38]
000018  f0406000          ORR      r0,r0,#0x8000000
00001c  63a0              STR      r0,[r4,#0x38]
;;;1083       return HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L21.32|
;;;1084     }
;;;1085     
;;;1086     if(hsd->State == HAL_SD_STATE_READY)
;;;1087     {
;;;1088       hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;1089       
;;;1090       if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;1091       {
;;;1092         hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;1093         return HAL_ERROR;
;;;1094       }
;;;1095       
;;;1096       hsd->State = HAL_SD_STATE_BUSY;
;;;1097       
;;;1098       /* Initialize data control register */
;;;1099       hsd->Instance->DCTRL = 0U;
;;;1100       
;;;1101   #ifdef SDIO_STA_STBITER
;;;1102       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND | SDIO_IT_STBITERR));
;;;1103   #else /* SDIO_STA_STBITERR not defined */
;;;1104       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND));
;;;1105   #endif /* SDIO_STA_STBITERR */
;;;1106       
;;;1107       /* Set the DMA transfer complete callback */
;;;1108       hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
;;;1109       
;;;1110       /* Set the DMA error callback */
;;;1111       hsd->hdmarx->XferErrorCallback = SD_DMAError;
;;;1112       
;;;1113       /* Set the DMA Abort callback */
;;;1114       hsd->hdmarx->XferAbortCallback = NULL;
;;;1115       
;;;1116       /* Enable the DMA Channel */
;;;1117       HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4);
;;;1118       
;;;1119       /* Enable SD DMA transfer */
;;;1120       __HAL_SD_DMA_ENABLE(hsd);
;;;1121       
;;;1122       if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;1123       {
;;;1124         BlockAdd *= 512U;
;;;1125       }
;;;1126       
;;;1127       /* Configure the SD DPSM (Data Path State Machine) */ 
;;;1128       config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;1129       config.DataLength    = BLOCKSIZE * NumberOfBlocks;
;;;1130       config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;1131       config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;1132       config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;1133       config.DPSM          = SDIO_DPSM_ENABLE;
;;;1134       SDIO_ConfigData(hsd->Instance, &config);
;;;1135   
;;;1136       /* Set Block Size for Card */ 
;;;1137       errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;1138       if(errorstate != HAL_SD_ERROR_NONE)
;;;1139       {
;;;1140         /* Clear all the static flags */
;;;1141         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1142         hsd->ErrorCode |= errorstate;
;;;1143         hsd->State = HAL_SD_STATE_READY;
;;;1144         return HAL_ERROR;
;;;1145       }
;;;1146           
;;;1147       /* Read Blocks in DMA mode */
;;;1148       if(NumberOfBlocks > 1U)
;;;1149       {
;;;1150         hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
;;;1151         
;;;1152         /* Read Multi Block command */ 
;;;1153         errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, BlockAdd);
;;;1154       }
;;;1155       else
;;;1156       {
;;;1157         hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
;;;1158         
;;;1159         /* Read Single Block command */ 
;;;1160         errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, BlockAdd);
;;;1161       }
;;;1162       if(errorstate != HAL_SD_ERROR_NONE)
;;;1163       {
;;;1164         /* Clear all the static flags */
;;;1165         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1166         hsd->ErrorCode |= errorstate;
;;;1167         hsd->State = HAL_SD_STATE_READY;
;;;1168         return HAL_ERROR;
;;;1169       }
;;;1170   
;;;1171       return HAL_OK;
;;;1172     }
;;;1173     else
;;;1174     {
;;;1175       return HAL_BUSY;
;;;1176     }
;;;1177   }
000020  b006              ADD      sp,sp,#0x18
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L21.38|
000026  f8940034          LDRB     r0,[r4,#0x34]         ;1086
00002a  2801              CMP      r0,#1                 ;1086
00002c  d173              BNE      |L21.278|
00002e  2000              MOVS     r0,#0                 ;1088
000030  63a0              STR      r0,[r4,#0x38]         ;1088
000032  1971              ADDS     r1,r6,r5              ;1090
000034  6de0              LDR      r0,[r4,#0x5c]         ;1090
000036  4281              CMP      r1,r0                 ;1090
000038  d905              BLS      |L21.70|
00003a  6ba0              LDR      r0,[r4,#0x38]         ;1092
00003c  f0407000          ORR      r0,r0,#0x2000000      ;1092
000040  63a0              STR      r0,[r4,#0x38]         ;1092
000042  2001              MOVS     r0,#1                 ;1093
000044  e7ec              B        |L21.32|
                  |L21.70|
000046  2003              MOVS     r0,#3                 ;1096
000048  f8840034          STRB     r0,[r4,#0x34]         ;1096
00004c  2000              MOVS     r0,#0                 ;1099
00004e  6821              LDR      r1,[r4,#0]            ;1099
000050  62c8              STR      r0,[r1,#0x2c]         ;1099
000052  6820              LDR      r0,[r4,#0]            ;1104
000054  6bc0              LDR      r0,[r0,#0x3c]         ;1104
000056  f4407095          ORR      r0,r0,#0x12a          ;1104
00005a  6821              LDR      r1,[r4,#0]            ;1104
00005c  63c8              STR      r0,[r1,#0x3c]         ;1104
00005e  482f              LDR      r0,|L21.284|
000060  6be1              LDR      r1,[r4,#0x3c]         ;1108
000062  63c8              STR      r0,[r1,#0x3c]         ;1108
000064  482e              LDR      r0,|L21.288|
000066  6be1              LDR      r1,[r4,#0x3c]         ;1111
000068  64c8              STR      r0,[r1,#0x4c]         ;1111
00006a  2000              MOVS     r0,#0                 ;1114
00006c  6be1              LDR      r1,[r4,#0x3c]         ;1114
00006e  6508              STR      r0,[r1,#0x50]         ;1114
000070  026a              LSLS     r2,r5,#9              ;1117
000072  0893              LSRS     r3,r2,#2              ;1117
000074  6822              LDR      r2,[r4,#0]            ;1117
000076  f1020180          ADD      r1,r2,#0x80           ;1117
00007a  4642              MOV      r2,r8                 ;1117
00007c  6be0              LDR      r0,[r4,#0x3c]         ;1117
00007e  f7fffffe          BL       HAL_DMA_Start_IT
000082  2001              MOVS     r0,#1                 ;1120
000084  4927              LDR      r1,|L21.292|
000086  6008              STR      r0,[r1,#0]            ;1120
000088  6c60              LDR      r0,[r4,#0x44]         ;1122
00008a  2801              CMP      r0,#1                 ;1122
00008c  d000              BEQ      |L21.144|
00008e  0276              LSLS     r6,r6,#9              ;1124
                  |L21.144|
000090  f04f30ff          MOV      r0,#0xffffffff        ;1128
000094  9000              STR      r0,[sp,#0]            ;1128
000096  0268              LSLS     r0,r5,#9              ;1129
000098  9001              STR      r0,[sp,#4]            ;1129
00009a  2090              MOVS     r0,#0x90              ;1130
00009c  9002              STR      r0,[sp,#8]            ;1130
00009e  2002              MOVS     r0,#2                 ;1131
0000a0  9003              STR      r0,[sp,#0xc]          ;1131
0000a2  2000              MOVS     r0,#0                 ;1132
0000a4  9004              STR      r0,[sp,#0x10]         ;1132
0000a6  2001              MOVS     r0,#1                 ;1133
0000a8  9005              STR      r0,[sp,#0x14]         ;1133
0000aa  4669              MOV      r1,sp                 ;1134
0000ac  6820              LDR      r0,[r4,#0]            ;1134
0000ae  f7fffffe          BL       SDIO_ConfigData
0000b2  f44f7100          MOV      r1,#0x200             ;1137
0000b6  6820              LDR      r0,[r4,#0]            ;1137
0000b8  f7fffffe          BL       SDMMC_CmdBlockLength
0000bc  4607              MOV      r7,r0                 ;1137
0000be  b157              CBZ      r7,|L21.214|
0000c0  f24050ff          MOV      r0,#0x5ff             ;1141
0000c4  6821              LDR      r1,[r4,#0]            ;1141
0000c6  6388              STR      r0,[r1,#0x38]         ;1141
0000c8  6ba0              LDR      r0,[r4,#0x38]         ;1142
0000ca  4338              ORRS     r0,r0,r7              ;1142
0000cc  63a0              STR      r0,[r4,#0x38]         ;1142
0000ce  2001              MOVS     r0,#1                 ;1143
0000d0  f8840034          STRB     r0,[r4,#0x34]         ;1143
0000d4  e7a4              B        |L21.32|
                  |L21.214|
0000d6  2d01              CMP      r5,#1                 ;1148
0000d8  d907              BLS      |L21.234|
0000da  2082              MOVS     r0,#0x82              ;1150
0000dc  6320              STR      r0,[r4,#0x30]         ;1150
0000de  4631              MOV      r1,r6                 ;1153
0000e0  6820              LDR      r0,[r4,#0]            ;1153
0000e2  f7fffffe          BL       SDMMC_CmdReadMultiBlock
0000e6  4607              MOV      r7,r0                 ;1153
0000e8  e006              B        |L21.248|
                  |L21.234|
0000ea  2081              MOVS     r0,#0x81              ;1157
0000ec  6320              STR      r0,[r4,#0x30]         ;1157
0000ee  4631              MOV      r1,r6                 ;1160
0000f0  6820              LDR      r0,[r4,#0]            ;1160
0000f2  f7fffffe          BL       SDMMC_CmdReadSingleBlock
0000f6  4607              MOV      r7,r0                 ;1160
                  |L21.248|
0000f8  b15f              CBZ      r7,|L21.274|
0000fa  f24050ff          MOV      r0,#0x5ff             ;1165
0000fe  6821              LDR      r1,[r4,#0]            ;1165
000100  6388              STR      r0,[r1,#0x38]         ;1165
000102  6ba0              LDR      r0,[r4,#0x38]         ;1166
000104  4338              ORRS     r0,r0,r7              ;1166
000106  63a0              STR      r0,[r4,#0x38]         ;1166
000108  2001              MOVS     r0,#1                 ;1167
00010a  f8840034          STRB     r0,[r4,#0x34]         ;1167
00010e  e787              B        |L21.32|
000110  e001              B        |L21.278|
                  |L21.274|
000112  2000              MOVS     r0,#0                 ;1171
000114  e784              B        |L21.32|
                  |L21.278|
000116  2002              MOVS     r0,#2                 ;1175
000118  e782              B        |L21.32|
;;;1178   
                          ENDP

00011a  0000              DCW      0x0000
                  |L21.284|
                          DCD      SD_DMAReceiveCplt
                  |L21.288|
                          DCD      SD_DMAError
                  |L21.292|
                          DCD      0x4225858c

                          AREA ||i.HAL_SD_ReadBlocks_IT||, CODE, READONLY, ALIGN=1

                  HAL_SD_ReadBlocks_IT PROC
;;;863      */
;;;864    HAL_StatusTypeDef HAL_SD_ReadBlocks_IT(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;865    {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4616              MOV      r6,r2
00000c  461d              MOV      r5,r3
;;;866      SDIO_DataInitTypeDef config;
;;;867      uint32_t errorstate = HAL_SD_ERROR_NONE;
00000e  2700              MOVS     r7,#0
;;;868      
;;;869      if(NULL == pData)
000010  f1b80f00          CMP      r8,#0
000014  d107              BNE      |L22.38|
;;;870      {
;;;871        hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
000016  6ba0              LDR      r0,[r4,#0x38]
000018  f0406000          ORR      r0,r0,#0x8000000
00001c  63a0              STR      r0,[r4,#0x38]
;;;872        return HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L22.32|
;;;873      }
;;;874      
;;;875      if(hsd->State == HAL_SD_STATE_READY)
;;;876      {
;;;877        hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;878        
;;;879        if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;880        {
;;;881          hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;882          return HAL_ERROR;
;;;883        }
;;;884        
;;;885        hsd->State = HAL_SD_STATE_BUSY;
;;;886        
;;;887        /* Initialize data control register */
;;;888        hsd->Instance->DCTRL = 0U;
;;;889        
;;;890        hsd->pRxBuffPtr = (uint32_t *)pData;
;;;891        hsd->RxXferSize = BLOCKSIZE * NumberOfBlocks;
;;;892        
;;;893    #ifdef SDIO_STA_STBITER
;;;894        __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND | SDIO_FLAG_RXFIFOHF | SDIO_IT_STBITERR));
;;;895    #else /* SDIO_STA_STBITERR not defined */
;;;896        __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_RXOVERR | SDIO_IT_DATAEND | SDIO_FLAG_RXFIFOHF));
;;;897    #endif /* SDIO_STA_STBITERR */
;;;898        
;;;899        if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;900        {
;;;901          BlockAdd *= 512U;
;;;902        }
;;;903        
;;;904        /* Configure the SD DPSM (Data Path State Machine) */ 
;;;905        config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;906        config.DataLength    = BLOCKSIZE * NumberOfBlocks;
;;;907        config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;908        config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;909        config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;910        config.DPSM          = SDIO_DPSM_ENABLE;
;;;911        SDIO_ConfigData(hsd->Instance, &config);
;;;912        
;;;913        /* Set Block Size for Card */ 
;;;914        errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;915        if(errorstate != HAL_SD_ERROR_NONE)
;;;916        {
;;;917          /* Clear all the static flags */
;;;918          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;919          hsd->ErrorCode |= errorstate;
;;;920          hsd->State = HAL_SD_STATE_READY;
;;;921          return HAL_ERROR;
;;;922        }
;;;923    
;;;924        /* Read Blocks in IT mode */
;;;925        if(NumberOfBlocks > 1U)
;;;926        {
;;;927          hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_IT);
;;;928          
;;;929          /* Read Multi Block command */
;;;930          errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, BlockAdd);
;;;931        }
;;;932        else
;;;933        {
;;;934          hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_IT);
;;;935          
;;;936          /* Read Single Block command */
;;;937          errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, BlockAdd);
;;;938        }
;;;939        if(errorstate != HAL_SD_ERROR_NONE)
;;;940        {
;;;941          /* Clear all the static flags */
;;;942          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;943          hsd->ErrorCode |= errorstate;
;;;944          hsd->State = HAL_SD_STATE_READY;
;;;945          return HAL_ERROR;
;;;946        }
;;;947        
;;;948        return HAL_OK;
;;;949      }
;;;950      else
;;;951      {
;;;952        return HAL_BUSY;
;;;953      }
;;;954    }
000020  b006              ADD      sp,sp,#0x18
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L22.38|
000026  f8940034          LDRB     r0,[r4,#0x34]         ;875
00002a  2801              CMP      r0,#1                 ;875
00002c  d162              BNE      |L22.244|
00002e  2000              MOVS     r0,#0                 ;877
000030  63a0              STR      r0,[r4,#0x38]         ;877
000032  1971              ADDS     r1,r6,r5              ;879
000034  6de0              LDR      r0,[r4,#0x5c]         ;879
000036  4281              CMP      r1,r0                 ;879
000038  d905              BLS      |L22.70|
00003a  6ba0              LDR      r0,[r4,#0x38]         ;881
00003c  f0407000          ORR      r0,r0,#0x2000000      ;881
000040  63a0              STR      r0,[r4,#0x38]         ;881
000042  2001              MOVS     r0,#1                 ;882
000044  e7ec              B        |L22.32|
                  |L22.70|
000046  2003              MOVS     r0,#3                 ;885
000048  f8840034          STRB     r0,[r4,#0x34]         ;885
00004c  2000              MOVS     r0,#0                 ;888
00004e  6821              LDR      r1,[r4,#0]            ;888
000050  62c8              STR      r0,[r1,#0x2c]         ;888
000052  f8c48028          STR      r8,[r4,#0x28]         ;890
000056  0268              LSLS     r0,r5,#9              ;891
000058  62e0              STR      r0,[r4,#0x2c]         ;891
00005a  6820              LDR      r0,[r4,#0]            ;896
00005c  6bc0              LDR      r0,[r0,#0x3c]         ;896
00005e  f248112a          MOV      r1,#0x812a            ;896
000062  4308              ORRS     r0,r0,r1              ;896
000064  6821              LDR      r1,[r4,#0]            ;896
000066  63c8              STR      r0,[r1,#0x3c]         ;896
000068  6c60              LDR      r0,[r4,#0x44]         ;899
00006a  2801              CMP      r0,#1                 ;899
00006c  d000              BEQ      |L22.112|
00006e  0276              LSLS     r6,r6,#9              ;901
                  |L22.112|
000070  f04f30ff          MOV      r0,#0xffffffff        ;905
000074  9000              STR      r0,[sp,#0]            ;905
000076  0268              LSLS     r0,r5,#9              ;906
000078  9001              STR      r0,[sp,#4]            ;906
00007a  2090              MOVS     r0,#0x90              ;907
00007c  9002              STR      r0,[sp,#8]            ;907
00007e  2002              MOVS     r0,#2                 ;908
000080  9003              STR      r0,[sp,#0xc]          ;908
000082  2000              MOVS     r0,#0                 ;909
000084  9004              STR      r0,[sp,#0x10]         ;909
000086  2001              MOVS     r0,#1                 ;910
000088  9005              STR      r0,[sp,#0x14]         ;910
00008a  4669              MOV      r1,sp                 ;911
00008c  6820              LDR      r0,[r4,#0]            ;911
00008e  f7fffffe          BL       SDIO_ConfigData
000092  f44f7100          MOV      r1,#0x200             ;914
000096  6820              LDR      r0,[r4,#0]            ;914
000098  f7fffffe          BL       SDMMC_CmdBlockLength
00009c  4607              MOV      r7,r0                 ;914
00009e  b157              CBZ      r7,|L22.182|
0000a0  f24050ff          MOV      r0,#0x5ff             ;918
0000a4  6821              LDR      r1,[r4,#0]            ;918
0000a6  6388              STR      r0,[r1,#0x38]         ;918
0000a8  6ba0              LDR      r0,[r4,#0x38]         ;919
0000aa  4338              ORRS     r0,r0,r7              ;919
0000ac  63a0              STR      r0,[r4,#0x38]         ;919
0000ae  2001              MOVS     r0,#1                 ;920
0000b0  f8840034          STRB     r0,[r4,#0x34]         ;920
0000b4  e7b4              B        |L22.32|
                  |L22.182|
0000b6  2d01              CMP      r5,#1                 ;925
0000b8  d907              BLS      |L22.202|
0000ba  200a              MOVS     r0,#0xa               ;927
0000bc  6320              STR      r0,[r4,#0x30]         ;927
0000be  4631              MOV      r1,r6                 ;930
0000c0  6820              LDR      r0,[r4,#0]            ;930
0000c2  f7fffffe          BL       SDMMC_CmdReadMultiBlock
0000c6  4607              MOV      r7,r0                 ;930
0000c8  e006              B        |L22.216|
                  |L22.202|
0000ca  2009              MOVS     r0,#9                 ;934
0000cc  6320              STR      r0,[r4,#0x30]         ;934
0000ce  4631              MOV      r1,r6                 ;937
0000d0  6820              LDR      r0,[r4,#0]            ;937
0000d2  f7fffffe          BL       SDMMC_CmdReadSingleBlock
0000d6  4607              MOV      r7,r0                 ;937
                  |L22.216|
0000d8  b157              CBZ      r7,|L22.240|
0000da  f24050ff          MOV      r0,#0x5ff             ;942
0000de  6821              LDR      r1,[r4,#0]            ;942
0000e0  6388              STR      r0,[r1,#0x38]         ;942
0000e2  6ba0              LDR      r0,[r4,#0x38]         ;943
0000e4  4338              ORRS     r0,r0,r7              ;943
0000e6  63a0              STR      r0,[r4,#0x38]         ;943
0000e8  2001              MOVS     r0,#1                 ;944
0000ea  f8840034          STRB     r0,[r4,#0x34]         ;944
0000ee  e797              B        |L22.32|
                  |L22.240|
0000f0  2000              MOVS     r0,#0                 ;948
0000f2  e795              B        |L22.32|
                  |L22.244|
0000f4  2002              MOVS     r0,#2                 ;952
0000f6  e793              B        |L22.32|
;;;955    
                          ENDP


                          AREA ||i.HAL_SD_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_RxCpltCallback PROC
;;;1663     */
;;;1664   __weak void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;1665   {
;;;1666     /* Prevent unused argument(s) compilation warning */
;;;1667     UNUSED(hsd);
;;;1668    
;;;1669     /* NOTE : This function should not be modified, when the callback is needed,
;;;1670               the HAL_SD_RxCpltCallback can be implemented in the user file
;;;1671      */
;;;1672   }
;;;1673   
                          ENDP


                          AREA ||i.HAL_SD_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_SD_TxCpltCallback PROC
;;;1648     */
;;;1649    __weak void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsd)
000000  4770              BX       lr
;;;1650   {
;;;1651     /* Prevent unused argument(s) compilation warning */
;;;1652     UNUSED(hsd);
;;;1653   
;;;1654     /* NOTE : This function should not be modified, when the callback is needed,
;;;1655               the HAL_SD_TxCpltCallback can be implemented in the user file
;;;1656      */
;;;1657   }
;;;1658   
                          ENDP


                          AREA ||i.HAL_SD_WriteBlocks||, CODE, READONLY, ALIGN=1

                  HAL_SD_WriteBlocks PROC
;;;687      */
;;;688    HAL_StatusTypeDef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks, uint32_t Timeout)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;689    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4617              MOV      r7,r2
00000c  461e              MOV      r6,r3
00000e  f8ddb040          LDR      r11,[sp,#0x40]
;;;690      SDIO_DataInitTypeDef config;
;;;691      uint32_t errorstate = HAL_SD_ERROR_NONE;
000012  2500              MOVS     r5,#0
;;;692      uint32_t tickstart = HAL_GetTick();
000014  f7fffffe          BL       HAL_GetTick
000018  9000              STR      r0,[sp,#0]
;;;693      uint32_t count = 0U;
00001a  46a9              MOV      r9,r5
;;;694      uint32_t *tempbuff = (uint32_t *)pData;
00001c  46c2              MOV      r10,r8
;;;695      
;;;696      if(NULL == pData)
00001e  f1b80f00          CMP      r8,#0
000022  d107              BNE      |L25.52|
;;;697      {
;;;698        hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
000024  6ba0              LDR      r0,[r4,#0x38]
000026  f0406000          ORR      r0,r0,#0x8000000
00002a  63a0              STR      r0,[r4,#0x38]
;;;699        return HAL_ERROR;
00002c  2001              MOVS     r0,#1
                  |L25.46|
;;;700      }
;;;701    
;;;702      if(hsd->State == HAL_SD_STATE_READY)
;;;703      {
;;;704        hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;705        
;;;706        if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;707        {
;;;708          hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;709          return HAL_ERROR;
;;;710        }
;;;711        
;;;712        hsd->State = HAL_SD_STATE_BUSY;
;;;713        
;;;714        /* Initialize data control register */
;;;715        hsd->Instance->DCTRL = 0U;
;;;716         
;;;717        if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;718        {
;;;719          BlockAdd *= 512U;
;;;720        }
;;;721        
;;;722        /* Set Block Size for Card */ 
;;;723        errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;724        if(errorstate != HAL_SD_ERROR_NONE)
;;;725        {
;;;726          /* Clear all the static flags */
;;;727          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);  
;;;728          hsd->ErrorCode |= errorstate;
;;;729          hsd->State = HAL_SD_STATE_READY;
;;;730          return HAL_ERROR;
;;;731        }
;;;732        
;;;733        /* Write Blocks in Polling mode */
;;;734        if(NumberOfBlocks > 1U)
;;;735        {
;;;736          hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
;;;737          
;;;738          /* Write Multi Block command */ 
;;;739          errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, BlockAdd);
;;;740        }
;;;741        else
;;;742        {
;;;743          hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
;;;744          
;;;745          /* Write Single Block command */
;;;746          errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, BlockAdd);
;;;747        }
;;;748        if(errorstate != HAL_SD_ERROR_NONE)
;;;749        {
;;;750          /* Clear all the static flags */
;;;751          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);  
;;;752          hsd->ErrorCode |= errorstate;
;;;753          hsd->State = HAL_SD_STATE_READY;
;;;754          return HAL_ERROR;
;;;755        }
;;;756        
;;;757        /* Configure the SD DPSM (Data Path State Machine) */ 
;;;758        config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;759        config.DataLength    = NumberOfBlocks * BLOCKSIZE;
;;;760        config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;761        config.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
;;;762        config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;763        config.DPSM          = SDIO_DPSM_ENABLE;
;;;764        SDIO_ConfigData(hsd->Instance, &config);
;;;765        
;;;766        /* Write block(s) in polling mode */
;;;767    #ifdef SDIO_STA_STBITERR
;;;768        while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND | SDIO_FLAG_STBITERR))
;;;769    #else /* SDIO_STA_STBITERR not defined */
;;;770        while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DATAEND))
;;;771    #endif /* SDIO_STA_STBITERR */
;;;772        {
;;;773          if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXFIFOHE))
;;;774          {
;;;775            /* Write data to SDIO Tx FIFO */
;;;776            for(count = 0U; count < 8U; count++)
;;;777            {
;;;778              SDIO_WriteFIFO(hsd->Instance, (tempbuff + count));
;;;779            }
;;;780            tempbuff += 8U;
;;;781          }
;;;782          
;;;783          if((Timeout == 0U)||((HAL_GetTick()-tickstart) >=  Timeout))
;;;784          {
;;;785            /* Clear all the static flags */
;;;786            __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);  
;;;787            hsd->ErrorCode |= errorstate;
;;;788            hsd->State = HAL_SD_STATE_READY;
;;;789            return HAL_TIMEOUT;
;;;790          }
;;;791        }
;;;792        
;;;793        /* Send stop transmission command in case of multiblock write */
;;;794        if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DATAEND) && (NumberOfBlocks > 1U))
;;;795        { 
;;;796          if(hsd->SdCard.CardType != CARD_SECURED)
;;;797          {
;;;798            /* Send stop transmission command */
;;;799            errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
;;;800            if(errorstate != HAL_SD_ERROR_NONE)
;;;801            {
;;;802              /* Clear all the static flags */
;;;803              __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);  
;;;804              hsd->ErrorCode |= errorstate;
;;;805              hsd->State = HAL_SD_STATE_READY;
;;;806              return HAL_ERROR;
;;;807            }
;;;808          }
;;;809        }
;;;810        
;;;811        /* Get error state */
;;;812        if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;813        {
;;;814          /* Clear all the static flags */
;;;815          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;816          hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
;;;817          hsd->State = HAL_SD_STATE_READY;
;;;818          return HAL_ERROR;
;;;819        }
;;;820        else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;821        {
;;;822          /* Clear all the static flags */
;;;823          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;824          hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;      
;;;825          hsd->State = HAL_SD_STATE_READY;
;;;826          return HAL_ERROR;
;;;827        }
;;;828        else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_TXUNDERR))
;;;829        {
;;;830          /* Clear all the static flags */
;;;831          __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;832          hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
;;;833          hsd->State = HAL_SD_STATE_READY;
;;;834          return HAL_ERROR;
;;;835        }
;;;836        
;;;837        /* Clear all the static flags */
;;;838        __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;839        
;;;840        hsd->State = HAL_SD_STATE_READY;
;;;841        
;;;842        return HAL_OK;
;;;843      }
;;;844      else
;;;845      {
;;;846        hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
;;;847        return HAL_ERROR;
;;;848      }
;;;849    }
00002e  b007              ADD      sp,sp,#0x1c
000030  e8bd8ff0          POP      {r4-r11,pc}
                  |L25.52|
000034  f8940034          LDRB     r0,[r4,#0x34]         ;702
000038  2801              CMP      r0,#1                 ;702
00003a  d17d              BNE      |L25.312|
00003c  2000              MOVS     r0,#0                 ;704
00003e  63a0              STR      r0,[r4,#0x38]         ;704
000040  19b9              ADDS     r1,r7,r6              ;706
000042  6de0              LDR      r0,[r4,#0x5c]         ;706
000044  4281              CMP      r1,r0                 ;706
000046  d905              BLS      |L25.84|
000048  6ba0              LDR      r0,[r4,#0x38]         ;708
00004a  f0407000          ORR      r0,r0,#0x2000000      ;708
00004e  63a0              STR      r0,[r4,#0x38]         ;708
000050  2001              MOVS     r0,#1                 ;709
000052  e7ec              B        |L25.46|
                  |L25.84|
000054  2003              MOVS     r0,#3                 ;712
000056  f8840034          STRB     r0,[r4,#0x34]         ;712
00005a  2000              MOVS     r0,#0                 ;715
00005c  6821              LDR      r1,[r4,#0]            ;715
00005e  62c8              STR      r0,[r1,#0x2c]         ;715
000060  6c60              LDR      r0,[r4,#0x44]         ;717
000062  2801              CMP      r0,#1                 ;717
000064  d000              BEQ      |L25.104|
000066  027f              LSLS     r7,r7,#9              ;719
                  |L25.104|
000068  f44f7100          MOV      r1,#0x200             ;723
00006c  6820              LDR      r0,[r4,#0]            ;723
00006e  f7fffffe          BL       SDMMC_CmdBlockLength
000072  4605              MOV      r5,r0                 ;723
000074  b155              CBZ      r5,|L25.140|
000076  f24050ff          MOV      r0,#0x5ff             ;727
00007a  6821              LDR      r1,[r4,#0]            ;727
00007c  6388              STR      r0,[r1,#0x38]         ;727
00007e  6ba0              LDR      r0,[r4,#0x38]         ;728
000080  4328              ORRS     r0,r0,r5              ;728
000082  63a0              STR      r0,[r4,#0x38]         ;728
000084  2001              MOVS     r0,#1                 ;729
000086  f8840034          STRB     r0,[r4,#0x34]         ;729
00008a  e7d0              B        |L25.46|
                  |L25.140|
00008c  2e01              CMP      r6,#1                 ;734
00008e  d907              BLS      |L25.160|
000090  2020              MOVS     r0,#0x20              ;736
000092  6320              STR      r0,[r4,#0x30]         ;736
000094  4639              MOV      r1,r7                 ;739
000096  6820              LDR      r0,[r4,#0]            ;739
000098  f7fffffe          BL       SDMMC_CmdWriteMultiBlock
00009c  4605              MOV      r5,r0                 ;739
00009e  e006              B        |L25.174|
                  |L25.160|
0000a0  2010              MOVS     r0,#0x10              ;743
0000a2  6320              STR      r0,[r4,#0x30]         ;743
0000a4  4639              MOV      r1,r7                 ;746
0000a6  6820              LDR      r0,[r4,#0]            ;746
0000a8  f7fffffe          BL       SDMMC_CmdWriteSingleBlock
0000ac  4605              MOV      r5,r0                 ;746
                  |L25.174|
0000ae  b155              CBZ      r5,|L25.198|
0000b0  f24050ff          MOV      r0,#0x5ff             ;751
0000b4  6821              LDR      r1,[r4,#0]            ;751
0000b6  6388              STR      r0,[r1,#0x38]         ;751
0000b8  6ba0              LDR      r0,[r4,#0x38]         ;752
0000ba  4328              ORRS     r0,r0,r5              ;752
0000bc  63a0              STR      r0,[r4,#0x38]         ;752
0000be  2001              MOVS     r0,#1                 ;753
0000c0  f8840034          STRB     r0,[r4,#0x34]         ;753
0000c4  e7b3              B        |L25.46|
                  |L25.198|
0000c6  f04f30ff          MOV      r0,#0xffffffff        ;758
0000ca  9001              STR      r0,[sp,#4]            ;758
0000cc  0270              LSLS     r0,r6,#9              ;759
0000ce  9002              STR      r0,[sp,#8]            ;759
0000d0  2090              MOVS     r0,#0x90              ;760
0000d2  9003              STR      r0,[sp,#0xc]          ;760
0000d4  2000              MOVS     r0,#0                 ;761
0000d6  9004              STR      r0,[sp,#0x10]         ;761
0000d8  9005              STR      r0,[sp,#0x14]         ;762
0000da  2001              MOVS     r0,#1                 ;763
0000dc  9006              STR      r0,[sp,#0x18]         ;763
0000de  a901              ADD      r1,sp,#4              ;764
0000e0  6820              LDR      r0,[r4,#0]            ;764
0000e2  f7fffffe          BL       SDIO_ConfigData
0000e6  e02a              B        |L25.318|
                  |L25.232|
0000e8  6820              LDR      r0,[r4,#0]            ;773
0000ea  6b40              LDR      r0,[r0,#0x34]         ;773
0000ec  f4004080          AND      r0,r0,#0x4000         ;773
0000f0  b170              CBZ      r0,|L25.272|
0000f2  f04f0900          MOV      r9,#0                 ;776
0000f6  e006              B        |L25.262|
                  |L25.248|
0000f8  eb0a0189          ADD      r1,r10,r9,LSL #2      ;778
0000fc  6820              LDR      r0,[r4,#0]            ;778
0000fe  f7fffffe          BL       SDIO_WriteFIFO
000102  f1090901          ADD      r9,r9,#1              ;776
                  |L25.262|
000106  f1b90f08          CMP      r9,#8                 ;776
00010a  d3f5              BCC      |L25.248|
00010c  f10a0a20          ADD      r10,r10,#0x20         ;780
                  |L25.272|
000110  f1bb0f00          CMP      r11,#0                ;783
000114  d005              BEQ      |L25.290|
000116  f7fffffe          BL       HAL_GetTick
00011a  9900              LDR      r1,[sp,#0]            ;783
00011c  1a40              SUBS     r0,r0,r1              ;783
00011e  4558              CMP      r0,r11                ;783
000120  d30d              BCC      |L25.318|
                  |L25.290|
000122  f24050ff          MOV      r0,#0x5ff             ;786
000126  6821              LDR      r1,[r4,#0]            ;786
000128  6388              STR      r0,[r1,#0x38]         ;786
00012a  6ba0              LDR      r0,[r4,#0x38]         ;787
00012c  4328              ORRS     r0,r0,r5              ;787
00012e  63a0              STR      r0,[r4,#0x38]         ;787
000130  2001              MOVS     r0,#1                 ;788
000132  f8840034          STRB     r0,[r4,#0x34]         ;788
000136  e000              B        |L25.314|
                  |L25.312|
000138  e05e              B        |L25.504|
                  |L25.314|
00013a  2003              MOVS     r0,#3                 ;789
00013c  e777              B        |L25.46|
                  |L25.318|
00013e  6820              LDR      r0,[r4,#0]            ;768
000140  6b40              LDR      r0,[r0,#0x34]         ;768
000142  f240311a          MOV      r1,#0x31a             ;768
000146  4008              ANDS     r0,r0,r1              ;768
000148  2800              CMP      r0,#0                 ;768
00014a  d0cd              BEQ      |L25.232|
00014c  6820              LDR      r0,[r4,#0]            ;794
00014e  6b40              LDR      r0,[r0,#0x34]         ;794
000150  f4007080          AND      r0,r0,#0x100          ;794
000154  b1a0              CBZ      r0,|L25.384|
000156  2e01              CMP      r6,#1                 ;794
000158  d912              BLS      |L25.384|
00015a  6c60              LDR      r0,[r4,#0x44]         ;796
00015c  2803              CMP      r0,#3                 ;796
00015e  d00f              BEQ      |L25.384|
000160  6820              LDR      r0,[r4,#0]            ;799
000162  f7fffffe          BL       SDMMC_CmdStopTransfer
000166  4605              MOV      r5,r0                 ;799
000168  b155              CBZ      r5,|L25.384|
00016a  f24050ff          MOV      r0,#0x5ff             ;803
00016e  6821              LDR      r1,[r4,#0]            ;803
000170  6388              STR      r0,[r1,#0x38]         ;803
000172  6ba0              LDR      r0,[r4,#0x38]         ;804
000174  4328              ORRS     r0,r0,r5              ;804
000176  63a0              STR      r0,[r4,#0x38]         ;804
000178  2001              MOVS     r0,#1                 ;805
00017a  f8840034          STRB     r0,[r4,#0x34]         ;805
00017e  e756              B        |L25.46|
                  |L25.384|
000180  6820              LDR      r0,[r4,#0]            ;812
000182  6b40              LDR      r0,[r0,#0x34]         ;812
000184  f0000008          AND      r0,r0,#8              ;812
000188  b158              CBZ      r0,|L25.418|
00018a  f24050ff          MOV      r0,#0x5ff             ;815
00018e  6821              LDR      r1,[r4,#0]            ;815
000190  6388              STR      r0,[r1,#0x38]         ;815
000192  6ba0              LDR      r0,[r4,#0x38]         ;816
000194  f0400008          ORR      r0,r0,#8              ;816
000198  63a0              STR      r0,[r4,#0x38]         ;816
00019a  2001              MOVS     r0,#1                 ;817
00019c  f8840034          STRB     r0,[r4,#0x34]         ;817
0001a0  e745              B        |L25.46|
                  |L25.418|
0001a2  6820              LDR      r0,[r4,#0]            ;820
0001a4  6b40              LDR      r0,[r0,#0x34]         ;820
0001a6  f0000002          AND      r0,r0,#2              ;820
0001aa  b158              CBZ      r0,|L25.452|
0001ac  f24050ff          MOV      r0,#0x5ff             ;823
0001b0  6821              LDR      r1,[r4,#0]            ;823
0001b2  6388              STR      r0,[r1,#0x38]         ;823
0001b4  6ba0              LDR      r0,[r4,#0x38]         ;824
0001b6  f0400002          ORR      r0,r0,#2              ;824
0001ba  63a0              STR      r0,[r4,#0x38]         ;824
0001bc  2001              MOVS     r0,#1                 ;825
0001be  f8840034          STRB     r0,[r4,#0x34]         ;825
0001c2  e734              B        |L25.46|
                  |L25.452|
0001c4  6820              LDR      r0,[r4,#0]            ;828
0001c6  6b40              LDR      r0,[r0,#0x34]         ;828
0001c8  f0000010          AND      r0,r0,#0x10           ;828
0001cc  b158              CBZ      r0,|L25.486|
0001ce  f24050ff          MOV      r0,#0x5ff             ;831
0001d2  6821              LDR      r1,[r4,#0]            ;831
0001d4  6388              STR      r0,[r1,#0x38]         ;831
0001d6  6ba0              LDR      r0,[r4,#0x38]         ;832
0001d8  f0400010          ORR      r0,r0,#0x10           ;832
0001dc  63a0              STR      r0,[r4,#0x38]         ;832
0001de  2001              MOVS     r0,#1                 ;833
0001e0  f8840034          STRB     r0,[r4,#0x34]         ;833
0001e4  e723              B        |L25.46|
                  |L25.486|
0001e6  f24050ff          MOV      r0,#0x5ff             ;838
0001ea  6821              LDR      r1,[r4,#0]            ;838
0001ec  6388              STR      r0,[r1,#0x38]         ;838
0001ee  2001              MOVS     r0,#1                 ;840
0001f0  f8840034          STRB     r0,[r4,#0x34]         ;840
0001f4  2000              MOVS     r0,#0                 ;842
0001f6  e71a              B        |L25.46|
                  |L25.504|
0001f8  6ba0              LDR      r0,[r4,#0x38]         ;846
0001fa  f0405000          ORR      r0,r0,#0x20000000     ;846
0001fe  63a0              STR      r0,[r4,#0x38]         ;846
000200  2001              MOVS     r0,#1                 ;847
000202  e714              B        |L25.46|
;;;850    
                          ENDP


                          AREA ||i.HAL_SD_WriteBlocks_DMA||, CODE, READONLY, ALIGN=2

                  HAL_SD_WriteBlocks_DMA PROC
;;;1191     */
;;;1192   HAL_StatusTypeDef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1193   {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4616              MOV      r6,r2
00000c  461d              MOV      r5,r3
;;;1194     SDIO_DataInitTypeDef config;
;;;1195     uint32_t errorstate = HAL_SD_ERROR_NONE;
00000e  2700              MOVS     r7,#0
;;;1196     
;;;1197     if(NULL == pData)
000010  f1b80f00          CMP      r8,#0
000014  d107              BNE      |L26.38|
;;;1198     {
;;;1199       hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
000016  6ba0              LDR      r0,[r4,#0x38]
000018  f0406000          ORR      r0,r0,#0x8000000
00001c  63a0              STR      r0,[r4,#0x38]
;;;1200       return HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L26.32|
;;;1201     }
;;;1202     
;;;1203     if(hsd->State == HAL_SD_STATE_READY)
;;;1204     {
;;;1205       hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;1206       
;;;1207       if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;1208       {
;;;1209         hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;1210         return HAL_ERROR;
;;;1211       }
;;;1212       
;;;1213       hsd->State = HAL_SD_STATE_BUSY;
;;;1214       
;;;1215       /* Initialize data control register */
;;;1216       hsd->Instance->DCTRL = 0U;
;;;1217       
;;;1218       /* Enable SD Error interrupts */  
;;;1219   #ifdef SDIO_STA_STBITER
;;;1220       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR | SDIO_IT_STBITERR));    
;;;1221   #else /* SDIO_STA_STBITERR not defined */
;;;1222       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR));    
;;;1223   #endif /* SDIO_STA_STBITERR */
;;;1224       
;;;1225       /* Set the DMA transfer complete callback */
;;;1226       hsd->hdmatx->XferCpltCallback = SD_DMATransmitCplt;
;;;1227       
;;;1228       /* Set the DMA error callback */
;;;1229       hsd->hdmatx->XferErrorCallback = SD_DMAError;
;;;1230       
;;;1231       /* Set the DMA Abort callback */
;;;1232       hsd->hdmatx->XferAbortCallback = NULL;
;;;1233       
;;;1234       if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;1235       {
;;;1236         BlockAdd *= 512U;
;;;1237       }
;;;1238       
;;;1239       /* Set Block Size for Card */ 
;;;1240       errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;1241       if(errorstate != HAL_SD_ERROR_NONE)
;;;1242       {
;;;1243         /* Clear all the static flags */
;;;1244         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1245         hsd->ErrorCode |= errorstate;
;;;1246         hsd->State = HAL_SD_STATE_READY;
;;;1247         return HAL_ERROR;
;;;1248       }
;;;1249       
;;;1250       /* Write Blocks in Polling mode */
;;;1251       if(NumberOfBlocks > 1U)
;;;1252       {
;;;1253         hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
;;;1254         
;;;1255         /* Write Multi Block command */ 
;;;1256         errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, BlockAdd);
;;;1257       }
;;;1258       else
;;;1259       {
;;;1260         hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
;;;1261         
;;;1262         /* Write Single Block command */
;;;1263         errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, BlockAdd);
;;;1264       }
;;;1265       if(errorstate != HAL_SD_ERROR_NONE)
;;;1266       {
;;;1267         /* Clear all the static flags */
;;;1268         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1269         hsd->ErrorCode |= errorstate;
;;;1270         hsd->State = HAL_SD_STATE_READY;
;;;1271         return HAL_ERROR;
;;;1272       }
;;;1273       
;;;1274       /* Enable SDIO DMA transfer */
;;;1275       __HAL_SD_DMA_ENABLE(hsd);
;;;1276       
;;;1277       /* Enable the DMA Channel */
;;;1278       HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4);
;;;1279       
;;;1280       /* Configure the SD DPSM (Data Path State Machine) */ 
;;;1281       config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;1282       config.DataLength    = BLOCKSIZE * NumberOfBlocks;
;;;1283       config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;1284       config.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
;;;1285       config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;1286       config.DPSM          = SDIO_DPSM_ENABLE;
;;;1287       SDIO_ConfigData(hsd->Instance, &config);
;;;1288       
;;;1289       return HAL_OK;
;;;1290     }
;;;1291     else
;;;1292     {
;;;1293       return HAL_BUSY;
;;;1294     }
;;;1295   }
000020  b006              ADD      sp,sp,#0x18
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L26.38|
000026  f8940034          LDRB     r0,[r4,#0x34]         ;1203
00002a  2801              CMP      r0,#1                 ;1203
00002c  d172              BNE      |L26.276|
00002e  2000              MOVS     r0,#0                 ;1205
000030  63a0              STR      r0,[r4,#0x38]         ;1205
000032  1971              ADDS     r1,r6,r5              ;1207
000034  6de0              LDR      r0,[r4,#0x5c]         ;1207
000036  4281              CMP      r1,r0                 ;1207
000038  d905              BLS      |L26.70|
00003a  6ba0              LDR      r0,[r4,#0x38]         ;1209
00003c  f0407000          ORR      r0,r0,#0x2000000      ;1209
000040  63a0              STR      r0,[r4,#0x38]         ;1209
000042  2001              MOVS     r0,#1                 ;1210
000044  e7ec              B        |L26.32|
                  |L26.70|
000046  2003              MOVS     r0,#3                 ;1213
000048  f8840034          STRB     r0,[r4,#0x34]         ;1213
00004c  2000              MOVS     r0,#0                 ;1216
00004e  6821              LDR      r1,[r4,#0]            ;1216
000050  62c8              STR      r0,[r1,#0x2c]         ;1216
000052  6820              LDR      r0,[r4,#0]            ;1222
000054  6bc0              LDR      r0,[r0,#0x3c]         ;1222
000056  f040001a          ORR      r0,r0,#0x1a           ;1222
00005a  6821              LDR      r1,[r4,#0]            ;1222
00005c  63c8              STR      r0,[r1,#0x3c]         ;1222
00005e  482e              LDR      r0,|L26.280|
000060  6c21              LDR      r1,[r4,#0x40]         ;1226
000062  63c8              STR      r0,[r1,#0x3c]         ;1226
000064  482d              LDR      r0,|L26.284|
000066  6c21              LDR      r1,[r4,#0x40]         ;1229
000068  64c8              STR      r0,[r1,#0x4c]         ;1229
00006a  2000              MOVS     r0,#0                 ;1232
00006c  6c21              LDR      r1,[r4,#0x40]         ;1232
00006e  6508              STR      r0,[r1,#0x50]         ;1232
000070  6c60              LDR      r0,[r4,#0x44]         ;1234
000072  2801              CMP      r0,#1                 ;1234
000074  d000              BEQ      |L26.120|
000076  0276              LSLS     r6,r6,#9              ;1236
                  |L26.120|
000078  f44f7100          MOV      r1,#0x200             ;1240
00007c  6820              LDR      r0,[r4,#0]            ;1240
00007e  f7fffffe          BL       SDMMC_CmdBlockLength
000082  4607              MOV      r7,r0                 ;1240
000084  b157              CBZ      r7,|L26.156|
000086  f24050ff          MOV      r0,#0x5ff             ;1244
00008a  6821              LDR      r1,[r4,#0]            ;1244
00008c  6388              STR      r0,[r1,#0x38]         ;1244
00008e  6ba0              LDR      r0,[r4,#0x38]         ;1245
000090  4338              ORRS     r0,r0,r7              ;1245
000092  63a0              STR      r0,[r4,#0x38]         ;1245
000094  2001              MOVS     r0,#1                 ;1246
000096  f8840034          STRB     r0,[r4,#0x34]         ;1246
00009a  e7c1              B        |L26.32|
                  |L26.156|
00009c  2d01              CMP      r5,#1                 ;1251
00009e  d907              BLS      |L26.176|
0000a0  20a0              MOVS     r0,#0xa0              ;1253
0000a2  6320              STR      r0,[r4,#0x30]         ;1253
0000a4  4631              MOV      r1,r6                 ;1256
0000a6  6820              LDR      r0,[r4,#0]            ;1256
0000a8  f7fffffe          BL       SDMMC_CmdWriteMultiBlock
0000ac  4607              MOV      r7,r0                 ;1256
0000ae  e006              B        |L26.190|
                  |L26.176|
0000b0  2090              MOVS     r0,#0x90              ;1260
0000b2  6320              STR      r0,[r4,#0x30]         ;1260
0000b4  4631              MOV      r1,r6                 ;1263
0000b6  6820              LDR      r0,[r4,#0]            ;1263
0000b8  f7fffffe          BL       SDMMC_CmdWriteSingleBlock
0000bc  4607              MOV      r7,r0                 ;1263
                  |L26.190|
0000be  b157              CBZ      r7,|L26.214|
0000c0  f24050ff          MOV      r0,#0x5ff             ;1268
0000c4  6821              LDR      r1,[r4,#0]            ;1268
0000c6  6388              STR      r0,[r1,#0x38]         ;1268
0000c8  6ba0              LDR      r0,[r4,#0x38]         ;1269
0000ca  4338              ORRS     r0,r0,r7              ;1269
0000cc  63a0              STR      r0,[r4,#0x38]         ;1269
0000ce  2001              MOVS     r0,#1                 ;1270
0000d0  f8840034          STRB     r0,[r4,#0x34]         ;1270
0000d4  e7a4              B        |L26.32|
                  |L26.214|
0000d6  2001              MOVS     r0,#1                 ;1275
0000d8  4911              LDR      r1,|L26.288|
0000da  6008              STR      r0,[r1,#0]            ;1275
0000dc  0269              LSLS     r1,r5,#9              ;1278
0000de  088b              LSRS     r3,r1,#2              ;1278
0000e0  6821              LDR      r1,[r4,#0]            ;1278
0000e2  f1010280          ADD      r2,r1,#0x80           ;1278
0000e6  4641              MOV      r1,r8                 ;1278
0000e8  6c20              LDR      r0,[r4,#0x40]         ;1278
0000ea  f7fffffe          BL       HAL_DMA_Start_IT
0000ee  f04f30ff          MOV      r0,#0xffffffff        ;1281
0000f2  9000              STR      r0,[sp,#0]            ;1281
0000f4  0268              LSLS     r0,r5,#9              ;1282
0000f6  9001              STR      r0,[sp,#4]            ;1282
0000f8  2090              MOVS     r0,#0x90              ;1283
0000fa  9002              STR      r0,[sp,#8]            ;1283
0000fc  2000              MOVS     r0,#0                 ;1284
0000fe  9003              STR      r0,[sp,#0xc]          ;1284
000100  9004              STR      r0,[sp,#0x10]         ;1285
000102  2001              MOVS     r0,#1                 ;1286
000104  9005              STR      r0,[sp,#0x14]         ;1286
000106  4669              MOV      r1,sp                 ;1287
000108  6820              LDR      r0,[r4,#0]            ;1287
00010a  f7fffffe          BL       SDIO_ConfigData
00010e  2000              MOVS     r0,#0                 ;1289
000110  e786              B        |L26.32|
000112  e7ff              B        |L26.276|
                  |L26.276|
000114  2002              MOVS     r0,#2                 ;1293
000116  e783              B        |L26.32|
;;;1296   
                          ENDP

                  |L26.280|
                          DCD      SD_DMATransmitCplt
                  |L26.284|
                          DCD      SD_DMAError
                  |L26.288|
                          DCD      0x4225858c

                          AREA ||i.HAL_SD_WriteBlocks_IT||, CODE, READONLY, ALIGN=1

                  HAL_SD_WriteBlocks_IT PROC
;;;968      */
;;;969    HAL_StatusTypeDef HAL_SD_WriteBlocks_IT(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;970    {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
000008  4688              MOV      r8,r1
00000a  4616              MOV      r6,r2
00000c  461d              MOV      r5,r3
;;;971      SDIO_DataInitTypeDef config;
;;;972      uint32_t errorstate = HAL_SD_ERROR_NONE;
00000e  2700              MOVS     r7,#0
;;;973      
;;;974      if(NULL == pData)
000010  f1b80f00          CMP      r8,#0
000014  d107              BNE      |L27.38|
;;;975      {
;;;976        hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
000016  6ba0              LDR      r0,[r4,#0x38]
000018  f0406000          ORR      r0,r0,#0x8000000
00001c  63a0              STR      r0,[r4,#0x38]
;;;977        return HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L27.32|
;;;978      }
;;;979      
;;;980      if(hsd->State == HAL_SD_STATE_READY)
;;;981      {
;;;982        hsd->ErrorCode = HAL_DMA_ERROR_NONE;
;;;983        
;;;984        if((BlockAdd + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
;;;985        {
;;;986          hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
;;;987          return HAL_ERROR;
;;;988        }
;;;989        
;;;990        hsd->State = HAL_SD_STATE_BUSY;
;;;991        
;;;992        /* Initialize data control register */
;;;993        hsd->Instance->DCTRL = 0U;
;;;994        
;;;995        hsd->pTxBuffPtr = (uint32_t *)pData;
;;;996        hsd->TxXferSize = BLOCKSIZE * NumberOfBlocks;
;;;997        
;;;998        /* Enable transfer interrupts */
;;;999    #ifdef SDIO_STA_STBITER
;;;1000       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR | SDIO_IT_DATAEND | SDIO_FLAG_TXFIFOHE | SDIO_IT_STBITERR));    
;;;1001   #else /* SDIO_STA_STBITERR not defined */
;;;1002       __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_TXUNDERR | SDIO_IT_DATAEND | SDIO_FLAG_TXFIFOHE));    
;;;1003   #endif /* SDIO_STA_STBITERR */
;;;1004       
;;;1005       if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
;;;1006       {
;;;1007         BlockAdd *= 512U;
;;;1008       }
;;;1009       
;;;1010       /* Set Block Size for Card */ 
;;;1011       errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
;;;1012       if(errorstate != HAL_SD_ERROR_NONE)
;;;1013       {
;;;1014         /* Clear all the static flags */
;;;1015         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1016         hsd->ErrorCode |= errorstate;
;;;1017         hsd->State = HAL_SD_STATE_READY;
;;;1018         return HAL_ERROR;
;;;1019       }
;;;1020       
;;;1021       /* Write Blocks in Polling mode */
;;;1022       if(NumberOfBlocks > 1U)
;;;1023       {
;;;1024         hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK| SD_CONTEXT_IT);
;;;1025         
;;;1026         /* Write Multi Block command */ 
;;;1027         errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, BlockAdd);
;;;1028       }
;;;1029       else
;;;1030       {
;;;1031         hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_IT);
;;;1032         
;;;1033         /* Write Single Block command */ 
;;;1034         errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, BlockAdd);
;;;1035       }
;;;1036       if(errorstate != HAL_SD_ERROR_NONE)
;;;1037       {
;;;1038         /* Clear all the static flags */
;;;1039         __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS); 
;;;1040         hsd->ErrorCode |= errorstate;
;;;1041         hsd->State = HAL_SD_STATE_READY;
;;;1042         return HAL_ERROR;
;;;1043       }
;;;1044       
;;;1045       /* Configure the SD DPSM (Data Path State Machine) */ 
;;;1046       config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;1047       config.DataLength    = BLOCKSIZE * NumberOfBlocks;
;;;1048       config.DataBlockSize = SDIO_DATABLOCK_SIZE_512B;
;;;1049       config.TransferDir   = SDIO_TRANSFER_DIR_TO_CARD;
;;;1050       config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;1051       config.DPSM          = SDIO_DPSM_ENABLE;
;;;1052       SDIO_ConfigData(hsd->Instance, &config);
;;;1053       
;;;1054       return HAL_OK;
;;;1055     }
;;;1056     else
;;;1057     {
;;;1058       return HAL_BUSY;
;;;1059     }
;;;1060   }
000020  b006              ADD      sp,sp,#0x18
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L27.38|
000026  f8940034          LDRB     r0,[r4,#0x34]         ;980
00002a  2801              CMP      r0,#1                 ;980
00002c  d161              BNE      |L27.242|
00002e  2000              MOVS     r0,#0                 ;982
000030  63a0              STR      r0,[r4,#0x38]         ;982
000032  1971              ADDS     r1,r6,r5              ;984
000034  6de0              LDR      r0,[r4,#0x5c]         ;984
000036  4281              CMP      r1,r0                 ;984
000038  d905              BLS      |L27.70|
00003a  6ba0              LDR      r0,[r4,#0x38]         ;986
00003c  f0407000          ORR      r0,r0,#0x2000000      ;986
000040  63a0              STR      r0,[r4,#0x38]         ;986
000042  2001              MOVS     r0,#1                 ;987
000044  e7ec              B        |L27.32|
                  |L27.70|
000046  2003              MOVS     r0,#3                 ;990
000048  f8840034          STRB     r0,[r4,#0x34]         ;990
00004c  2000              MOVS     r0,#0                 ;993
00004e  6821              LDR      r1,[r4,#0]            ;993
000050  62c8              STR      r0,[r1,#0x2c]         ;993
000052  f8c48020          STR      r8,[r4,#0x20]         ;995
000056  0268              LSLS     r0,r5,#9              ;996
000058  6260              STR      r0,[r4,#0x24]         ;996
00005a  6820              LDR      r0,[r4,#0]            ;1002
00005c  6bc0              LDR      r0,[r0,#0x3c]         ;1002
00005e  f244111a          MOV      r1,#0x411a            ;1002
000062  4308              ORRS     r0,r0,r1              ;1002
000064  6821              LDR      r1,[r4,#0]            ;1002
000066  63c8              STR      r0,[r1,#0x3c]         ;1002
000068  6c60              LDR      r0,[r4,#0x44]         ;1005
00006a  2801              CMP      r0,#1                 ;1005
00006c  d000              BEQ      |L27.112|
00006e  0276              LSLS     r6,r6,#9              ;1007
                  |L27.112|
000070  f44f7100          MOV      r1,#0x200             ;1011
000074  6820              LDR      r0,[r4,#0]            ;1011
000076  f7fffffe          BL       SDMMC_CmdBlockLength
00007a  4607              MOV      r7,r0                 ;1011
00007c  b157              CBZ      r7,|L27.148|
00007e  f24050ff          MOV      r0,#0x5ff             ;1015
000082  6821              LDR      r1,[r4,#0]            ;1015
000084  6388              STR      r0,[r1,#0x38]         ;1015
000086  6ba0              LDR      r0,[r4,#0x38]         ;1016
000088  4338              ORRS     r0,r0,r7              ;1016
00008a  63a0              STR      r0,[r4,#0x38]         ;1016
00008c  2001              MOVS     r0,#1                 ;1017
00008e  f8840034          STRB     r0,[r4,#0x34]         ;1017
000092  e7c5              B        |L27.32|
                  |L27.148|
000094  2d01              CMP      r5,#1                 ;1022
000096  d907              BLS      |L27.168|
000098  2028              MOVS     r0,#0x28              ;1024
00009a  6320              STR      r0,[r4,#0x30]         ;1024
00009c  4631              MOV      r1,r6                 ;1027
00009e  6820              LDR      r0,[r4,#0]            ;1027
0000a0  f7fffffe          BL       SDMMC_CmdWriteMultiBlock
0000a4  4607              MOV      r7,r0                 ;1027
0000a6  e006              B        |L27.182|
                  |L27.168|
0000a8  2018              MOVS     r0,#0x18              ;1031
0000aa  6320              STR      r0,[r4,#0x30]         ;1031
0000ac  4631              MOV      r1,r6                 ;1034
0000ae  6820              LDR      r0,[r4,#0]            ;1034
0000b0  f7fffffe          BL       SDMMC_CmdWriteSingleBlock
0000b4  4607              MOV      r7,r0                 ;1034
                  |L27.182|
0000b6  b157              CBZ      r7,|L27.206|
0000b8  f24050ff          MOV      r0,#0x5ff             ;1039
0000bc  6821              LDR      r1,[r4,#0]            ;1039
0000be  6388              STR      r0,[r1,#0x38]         ;1039
0000c0  6ba0              LDR      r0,[r4,#0x38]         ;1040
0000c2  4338              ORRS     r0,r0,r7              ;1040
0000c4  63a0              STR      r0,[r4,#0x38]         ;1040
0000c6  2001              MOVS     r0,#1                 ;1041
0000c8  f8840034          STRB     r0,[r4,#0x34]         ;1041
0000cc  e7a8              B        |L27.32|
                  |L27.206|
0000ce  f04f30ff          MOV      r0,#0xffffffff        ;1046
0000d2  9000              STR      r0,[sp,#0]            ;1046
0000d4  0268              LSLS     r0,r5,#9              ;1047
0000d6  9001              STR      r0,[sp,#4]            ;1047
0000d8  2090              MOVS     r0,#0x90              ;1048
0000da  9002              STR      r0,[sp,#8]            ;1048
0000dc  2000              MOVS     r0,#0                 ;1049
0000de  9003              STR      r0,[sp,#0xc]          ;1049
0000e0  9004              STR      r0,[sp,#0x10]         ;1050
0000e2  2001              MOVS     r0,#1                 ;1051
0000e4  9005              STR      r0,[sp,#0x14]         ;1051
0000e6  4669              MOV      r1,sp                 ;1052
0000e8  6820              LDR      r0,[r4,#0]            ;1052
0000ea  f7fffffe          BL       SDIO_ConfigData
0000ee  2000              MOVS     r0,#0                 ;1054
0000f0  e796              B        |L27.32|
                  |L27.242|
0000f2  2002              MOVS     r0,#2                 ;1058
0000f4  e794              B        |L27.32|
;;;1061   
                          ENDP


                          AREA ||i.SD_DMAError||, CODE, READONLY, ALIGN=1

                  SD_DMAError PROC
;;;2336     */
;;;2337   static void SD_DMAError(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2338   {
000002  4606              MOV      r6,r0
;;;2339     SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
000004  6bb4              LDR      r4,[r6,#0x38]
;;;2340     HAL_SD_CardStateTypeDef CardState;
;;;2341     
;;;2342     if((hsd->hdmarx->ErrorCode == HAL_DMA_ERROR_TE) || (hsd->hdmatx->ErrorCode == HAL_DMA_ERROR_TE))
000006  6be0              LDR      r0,[r4,#0x3c]
000008  6d40              LDR      r0,[r0,#0x54]
00000a  2801              CMP      r0,#1
00000c  d003              BEQ      |L28.22|
00000e  6c20              LDR      r0,[r4,#0x40]
000010  6d40              LDR      r0,[r0,#0x54]
000012  2801              CMP      r0,#1
000014  d11e              BNE      |L28.84|
                  |L28.22|
;;;2343     {
;;;2344       /* Clear All flags */
;;;2345       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
000016  f24050ff          MOV      r0,#0x5ff
00001a  6821              LDR      r1,[r4,#0]
00001c  6388              STR      r0,[r1,#0x38]
;;;2346       
;;;2347       /* Disable All interrupts */
;;;2348       __HAL_SD_DISABLE_IT(hsd, SDIO_IT_DATAEND | SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT|\
00001e  6820              LDR      r0,[r4,#0]
000020  6bc0              LDR      r0,[r0,#0x3c]
000022  f420709d          BIC      r0,r0,#0x13a
000026  6821              LDR      r1,[r4,#0]
000028  63c8              STR      r0,[r1,#0x3c]
;;;2349         SDIO_IT_TXUNDERR| SDIO_IT_RXOVERR);
;;;2350       
;;;2351       hsd->ErrorCode |= HAL_SD_ERROR_DMA;
00002a  6ba0              LDR      r0,[r4,#0x38]
00002c  f0404080          ORR      r0,r0,#0x40000000
000030  63a0              STR      r0,[r4,#0x38]
;;;2352       CardState = HAL_SD_GetCardState(hsd);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       HAL_SD_GetCardState
000038  4605              MOV      r5,r0
;;;2353       if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
00003a  2d06              CMP      r5,#6
00003c  d001              BEQ      |L28.66|
00003e  2d05              CMP      r5,#5
000040  d105              BNE      |L28.78|
                  |L28.66|
;;;2354       {
;;;2355         hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       SDMMC_CmdStopTransfer
000048  6ba1              LDR      r1,[r4,#0x38]
00004a  4308              ORRS     r0,r0,r1
00004c  63a0              STR      r0,[r4,#0x38]
                  |L28.78|
;;;2356       }
;;;2357       
;;;2358       hsd->State= HAL_SD_STATE_READY;
00004e  2001              MOVS     r0,#1
000050  f8840034          STRB     r0,[r4,#0x34]
                  |L28.84|
;;;2359     }
;;;2360   
;;;2361     HAL_SD_ErrorCallback(hsd);
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       HAL_SD_ErrorCallback
;;;2362   }
00005a  bd70              POP      {r4-r6,pc}
;;;2363   
                          ENDP


                          AREA ||i.SD_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  SD_DMAReceiveCplt PROC
;;;2303     */
;;;2304   static void SD_DMAReceiveCplt(DMA_HandleTypeDef *hdma)  
000000  b570              PUSH     {r4-r6,lr}
;;;2305   {
000002  4605              MOV      r5,r0
;;;2306     SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
000004  6bac              LDR      r4,[r5,#0x38]
;;;2307     uint32_t errorstate = HAL_SD_ERROR_NONE;
000006  2600              MOVS     r6,#0
;;;2308     
;;;2309     /* Send stop command in multiblock write */
;;;2310     if(hsd->Context == (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA))
000008  6b20              LDR      r0,[r4,#0x30]
00000a  2882              CMP      r0,#0x82
00000c  d10a              BNE      |L29.36|
;;;2311     {
;;;2312       errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       SDMMC_CmdStopTransfer
000014  4606              MOV      r6,r0
;;;2313       if(errorstate != HAL_SD_ERROR_NONE)
000016  b12e              CBZ      r6,|L29.36|
;;;2314       {
;;;2315         hsd->ErrorCode |= errorstate;
000018  6ba0              LDR      r0,[r4,#0x38]
00001a  4330              ORRS     r0,r0,r6
00001c  63a0              STR      r0,[r4,#0x38]
;;;2316         HAL_SD_ErrorCallback(hsd);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       HAL_SD_ErrorCallback
                  |L29.36|
;;;2317       }
;;;2318     }
;;;2319     
;;;2320     /* Disable the DMA transfer for transmit request by setting the DMAEN bit
;;;2321     in the SD DCTRL register */
;;;2322     hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDIO_DCTRL_DMAEN);
000024  6820              LDR      r0,[r4,#0]
000026  6ac0              LDR      r0,[r0,#0x2c]
000028  f0200008          BIC      r0,r0,#8
00002c  6821              LDR      r1,[r4,#0]
00002e  62c8              STR      r0,[r1,#0x2c]
;;;2323     
;;;2324     /* Clear all the static flags */
;;;2325     __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
000030  f24050ff          MOV      r0,#0x5ff
000034  6821              LDR      r1,[r4,#0]
000036  6388              STR      r0,[r1,#0x38]
;;;2326     
;;;2327     hsd->State = HAL_SD_STATE_READY;
000038  2001              MOVS     r0,#1
00003a  f8840034          STRB     r0,[r4,#0x34]
;;;2328   
;;;2329     HAL_SD_RxCpltCallback(hsd);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       HAL_SD_RxCpltCallback
;;;2330   }
000044  bd70              POP      {r4-r6,pc}
;;;2331   
                          ENDP


                          AREA ||i.SD_DMARxAbort||, CODE, READONLY, ALIGN=1

                  SD_DMARxAbort PROC
;;;2405     */
;;;2406   static void SD_DMARxAbort(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2407   {
000002  4606              MOV      r6,r0
;;;2408     SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
000004  6bb4              LDR      r4,[r6,#0x38]
;;;2409     HAL_SD_CardStateTypeDef CardState;
;;;2410     
;;;2411     if(hsd->hdmarx != NULL)
000006  6be0              LDR      r0,[r4,#0x3c]
000008  b108              CBZ      r0,|L30.14|
;;;2412     {
;;;2413       hsd->hdmarx = NULL;
00000a  2000              MOVS     r0,#0
00000c  63e0              STR      r0,[r4,#0x3c]
                  |L30.14|
;;;2414     }
;;;2415     
;;;2416     /* All DMA channels are aborted */
;;;2417     if(hsd->hdmatx == NULL)
00000e  6c20              LDR      r0,[r4,#0x40]
000010  b9d8              CBNZ     r0,|L30.74|
;;;2418     {
;;;2419       CardState = HAL_SD_GetCardState(hsd);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       HAL_SD_GetCardState
000018  4605              MOV      r5,r0
;;;2420       hsd->ErrorCode = HAL_SD_ERROR_NONE;
00001a  2000              MOVS     r0,#0
00001c  63a0              STR      r0,[r4,#0x38]
;;;2421       hsd->State = HAL_SD_STATE_READY;
00001e  2001              MOVS     r0,#1
000020  f8840034          STRB     r0,[r4,#0x34]
;;;2422       if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
000024  2d06              CMP      r5,#6
000026  d001              BEQ      |L30.44|
000028  2d05              CMP      r5,#5
00002a  d10e              BNE      |L30.74|
                  |L30.44|
;;;2423       {
;;;2424         hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       SDMMC_CmdStopTransfer
000032  6ba1              LDR      r1,[r4,#0x38]
000034  4308              ORRS     r0,r0,r1
000036  63a0              STR      r0,[r4,#0x38]
;;;2425         
;;;2426         if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
000038  6ba0              LDR      r0,[r4,#0x38]
00003a  b118              CBZ      r0,|L30.68|
;;;2427         {
;;;2428           HAL_SD_AbortCallback(hsd);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       HAL_SD_AbortCallback
000042  e002              B        |L30.74|
                  |L30.68|
;;;2429         }
;;;2430         else
;;;2431         {
;;;2432           HAL_SD_ErrorCallback(hsd);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_SD_ErrorCallback
                  |L30.74|
;;;2433         }
;;;2434       }
;;;2435     }
;;;2436   }
00004a  bd70              POP      {r4-r6,pc}
;;;2437   
                          ENDP


                          AREA ||i.SD_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  SD_DMATransmitCplt PROC
;;;2290     */
;;;2291   static void SD_DMATransmitCplt(DMA_HandleTypeDef *hdma)     
000000  4601              MOV      r1,r0
;;;2292   {
;;;2293     SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
000002  6b88              LDR      r0,[r1,#0x38]
;;;2294     
;;;2295     /* Enable DATAEND Interrupt */
;;;2296     __HAL_SD_ENABLE_IT(hsd, (SDIO_IT_DATAEND));
000004  6802              LDR      r2,[r0,#0]
000006  6bd2              LDR      r2,[r2,#0x3c]
000008  f4427280          ORR      r2,r2,#0x100
00000c  6803              LDR      r3,[r0,#0]
00000e  63da              STR      r2,[r3,#0x3c]
;;;2297   }
000010  4770              BX       lr
;;;2298   
                          ENDP


                          AREA ||i.SD_DMATxAbort||, CODE, READONLY, ALIGN=1

                  SD_DMATxAbort PROC
;;;2368     */
;;;2369   static void SD_DMATxAbort(DMA_HandleTypeDef *hdma)   
000000  b570              PUSH     {r4-r6,lr}
;;;2370   {
000002  4606              MOV      r6,r0
;;;2371     SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
000004  6bb4              LDR      r4,[r6,#0x38]
;;;2372     HAL_SD_CardStateTypeDef CardState;
;;;2373     
;;;2374     if(hsd->hdmatx != NULL)
000006  6c20              LDR      r0,[r4,#0x40]
000008  b108              CBZ      r0,|L32.14|
;;;2375     {
;;;2376       hsd->hdmatx = NULL;
00000a  2000              MOVS     r0,#0
00000c  6420              STR      r0,[r4,#0x40]
                  |L32.14|
;;;2377     }
;;;2378     
;;;2379     /* All DMA channels are aborted */
;;;2380     if(hsd->hdmarx == NULL)
00000e  6be0              LDR      r0,[r4,#0x3c]
000010  b9d8              CBNZ     r0,|L32.74|
;;;2381     {
;;;2382       CardState = HAL_SD_GetCardState(hsd);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       HAL_SD_GetCardState
000018  4605              MOV      r5,r0
;;;2383       hsd->ErrorCode = HAL_SD_ERROR_NONE;
00001a  2000              MOVS     r0,#0
00001c  63a0              STR      r0,[r4,#0x38]
;;;2384       hsd->State = HAL_SD_STATE_READY;
00001e  2001              MOVS     r0,#1
000020  f8840034          STRB     r0,[r4,#0x34]
;;;2385       if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
000024  2d06              CMP      r5,#6
000026  d001              BEQ      |L32.44|
000028  2d05              CMP      r5,#5
00002a  d10e              BNE      |L32.74|
                  |L32.44|
;;;2386       {
;;;2387         hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       SDMMC_CmdStopTransfer
000032  6ba1              LDR      r1,[r4,#0x38]
000034  4308              ORRS     r0,r0,r1
000036  63a0              STR      r0,[r4,#0x38]
;;;2388         
;;;2389         if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
000038  6ba0              LDR      r0,[r4,#0x38]
00003a  b118              CBZ      r0,|L32.68|
;;;2390         {
;;;2391           HAL_SD_AbortCallback(hsd);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       HAL_SD_AbortCallback
000042  e002              B        |L32.74|
                  |L32.68|
;;;2392         }
;;;2393         else
;;;2394         {
;;;2395           HAL_SD_ErrorCallback(hsd);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_SD_ErrorCallback
                  |L32.74|
;;;2396         }
;;;2397       }
;;;2398     }
;;;2399   }
00004a  bd70              POP      {r4-r6,pc}
;;;2400   
                          ENDP


                          AREA ||i.SD_FindSCR||, CODE, READONLY, ALIGN=1

                  SD_FindSCR PROC
;;;2873     */
;;;2874   static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2875   {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
;;;2876     SDIO_DataInitTypeDef config;
;;;2877     uint32_t errorstate = HAL_SD_ERROR_NONE;
00000a  2500              MOVS     r5,#0
;;;2878     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
;;;2879     uint32_t index = 0U;
000012  2700              MOVS     r7,#0
;;;2880     uint32_t tempscr[2U] = {0U, 0U};
000014  2000              MOVS     r0,#0
000016  9000              STR      r0,[sp,#0]
000018  9001              STR      r0,[sp,#4]
;;;2881     
;;;2882     /* Set Block Size To 8 Bytes */
;;;2883     errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
00001a  2108              MOVS     r1,#8
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       SDMMC_CmdBlockLength
000022  4605              MOV      r5,r0
;;;2884     if(errorstate != HAL_OK)
000024  b11d              CBZ      r5,|L33.46|
;;;2885     {
;;;2886       return errorstate;
000026  4628              MOV      r0,r5
                  |L33.40|
;;;2887     }
;;;2888   
;;;2889     /* Send CMD55 APP_CMD with argument as card's RCA */
;;;2890     errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
;;;2891     if(errorstate != HAL_OK)
;;;2892     {
;;;2893       return errorstate;
;;;2894     }
;;;2895   
;;;2896     config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;2897     config.DataLength    = 8U;
;;;2898     config.DataBlockSize = SDIO_DATABLOCK_SIZE_8B;
;;;2899     config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;2900     config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;2901     config.DPSM          = SDIO_DPSM_ENABLE;
;;;2902     SDIO_ConfigData(hsd->Instance, &config);
;;;2903     
;;;2904     /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
;;;2905     errorstate = SDMMC_CmdSendSCR(hsd->Instance);
;;;2906     if(errorstate != HAL_OK)
;;;2907     {
;;;2908       return errorstate;
;;;2909     }
;;;2910     
;;;2911     while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
;;;2912     {
;;;2913       if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXDAVL))
;;;2914       {
;;;2915         *(tempscr + index) = SDIO_ReadFIFO(hsd->Instance);
;;;2916         index++;
;;;2917       }
;;;2918       
;;;2919       if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
;;;2920       {
;;;2921         return HAL_SD_ERROR_TIMEOUT;
;;;2922       }
;;;2923     }
;;;2924     
;;;2925     if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;2926     {
;;;2927       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DTIMEOUT);
;;;2928       
;;;2929       return HAL_SD_ERROR_DATA_TIMEOUT;
;;;2930     }
;;;2931     else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;2932     {
;;;2933       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_DCRCFAIL);
;;;2934       
;;;2935       return HAL_SD_ERROR_DATA_CRC_FAIL;
;;;2936     }
;;;2937     else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
;;;2938     {
;;;2939       __HAL_SD_CLEAR_FLAG(hsd, SDIO_FLAG_RXOVERR);
;;;2940       
;;;2941       return HAL_SD_ERROR_RX_OVERRUN;
;;;2942     }
;;;2943     else
;;;2944     {
;;;2945       /* No error flag set */
;;;2946       /* Clear all the static flags */
;;;2947       __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;2948       
;;;2949       *(pSCR + 1U) = ((tempscr[0U] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[0U] & SDMMC_8TO15BITS) << 8U) |\
;;;2950         ((tempscr[0U] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[0U] & SDMMC_24TO31BITS) >> 24U);
;;;2951       
;;;2952       *(pSCR) = ((tempscr[1U] & SDMMC_0TO7BITS) << 24U)  | ((tempscr[1U] & SDMMC_8TO15BITS) << 8U) |\
;;;2953         ((tempscr[1U] & SDMMC_16TO23BITS) >> 8U) | ((tempscr[1U] & SDMMC_24TO31BITS) >> 24U);
;;;2954     }
;;;2955   
;;;2956     return HAL_SD_ERROR_NONE;
;;;2957   }
000028  b008              ADD      sp,sp,#0x20
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L33.46|
00002e  2250              MOVS     r2,#0x50              ;2890
000030  5b12              LDRH     r2,[r2,r4]            ;2890
000032  0411              LSLS     r1,r2,#16             ;2890
000034  6820              LDR      r0,[r4,#0]            ;2890
000036  f7fffffe          BL       SDMMC_CmdAppCommand
00003a  4605              MOV      r5,r0                 ;2890
00003c  b10d              CBZ      r5,|L33.66|
00003e  4628              MOV      r0,r5                 ;2893
000040  e7f2              B        |L33.40|
                  |L33.66|
000042  f04f30ff          MOV      r0,#0xffffffff        ;2896
000046  9002              STR      r0,[sp,#8]            ;2896
000048  2008              MOVS     r0,#8                 ;2897
00004a  9003              STR      r0,[sp,#0xc]          ;2897
00004c  2030              MOVS     r0,#0x30              ;2898
00004e  9004              STR      r0,[sp,#0x10]         ;2898
000050  2002              MOVS     r0,#2                 ;2899
000052  9005              STR      r0,[sp,#0x14]         ;2899
000054  2000              MOVS     r0,#0                 ;2900
000056  9006              STR      r0,[sp,#0x18]         ;2900
000058  2001              MOVS     r0,#1                 ;2901
00005a  9007              STR      r0,[sp,#0x1c]         ;2901
00005c  a902              ADD      r1,sp,#8              ;2902
00005e  6820              LDR      r0,[r4,#0]            ;2902
000060  f7fffffe          BL       SDIO_ConfigData
000064  6820              LDR      r0,[r4,#0]            ;2905
000066  f7fffffe          BL       SDMMC_CmdSendSCR
00006a  4605              MOV      r5,r0                 ;2905
00006c  b10d              CBZ      r5,|L33.114|
00006e  4628              MOV      r0,r5                 ;2908
000070  e7da              B        |L33.40|
                  |L33.114|
000072  e013              B        |L33.156|
                  |L33.116|
000074  6820              LDR      r0,[r4,#0]            ;2913
000076  6b40              LDR      r0,[r0,#0x34]         ;2913
000078  f4001000          AND      r0,r0,#0x200000       ;2913
00007c  b128              CBZ      r0,|L33.138|
00007e  6820              LDR      r0,[r4,#0]            ;2915
000080  f7fffffe          BL       SDIO_ReadFIFO
000084  f84d0027          STR      r0,[sp,r7,LSL #2]     ;2915
000088  1c7f              ADDS     r7,r7,#1              ;2916
                  |L33.138|
00008a  f7fffffe          BL       HAL_GetTick
00008e  eba00008          SUB      r0,r0,r8              ;2919
000092  1c40              ADDS     r0,r0,#1              ;2919
000094  b910              CBNZ     r0,|L33.156|
000096  f04f4000          MOV      r0,#0x80000000        ;2921
00009a  e7c5              B        |L33.40|
                  |L33.156|
00009c  6820              LDR      r0,[r4,#0]            ;2911
00009e  6b40              LDR      r0,[r0,#0x34]         ;2911
0000a0  f240412a          MOV      r1,#0x42a             ;2911
0000a4  4008              ANDS     r0,r0,r1              ;2911
0000a6  2800              CMP      r0,#0                 ;2911
0000a8  d0e4              BEQ      |L33.116|
0000aa  6820              LDR      r0,[r4,#0]            ;2925
0000ac  6b40              LDR      r0,[r0,#0x34]         ;2925
0000ae  f0000008          AND      r0,r0,#8              ;2925
0000b2  b118              CBZ      r0,|L33.188|
0000b4  2008              MOVS     r0,#8                 ;2927
0000b6  6821              LDR      r1,[r4,#0]            ;2927
0000b8  6388              STR      r0,[r1,#0x38]         ;2927
0000ba  e7b5              B        |L33.40|
                  |L33.188|
0000bc  6820              LDR      r0,[r4,#0]            ;2931
0000be  6b40              LDR      r0,[r0,#0x34]         ;2931
0000c0  f0000002          AND      r0,r0,#2              ;2931
0000c4  b118              CBZ      r0,|L33.206|
0000c6  2002              MOVS     r0,#2                 ;2933
0000c8  6821              LDR      r1,[r4,#0]            ;2933
0000ca  6388              STR      r0,[r1,#0x38]         ;2933
0000cc  e7ac              B        |L33.40|
                  |L33.206|
0000ce  6820              LDR      r0,[r4,#0]            ;2937
0000d0  6b40              LDR      r0,[r0,#0x34]         ;2937
0000d2  f0000020          AND      r0,r0,#0x20           ;2937
0000d6  b118              CBZ      r0,|L33.224|
0000d8  2020              MOVS     r0,#0x20              ;2939
0000da  6821              LDR      r1,[r4,#0]            ;2939
0000dc  6388              STR      r0,[r1,#0x38]         ;2939
0000de  e7a3              B        |L33.40|
                  |L33.224|
0000e0  f24050ff          MOV      r0,#0x5ff             ;2947
0000e4  6821              LDR      r1,[r4,#0]            ;2947
0000e6  6388              STR      r0,[r1,#0x38]         ;2947
0000e8  9800              LDR      r0,[sp,#0]            ;2949
0000ea  0600              LSLS     r0,r0,#24             ;2949
0000ec  9900              LDR      r1,[sp,#0]            ;2949
0000ee  f401417f          AND      r1,r1,#0xff00         ;2949
0000f2  ea402001          ORR      r0,r0,r1,LSL #8       ;2949
0000f6  9900              LDR      r1,[sp,#0]            ;2949
0000f8  f401017f          AND      r1,r1,#0xff0000       ;2949
0000fc  ea402011          ORR      r0,r0,r1,LSR #8       ;2949
000100  9900              LDR      r1,[sp,#0]            ;2949
000102  ea406011          ORR      r0,r0,r1,LSR #24      ;2949
000106  6070              STR      r0,[r6,#4]            ;2949
000108  9801              LDR      r0,[sp,#4]            ;2952
00010a  0600              LSLS     r0,r0,#24             ;2952
00010c  9901              LDR      r1,[sp,#4]            ;2952
00010e  f401417f          AND      r1,r1,#0xff00         ;2952
000112  ea402001          ORR      r0,r0,r1,LSL #8       ;2952
000116  9901              LDR      r1,[sp,#4]            ;2952
000118  f401017f          AND      r1,r1,#0xff0000       ;2952
00011c  ea402011          ORR      r0,r0,r1,LSR #8       ;2952
000120  9901              LDR      r1,[sp,#4]            ;2952
000122  ea406011          ORR      r0,r0,r1,LSR #24      ;2952
000126  6030              STR      r0,[r6,#0]            ;2952
000128  2000              MOVS     r0,#0                 ;2956
00012a  e77d              B        |L33.40|
;;;2958   
                          ENDP


                          AREA ||i.SD_InitCard||, CODE, READONLY, ALIGN=1

                  SD_InitCard PROC
;;;2443     */
;;;2444   static uint32_t SD_InitCard(SD_HandleTypeDef *hsd)
000000  b530              PUSH     {r4,r5,lr}
;;;2445   {
000002  b08f              SUB      sp,sp,#0x3c
000004  4604              MOV      r4,r0
;;;2446     HAL_SD_CardCSDTypeDef CSD;
;;;2447     uint32_t errorstate = HAL_SD_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;2448     uint16_t sd_rca = 1U;
000008  2001              MOVS     r0,#1
00000a  9003              STR      r0,[sp,#0xc]
;;;2449     
;;;2450     /* Check the power State */
;;;2451     if(SDIO_GetPowerState(hsd->Instance) == 0U) 
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       SDIO_GetPowerState
000012  b918              CBNZ     r0,|L34.28|
;;;2452     {
;;;2453       /* Power off */
;;;2454       return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
000014  f04f6080          MOV      r0,#0x4000000
                  |L34.24|
;;;2455     }
;;;2456     
;;;2457     if(hsd->SdCard.CardType != CARD_SECURED) 
;;;2458     {
;;;2459       /* Send CMD2 ALL_SEND_CID */
;;;2460       errorstate = SDMMC_CmdSendCID(hsd->Instance);
;;;2461       if(errorstate != HAL_SD_ERROR_NONE)
;;;2462       {
;;;2463         return errorstate;
;;;2464       }
;;;2465       else
;;;2466       {
;;;2467         /* Get Card identification number data */
;;;2468         hsd->CID[0U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
;;;2469         hsd->CID[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
;;;2470         hsd->CID[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
;;;2471         hsd->CID[3U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
;;;2472       }
;;;2473     }
;;;2474     
;;;2475     if(hsd->SdCard.CardType != CARD_SECURED) 
;;;2476     {
;;;2477       /* Send CMD3 SET_REL_ADDR with argument 0 */
;;;2478       /* SD Card publishes its RCA. */
;;;2479       errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
;;;2480       if(errorstate != HAL_SD_ERROR_NONE)
;;;2481       {
;;;2482         return errorstate;
;;;2483       }
;;;2484     }
;;;2485     if(hsd->SdCard.CardType != CARD_SECURED) 
;;;2486     {
;;;2487       /* Get the SD card RCA */
;;;2488       hsd->SdCard.RelCardAdd = sd_rca;
;;;2489       
;;;2490       /* Send CMD9 SEND_CSD with argument as card's RCA */
;;;2491       errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
;;;2492       if(errorstate != HAL_SD_ERROR_NONE)
;;;2493       {
;;;2494         return errorstate;
;;;2495       }
;;;2496       else
;;;2497       {
;;;2498         /* Get Card Specific Data */
;;;2499         hsd->CSD[0U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
;;;2500         hsd->CSD[1U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP2);
;;;2501         hsd->CSD[2U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP3);
;;;2502         hsd->CSD[3U] = SDIO_GetResponse(hsd->Instance, SDIO_RESP4);
;;;2503       }
;;;2504     }
;;;2505     
;;;2506     /* Get the Card Class */
;;;2507     hsd->SdCard.Class = (SDIO_GetResponse(hsd->Instance, SDIO_RESP2) >> 20U);
;;;2508     
;;;2509     /* Get CSD parameters */
;;;2510     HAL_SD_GetCardCSD(hsd, &CSD);
;;;2511   
;;;2512     /* Select the Card */
;;;2513     errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
;;;2514     if(errorstate != HAL_SD_ERROR_NONE)
;;;2515     {
;;;2516       return errorstate;
;;;2517     }
;;;2518   
;;;2519     /* Configure SDIO peripheral interface */     
;;;2520     SDIO_Init(hsd->Instance, hsd->Init);
;;;2521   
;;;2522     /* All cards are initialized */
;;;2523     return HAL_SD_ERROR_NONE;
;;;2524   }
000018  b00f              ADD      sp,sp,#0x3c
00001a  bd30              POP      {r4,r5,pc}
                  |L34.28|
00001c  6c60              LDR      r0,[r4,#0x44]         ;2457
00001e  2803              CMP      r0,#3                 ;2457
000020  d01b              BEQ      |L34.90|
000022  6820              LDR      r0,[r4,#0]            ;2460
000024  f7fffffe          BL       SDMMC_CmdSendCID
000028  4605              MOV      r5,r0                 ;2460
00002a  b10d              CBZ      r5,|L34.48|
00002c  4628              MOV      r0,r5                 ;2463
00002e  e7f3              B        |L34.24|
                  |L34.48|
000030  2100              MOVS     r1,#0                 ;2468
000032  6820              LDR      r0,[r4,#0]            ;2468
000034  f7fffffe          BL       SDIO_GetResponse
000038  6760              STR      r0,[r4,#0x74]         ;2468
00003a  2104              MOVS     r1,#4                 ;2469
00003c  6820              LDR      r0,[r4,#0]            ;2469
00003e  f7fffffe          BL       SDIO_GetResponse
000042  67a0              STR      r0,[r4,#0x78]         ;2469
000044  2108              MOVS     r1,#8                 ;2470
000046  6820              LDR      r0,[r4,#0]            ;2470
000048  f7fffffe          BL       SDIO_GetResponse
00004c  67e0              STR      r0,[r4,#0x7c]         ;2470
00004e  210c              MOVS     r1,#0xc               ;2471
000050  6820              LDR      r0,[r4,#0]            ;2471
000052  f7fffffe          BL       SDIO_GetResponse
000056  2180              MOVS     r1,#0x80              ;2471
000058  5108              STR      r0,[r1,r4]            ;2471
                  |L34.90|
00005a  6c60              LDR      r0,[r4,#0x44]         ;2475
00005c  2803              CMP      r0,#3                 ;2475
00005e  d007              BEQ      |L34.112|
000060  a903              ADD      r1,sp,#0xc            ;2479
000062  6820              LDR      r0,[r4,#0]            ;2479
000064  f7fffffe          BL       SDMMC_CmdSetRelAdd
000068  4605              MOV      r5,r0                 ;2479
00006a  b10d              CBZ      r5,|L34.112|
00006c  4628              MOV      r0,r5                 ;2482
00006e  e7d3              B        |L34.24|
                  |L34.112|
000070  6c60              LDR      r0,[r4,#0x44]         ;2485
000072  2803              CMP      r0,#3                 ;2485
000074  d020              BEQ      |L34.184|
000076  f8bd100c          LDRH     r1,[sp,#0xc]          ;2488
00007a  6521              STR      r1,[r4,#0x50]         ;2488
00007c  2250              MOVS     r2,#0x50              ;2491
00007e  5b12              LDRH     r2,[r2,r4]            ;2491
000080  0411              LSLS     r1,r2,#16             ;2491
000082  6820              LDR      r0,[r4,#0]            ;2491
000084  f7fffffe          BL       SDMMC_CmdSendCSD
000088  4605              MOV      r5,r0                 ;2491
00008a  b10d              CBZ      r5,|L34.144|
00008c  4628              MOV      r0,r5                 ;2494
00008e  e7c3              B        |L34.24|
                  |L34.144|
000090  2100              MOVS     r1,#0                 ;2499
000092  6820              LDR      r0,[r4,#0]            ;2499
000094  f7fffffe          BL       SDIO_GetResponse
000098  6660              STR      r0,[r4,#0x64]         ;2499
00009a  2104              MOVS     r1,#4                 ;2500
00009c  6820              LDR      r0,[r4,#0]            ;2500
00009e  f7fffffe          BL       SDIO_GetResponse
0000a2  66a0              STR      r0,[r4,#0x68]         ;2500
0000a4  2108              MOVS     r1,#8                 ;2501
0000a6  6820              LDR      r0,[r4,#0]            ;2501
0000a8  f7fffffe          BL       SDIO_GetResponse
0000ac  66e0              STR      r0,[r4,#0x6c]         ;2501
0000ae  210c              MOVS     r1,#0xc               ;2502
0000b0  6820              LDR      r0,[r4,#0]            ;2502
0000b2  f7fffffe          BL       SDIO_GetResponse
0000b6  6720              STR      r0,[r4,#0x70]         ;2502
                  |L34.184|
0000b8  2104              MOVS     r1,#4                 ;2507
0000ba  6820              LDR      r0,[r4,#0]            ;2507
0000bc  f7fffffe          BL       SDIO_GetResponse
0000c0  0d01              LSRS     r1,r0,#20             ;2507
0000c2  64e1              STR      r1,[r4,#0x4c]         ;2507
0000c4  a904              ADD      r1,sp,#0x10           ;2510
0000c6  4620              MOV      r0,r4                 ;2510
0000c8  f7fffffe          BL       HAL_SD_GetCardCSD
0000cc  2050              MOVS     r0,#0x50              ;2513
0000ce  5b00              LDRH     r0,[r0,r4]            ;2513
0000d0  0401              LSLS     r1,r0,#16             ;2513
0000d2  460a              MOV      r2,r1                 ;2513
0000d4  2300              MOVS     r3,#0                 ;2513
0000d6  6820              LDR      r0,[r4,#0]            ;2513
0000d8  f7fffffe          BL       SDMMC_CmdSelDesel
0000dc  4605              MOV      r5,r0                 ;2513
0000de  b10d              CBZ      r5,|L34.228|
0000e0  4628              MOV      r0,r5                 ;2516
0000e2  e799              B        |L34.24|
                  |L34.228|
0000e4  e9d41204          LDRD     r1,r2,[r4,#0x10]      ;2520
0000e8  69a0              LDR      r0,[r4,#0x18]         ;2520
0000ea  e9cd1200          STRD     r1,r2,[sp,#0]         ;2520
0000ee  9002              STR      r0,[sp,#8]            ;2520
0000f0  e894000f          LDM      r4,{r0-r3}            ;2520
0000f4  f7fffffe          BL       SDIO_Init
0000f8  2000              MOVS     r0,#0                 ;2523
0000fa  e78d              B        |L34.24|
;;;2525   
                          ENDP


                          AREA ||i.SD_PowerOFF||, CODE, READONLY, ALIGN=1

                  SD_PowerOFF PROC
;;;2633     */
;;;2634   static HAL_StatusTypeDef SD_PowerOFF(SD_HandleTypeDef *hsd)
000000  b510              PUSH     {r4,lr}
;;;2635   {
000002  4604              MOV      r4,r0
;;;2636     /* Set Power State to OFF */
;;;2637     SDIO_PowerState_OFF(hsd->Instance);
000004  6820              LDR      r0,[r4,#0]
000006  f7fffffe          BL       SDIO_PowerState_OFF
;;;2638     
;;;2639     return HAL_OK;
00000a  2000              MOVS     r0,#0
;;;2640   }
00000c  bd10              POP      {r4,pc}
;;;2641   
                          ENDP


                          AREA ||i.SD_PowerON||, CODE, READONLY, ALIGN=1

                  SD_PowerON PROC
;;;2532     */
;;;2533   static uint32_t SD_PowerON(SD_HandleTypeDef *hsd)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2534   {
000002  4604              MOV      r4,r0
;;;2535     __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;2536     uint32_t response = 0U, validvoltage = 0U;
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;2537     uint32_t errorstate = HAL_SD_ERROR_NONE;
00000c  2500              MOVS     r5,#0
;;;2538     
;;;2539     /* CMD0: GO_IDLE_STATE */
;;;2540     errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       SDMMC_CmdGoIdleState
000014  4605              MOV      r5,r0
;;;2541     if(errorstate != HAL_SD_ERROR_NONE)
000016  b10d              CBZ      r5,|L36.28|
;;;2542     {
;;;2543       return errorstate;
000018  4628              MOV      r0,r5
                  |L36.26|
;;;2544     }
;;;2545     
;;;2546     /* CMD8: SEND_IF_COND: Command available only on V2.0 cards */
;;;2547     errorstate = SDMMC_CmdOperCond(hsd->Instance);
;;;2548     if(errorstate != HAL_SD_ERROR_NONE)
;;;2549     {
;;;2550       hsd->SdCard.CardVersion = CARD_V1_X;
;;;2551         
;;;2552       /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
;;;2553       while(validvoltage == 0U)
;;;2554       {
;;;2555         if(count++ == SDMMC_MAX_VOLT_TRIAL)
;;;2556         {
;;;2557           return HAL_SD_ERROR_INVALID_VOLTRANGE;
;;;2558         }
;;;2559         
;;;2560         /* SEND CMD55 APP_CMD with RCA as 0 */
;;;2561         errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0U);
;;;2562         if(errorstate != HAL_SD_ERROR_NONE)
;;;2563         {
;;;2564           return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
;;;2565         }
;;;2566         
;;;2567         /* Send CMD41 */
;;;2568         errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_STD_CAPACITY);
;;;2569         if(errorstate != HAL_SD_ERROR_NONE)
;;;2570         {
;;;2571           return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
;;;2572         }
;;;2573         
;;;2574         /* Get command response */
;;;2575         response = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
;;;2576         
;;;2577         /* Get operating voltage*/
;;;2578         validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
;;;2579       }
;;;2580       /* Card type is SDSC */
;;;2581       hsd->SdCard.CardType = CARD_SDSC;
;;;2582     }
;;;2583     else
;;;2584     {
;;;2585       hsd->SdCard.CardVersion = CARD_V2_X;
;;;2586           
;;;2587       /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
;;;2588       while(validvoltage == 0U)
;;;2589       {
;;;2590         if(count++ == SDMMC_MAX_VOLT_TRIAL)
;;;2591         {
;;;2592           return HAL_SD_ERROR_INVALID_VOLTRANGE;
;;;2593         }
;;;2594         
;;;2595         /* SEND CMD55 APP_CMD with RCA as 0 */
;;;2596         errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0U);
;;;2597         if(errorstate != HAL_SD_ERROR_NONE)
;;;2598         {
;;;2599           return errorstate;
;;;2600         }
;;;2601         
;;;2602         /* Send CMD41 */
;;;2603         errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_HIGH_CAPACITY);
;;;2604         if(errorstate != HAL_SD_ERROR_NONE)
;;;2605         {
;;;2606           return errorstate;
;;;2607         }
;;;2608         
;;;2609         /* Get command response */
;;;2610         response = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
;;;2611         
;;;2612         /* Get operating voltage*/
;;;2613         validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
;;;2614       }
;;;2615       
;;;2616       if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
;;;2617       {
;;;2618         hsd->SdCard.CardType = CARD_SDHC_SDXC;
;;;2619       }
;;;2620       else
;;;2621       {
;;;2622         hsd->SdCard.CardType = CARD_SDSC;
;;;2623       }
;;;2624     }
;;;2625     
;;;2626     return HAL_SD_ERROR_NONE;
;;;2627   }
00001a  bdf8              POP      {r3-r7,pc}
                  |L36.28|
00001c  6820              LDR      r0,[r4,#0]            ;2547
00001e  f7fffffe          BL       SDMMC_CmdOperCond
000022  4605              MOV      r5,r0                 ;2547
000024  b36d              CBZ      r5,|L36.130|
000026  2100              MOVS     r1,#0                 ;2550
000028  64a1              STR      r1,[r4,#0x48]         ;2550
00002a  e025              B        |L36.120|
                  |L36.44|
00002c  9800              LDR      r0,[sp,#0]            ;2555
00002e  1c41              ADDS     r1,r0,#1              ;2555
000030  9100              STR      r1,[sp,#0]            ;2555
000032  f64f71ff          MOV      r1,#0xffff            ;2555
000036  4288              CMP      r0,r1                 ;2555
000038  d102              BNE      |L36.64|
00003a  f04f7080          MOV      r0,#0x1000000         ;2557
00003e  e7ec              B        |L36.26|
                  |L36.64|
000040  2100              MOVS     r1,#0                 ;2561
000042  6820              LDR      r0,[r4,#0]            ;2561
000044  f7fffffe          BL       SDMMC_CmdAppCommand
000048  4605              MOV      r5,r0                 ;2561
00004a  b115              CBZ      r5,|L36.82|
00004c  f04f5080          MOV      r0,#0x10000000        ;2564
000050  e7e3              B        |L36.26|
                  |L36.82|
000052  2100              MOVS     r1,#0                 ;2568
000054  6820              LDR      r0,[r4,#0]            ;2568
000056  f7fffffe          BL       SDMMC_CmdAppOperCommand
00005a  4605              MOV      r5,r0                 ;2568
00005c  b115              CBZ      r5,|L36.100|
00005e  f04f5080          MOV      r0,#0x10000000        ;2571
000062  e7da              B        |L36.26|
                  |L36.100|
000064  2100              MOVS     r1,#0                 ;2575
000066  6820              LDR      r0,[r4,#0]            ;2575
000068  f7fffffe          BL       SDIO_GetResponse
00006c  4606              MOV      r6,r0                 ;2575
00006e  2001              MOVS     r0,#1                 ;2578
000070  ea8070d6          EOR      r0,r0,r6,LSR #31      ;2578
000074  f0800701          EOR      r7,r0,#1              ;2578
                  |L36.120|
000078  2f00              CMP      r7,#0                 ;2553
00007a  d0d7              BEQ      |L36.44|
00007c  2000              MOVS     r0,#0                 ;2581
00007e  6460              STR      r0,[r4,#0x44]         ;2581
000080  e033              B        |L36.234|
                  |L36.130|
000082  2101              MOVS     r1,#1                 ;2585
000084  64a1              STR      r1,[r4,#0x48]         ;2585
000086  e024              B        |L36.210|
                  |L36.136|
000088  9800              LDR      r0,[sp,#0]            ;2590
00008a  1c41              ADDS     r1,r0,#1              ;2590
00008c  9100              STR      r1,[sp,#0]            ;2590
00008e  f64f71ff          MOV      r1,#0xffff            ;2590
000092  4288              CMP      r0,r1                 ;2590
000094  d102              BNE      |L36.156|
000096  f04f7080          MOV      r0,#0x1000000         ;2592
00009a  e7be              B        |L36.26|
                  |L36.156|
00009c  2100              MOVS     r1,#0                 ;2596
00009e  6820              LDR      r0,[r4,#0]            ;2596
0000a0  f7fffffe          BL       SDMMC_CmdAppCommand
0000a4  4605              MOV      r5,r0                 ;2596
0000a6  b10d              CBZ      r5,|L36.172|
0000a8  4628              MOV      r0,r5                 ;2599
0000aa  e7b6              B        |L36.26|
                  |L36.172|
0000ac  f04f4180          MOV      r1,#0x40000000        ;2603
0000b0  6820              LDR      r0,[r4,#0]            ;2603
0000b2  f7fffffe          BL       SDMMC_CmdAppOperCommand
0000b6  4605              MOV      r5,r0                 ;2603
0000b8  b10d              CBZ      r5,|L36.190|
0000ba  4628              MOV      r0,r5                 ;2606
0000bc  e7ad              B        |L36.26|
                  |L36.190|
0000be  2100              MOVS     r1,#0                 ;2610
0000c0  6820              LDR      r0,[r4,#0]            ;2610
0000c2  f7fffffe          BL       SDIO_GetResponse
0000c6  4606              MOV      r6,r0                 ;2610
0000c8  2001              MOVS     r0,#1                 ;2613
0000ca  ea8070d6          EOR      r0,r0,r6,LSR #31      ;2613
0000ce  f0800701          EOR      r7,r0,#1              ;2613
                  |L36.210|
0000d2  2f00              CMP      r7,#0                 ;2588
0000d4  d0d8              BEQ      |L36.136|
0000d6  f0064080          AND      r0,r6,#0x40000000     ;2616
0000da  f1b04f80          CMP      r0,#0x40000000        ;2616
0000de  d102              BNE      |L36.230|
0000e0  2001              MOVS     r0,#1                 ;2618
0000e2  6460              STR      r0,[r4,#0x44]         ;2618
0000e4  e001              B        |L36.234|
                  |L36.230|
0000e6  2000              MOVS     r0,#0                 ;2622
0000e8  6460              STR      r0,[r4,#0x44]         ;2622
                  |L36.234|
0000ea  2000              MOVS     r0,#0                 ;2626
0000ec  e795              B        |L36.26|
;;;2628   
                          ENDP


                          AREA ||i.SD_Read_IT||, CODE, READONLY, ALIGN=1

                  SD_Read_IT PROC
;;;2964     */
;;;2965   static HAL_StatusTypeDef SD_Read_IT(SD_HandleTypeDef *hsd)
000000  b570              PUSH     {r4-r6,lr}
;;;2966   {
000002  4604              MOV      r4,r0
;;;2967     uint32_t count = 0U;
000004  2500              MOVS     r5,#0
;;;2968     uint32_t* tmp;
;;;2969   
;;;2970     tmp = (uint32_t*)hsd->pRxBuffPtr;
000006  6aa6              LDR      r6,[r4,#0x28]
;;;2971     
;;;2972     /* Read data from SDIO Rx FIFO */
;;;2973     for(count = 0U; count < 8U; count++)
000008  bf00              NOP      
00000a  e005              B        |L37.24|
                  |L37.12|
;;;2974     {
;;;2975       *(tmp + count) = SDIO_ReadFIFO(hsd->Instance);
00000c  6820              LDR      r0,[r4,#0]
00000e  f7fffffe          BL       SDIO_ReadFIFO
000012  f8460025          STR      r0,[r6,r5,LSL #2]
000016  1c6d              ADDS     r5,r5,#1              ;2973
                  |L37.24|
000018  2d08              CMP      r5,#8                 ;2973
00001a  d3f7              BCC      |L37.12|
;;;2976     }
;;;2977     
;;;2978     hsd->pRxBuffPtr += 8U;
00001c  6aa0              LDR      r0,[r4,#0x28]
00001e  3020              ADDS     r0,r0,#0x20
000020  62a0              STR      r0,[r4,#0x28]
;;;2979     
;;;2980     return HAL_OK;
000022  2000              MOVS     r0,#0
;;;2981   }
000024  bd70              POP      {r4-r6,pc}
;;;2982   
                          ENDP


                          AREA ||i.SD_SendSDStatus||, CODE, READONLY, ALIGN=1

                  SD_SendSDStatus PROC
;;;2648     */
;;;2649   static uint32_t SD_SendSDStatus(SD_HandleTypeDef *hsd, uint32_t *pSDstatus)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2650   {
000004  b086              SUB      sp,sp,#0x18
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;2651     SDIO_DataInitTypeDef config;
;;;2652     uint32_t errorstate = HAL_SD_ERROR_NONE;
00000a  2600              MOVS     r6,#0
;;;2653     uint32_t tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
000010  4680              MOV      r8,r0
;;;2654     uint32_t count = 0U;
000012  2700              MOVS     r7,#0
;;;2655     
;;;2656     /* Check SD response */
;;;2657     if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
000014  2100              MOVS     r1,#0
000016  6820              LDR      r0,[r4,#0]
000018  f7fffffe          BL       SDIO_GetResponse
00001c  f0007000          AND      r0,r0,#0x2000000
000020  f1b07f00          CMP      r0,#0x2000000
000024  d104              BNE      |L38.48|
;;;2658     {
;;;2659       return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
000026  f44f6000          MOV      r0,#0x800
                  |L38.42|
;;;2660     }
;;;2661     
;;;2662     /* Set block size for card if it is not equal to current block size for card */
;;;2663     errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
;;;2664     if(errorstate != HAL_SD_ERROR_NONE)
;;;2665     {
;;;2666       hsd->ErrorCode |= HAL_SD_ERROR_NONE;
;;;2667       return errorstate;
;;;2668     }
;;;2669     
;;;2670     /* Send CMD55 */
;;;2671     errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
;;;2672     if(errorstate != HAL_SD_ERROR_NONE)
;;;2673     {
;;;2674       hsd->ErrorCode |= HAL_SD_ERROR_NONE;
;;;2675       return errorstate;
;;;2676     }
;;;2677     
;;;2678     /* Configure the SD DPSM (Data Path State Machine) */ 
;;;2679     config.DataTimeOut   = SDMMC_DATATIMEOUT;
;;;2680     config.DataLength    = 64U;
;;;2681     config.DataBlockSize = SDIO_DATABLOCK_SIZE_64B;
;;;2682     config.TransferDir   = SDIO_TRANSFER_DIR_TO_SDIO;
;;;2683     config.TransferMode  = SDIO_TRANSFER_MODE_BLOCK;
;;;2684     config.DPSM          = SDIO_DPSM_ENABLE;
;;;2685     SDIO_ConfigData(hsd->Instance, &config);
;;;2686     
;;;2687     /* Send ACMD13 (SD_APP_STAUS)  with argument as card's RCA */
;;;2688     errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
;;;2689     if(errorstate != HAL_SD_ERROR_NONE)
;;;2690     {
;;;2691       hsd->ErrorCode |= HAL_SD_ERROR_NONE;
;;;2692       return errorstate;
;;;2693     }
;;;2694     
;;;2695     /* Get status data */
;;;2696     while(!__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR | SDIO_FLAG_DCRCFAIL | SDIO_FLAG_DTIMEOUT | SDIO_FLAG_DBCKEND))
;;;2697     {
;;;2698       if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXFIFOHF))
;;;2699       {
;;;2700         for(count = 0U; count < 8U; count++)
;;;2701         {
;;;2702           *(pSDstatus + count) = SDIO_ReadFIFO(hsd->Instance);
;;;2703         }
;;;2704         
;;;2705         pSDstatus += 8U;
;;;2706       }
;;;2707       
;;;2708       if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
;;;2709       {
;;;2710         return HAL_SD_ERROR_TIMEOUT;
;;;2711       }
;;;2712     }
;;;2713     
;;;2714     if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DTIMEOUT))
;;;2715     {
;;;2716       return HAL_SD_ERROR_DATA_TIMEOUT;
;;;2717     }
;;;2718     else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_DCRCFAIL))
;;;2719     {
;;;2720       return HAL_SD_ERROR_DATA_CRC_FAIL;
;;;2721     }
;;;2722     else if(__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXOVERR))
;;;2723     {
;;;2724       return HAL_SD_ERROR_RX_OVERRUN;
;;;2725     }
;;;2726   
;;;2727     while ((__HAL_SD_GET_FLAG(hsd, SDIO_FLAG_RXDAVL)))
;;;2728     {
;;;2729       *pSDstatus = SDIO_ReadFIFO(hsd->Instance);
;;;2730       pSDstatus++;
;;;2731       
;;;2732       if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
;;;2733       {
;;;2734         return HAL_SD_ERROR_TIMEOUT;
;;;2735       }
;;;2736     }
;;;2737     
;;;2738     /* Clear all the static status flags*/
;;;2739     __HAL_SD_CLEAR_FLAG(hsd, SDIO_STATIC_FLAGS);
;;;2740     
;;;2741     return HAL_SD_ERROR_NONE;
;;;2742   }
00002a  b006              ADD      sp,sp,#0x18
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L38.48|
000030  2140              MOVS     r1,#0x40              ;2663
000032  6820              LDR      r0,[r4,#0]            ;2663
000034  f7fffffe          BL       SDMMC_CmdBlockLength
000038  4606              MOV      r6,r0                 ;2663
00003a  b11e              CBZ      r6,|L38.68|
00003c  6ba0              LDR      r0,[r4,#0x38]         ;2666
00003e  63a0              STR      r0,[r4,#0x38]         ;2666
000040  4630              MOV      r0,r6                 ;2667
000042  e7f2              B        |L38.42|
                  |L38.68|
000044  2250              MOVS     r2,#0x50              ;2671
000046  5b12              LDRH     r2,[r2,r4]            ;2671
000048  0411              LSLS     r1,r2,#16             ;2671
00004a  6820              LDR      r0,[r4,#0]            ;2671
00004c  f7fffffe          BL       SDMMC_CmdAppCommand
000050  4606              MOV      r6,r0                 ;2671
000052  b11e              CBZ      r6,|L38.92|
000054  6ba0              LDR      r0,[r4,#0x38]         ;2674
000056  63a0              STR      r0,[r4,#0x38]         ;2674
000058  4630              MOV      r0,r6                 ;2675
00005a  e7e6              B        |L38.42|
                  |L38.92|
00005c  f04f30ff          MOV      r0,#0xffffffff        ;2679
000060  9000              STR      r0,[sp,#0]            ;2679
000062  2040              MOVS     r0,#0x40              ;2680
000064  9001              STR      r0,[sp,#4]            ;2680
000066  2060              MOVS     r0,#0x60              ;2681
000068  9002              STR      r0,[sp,#8]            ;2681
00006a  2002              MOVS     r0,#2                 ;2682
00006c  9003              STR      r0,[sp,#0xc]          ;2682
00006e  2000              MOVS     r0,#0                 ;2683
000070  9004              STR      r0,[sp,#0x10]         ;2683
000072  2001              MOVS     r0,#1                 ;2684
000074  9005              STR      r0,[sp,#0x14]         ;2684
000076  4669              MOV      r1,sp                 ;2685
000078  6820              LDR      r0,[r4,#0]            ;2685
00007a  f7fffffe          BL       SDIO_ConfigData
00007e  6820              LDR      r0,[r4,#0]            ;2688
000080  f7fffffe          BL       SDMMC_CmdStatusRegister
000084  4606              MOV      r6,r0                 ;2688
000086  b11e              CBZ      r6,|L38.144|
000088  6ba0              LDR      r0,[r4,#0x38]         ;2691
00008a  63a0              STR      r0,[r4,#0x38]         ;2691
00008c  4630              MOV      r0,r6                 ;2692
00008e  e7cc              B        |L38.42|
                  |L38.144|
000090  e018              B        |L38.196|
                  |L38.146|
000092  6820              LDR      r0,[r4,#0]            ;2698
000094  6b40              LDR      r0,[r0,#0x34]         ;2698
000096  f4004000          AND      r0,r0,#0x8000         ;2698
00009a  b150              CBZ      r0,|L38.178|
00009c  2700              MOVS     r7,#0                 ;2700
00009e  e005              B        |L38.172|
                  |L38.160|
0000a0  6820              LDR      r0,[r4,#0]            ;2702
0000a2  f7fffffe          BL       SDIO_ReadFIFO
0000a6  f8450027          STR      r0,[r5,r7,LSL #2]     ;2702
0000aa  1c7f              ADDS     r7,r7,#1              ;2700
                  |L38.172|
0000ac  2f08              CMP      r7,#8                 ;2700
0000ae  d3f7              BCC      |L38.160|
0000b0  3520              ADDS     r5,r5,#0x20           ;2705
                  |L38.178|
0000b2  f7fffffe          BL       HAL_GetTick
0000b6  eba00008          SUB      r0,r0,r8              ;2708
0000ba  1c40              ADDS     r0,r0,#1              ;2708
0000bc  b910              CBNZ     r0,|L38.196|
0000be  f04f4000          MOV      r0,#0x80000000        ;2710
0000c2  e7b2              B        |L38.42|
                  |L38.196|
0000c4  6820              LDR      r0,[r4,#0]            ;2696
0000c6  6b40              LDR      r0,[r0,#0x34]         ;2696
0000c8  f240412a          MOV      r1,#0x42a             ;2696
0000cc  4008              ANDS     r0,r0,r1              ;2696
0000ce  2800              CMP      r0,#0                 ;2696
0000d0  d0df              BEQ      |L38.146|
0000d2  6820              LDR      r0,[r4,#0]            ;2714
0000d4  6b40              LDR      r0,[r0,#0x34]         ;2714
0000d6  f0000008          AND      r0,r0,#8              ;2714
0000da  b108              CBZ      r0,|L38.224|
0000dc  2008              MOVS     r0,#8                 ;2716
0000de  e7a4              B        |L38.42|
                  |L38.224|
0000e0  6820              LDR      r0,[r4,#0]            ;2718
0000e2  6b40              LDR      r0,[r0,#0x34]         ;2718
0000e4  f0000002          AND      r0,r0,#2              ;2718
0000e8  b108              CBZ      r0,|L38.238|
0000ea  2002              MOVS     r0,#2                 ;2720
0000ec  e79d              B        |L38.42|
                  |L38.238|
0000ee  6820              LDR      r0,[r4,#0]            ;2722
0000f0  6b40              LDR      r0,[r0,#0x34]         ;2722
0000f2  f0000020          AND      r0,r0,#0x20           ;2722
0000f6  b108              CBZ      r0,|L38.252|
0000f8  2020              MOVS     r0,#0x20              ;2724
0000fa  e796              B        |L38.42|
                  |L38.252|
0000fc  e00d              B        |L38.282|
                  |L38.254|
0000fe  6820              LDR      r0,[r4,#0]            ;2729
000100  f7fffffe          BL       SDIO_ReadFIFO
000104  6028              STR      r0,[r5,#0]            ;2729
000106  1d2d              ADDS     r5,r5,#4              ;2730
000108  f7fffffe          BL       HAL_GetTick
00010c  eba00008          SUB      r0,r0,r8              ;2732
000110  1c40              ADDS     r0,r0,#1              ;2732
000112  b910              CBNZ     r0,|L38.282|
000114  f04f4000          MOV      r0,#0x80000000        ;2734
000118  e787              B        |L38.42|
                  |L38.282|
00011a  6820              LDR      r0,[r4,#0]            ;2727
00011c  6b40              LDR      r0,[r0,#0x34]         ;2727
00011e  f4001000          AND      r0,r0,#0x200000       ;2727
000122  2800              CMP      r0,#0                 ;2727
000124  d1eb              BNE      |L38.254|
000126  f24050ff          MOV      r0,#0x5ff             ;2739
00012a  6821              LDR      r1,[r4,#0]            ;2739
00012c  6388              STR      r0,[r1,#0x38]         ;2739
00012e  2000              MOVS     r0,#0                 ;2741
000130  e77b              B        |L38.42|
;;;2743   
                          ENDP


                          AREA ||i.SD_SendStatus||, CODE, READONLY, ALIGN=1

                  SD_SendStatus PROC
;;;2750     */
;;;2751   static uint32_t SD_SendStatus(SD_HandleTypeDef *hsd, uint32_t *pCardStatus)
000000  b570              PUSH     {r4-r6,lr}
;;;2752   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2753     uint32_t errorstate = HAL_SD_ERROR_NONE;
000006  2600              MOVS     r6,#0
;;;2754     
;;;2755     if(pCardStatus == NULL)
000008  b915              CBNZ     r5,|L39.16|
;;;2756     {
;;;2757       return HAL_SD_ERROR_PARAM;
00000a  f04f6000          MOV      r0,#0x8000000
                  |L39.14|
;;;2758     }
;;;2759     
;;;2760     /* Send Status command */
;;;2761     errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
;;;2762     if(errorstate != HAL_OK)
;;;2763     {
;;;2764       return errorstate;
;;;2765     }
;;;2766     
;;;2767     /* Get SD card status */
;;;2768     *pCardStatus = SDIO_GetResponse(hsd->Instance, SDIO_RESP1);
;;;2769     
;;;2770     return HAL_SD_ERROR_NONE;
;;;2771   }
00000e  bd70              POP      {r4-r6,pc}
                  |L39.16|
000010  2250              MOVS     r2,#0x50              ;2761
000012  5b12              LDRH     r2,[r2,r4]            ;2761
000014  0411              LSLS     r1,r2,#16             ;2761
000016  6820              LDR      r0,[r4,#0]            ;2761
000018  f7fffffe          BL       SDMMC_CmdSendStatus
00001c  4606              MOV      r6,r0                 ;2761
00001e  b10e              CBZ      r6,|L39.36|
000020  4630              MOV      r0,r6                 ;2764
000022  e7f4              B        |L39.14|
                  |L39.36|
000024  2100              MOVS     r1,#0                 ;2768
000026  6820              LDR      r0,[r4,#0]            ;2768
000028  f7fffffe          BL       SDIO_GetResponse
00002c  6028              STR      r0,[r5,#0]            ;2768
00002e  2000              MOVS     r0,#0                 ;2770
000030  e7ed              B        |L39.14|
;;;2772   
                          ENDP


                          AREA ||i.SD_WideBus_Disable||, CODE, READONLY, ALIGN=1

                  SD_WideBus_Disable PROC
;;;2824     */
;;;2825   static uint32_t SD_WideBus_Disable(SD_HandleTypeDef *hsd)
000000  b57c              PUSH     {r2-r6,lr}
;;;2826   {
000002  4604              MOV      r4,r0
;;;2827     uint32_t scr[2U] = {0U, 0U};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
;;;2828     uint32_t errorstate = HAL_SD_ERROR_NONE;
00000a  2500              MOVS     r5,#0
;;;2829     
;;;2830     if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
00000c  2100              MOVS     r1,#0
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       SDIO_GetResponse
000014  f0007000          AND      r0,r0,#0x2000000
000018  f1b07f00          CMP      r0,#0x2000000
00001c  d102              BNE      |L40.36|
;;;2831     {
;;;2832       return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
00001e  f44f6000          MOV      r0,#0x800
                  |L40.34|
;;;2833     }
;;;2834     
;;;2835     /* Get SCR Register */
;;;2836     errorstate = SD_FindSCR(hsd, scr);
;;;2837     if(errorstate != HAL_OK)
;;;2838     {
;;;2839       return errorstate;
;;;2840     }
;;;2841     
;;;2842     /* If requested card supports 1 bit mode operation */
;;;2843     if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
;;;2844     {
;;;2845       /* Send CMD55 APP_CMD with argument as card's RCA */
;;;2846       errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
;;;2847       if(errorstate != HAL_OK)
;;;2848       {
;;;2849         return errorstate;
;;;2850       }
;;;2851       
;;;2852       /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
;;;2853       errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
;;;2854       if(errorstate != HAL_OK)
;;;2855       {
;;;2856         return errorstate;
;;;2857       }
;;;2858       
;;;2859       return HAL_SD_ERROR_NONE;
;;;2860     }
;;;2861     else
;;;2862     {
;;;2863       return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
;;;2864     }
;;;2865   }
000022  bd7c              POP      {r2-r6,pc}
                  |L40.36|
000024  4669              MOV      r1,sp                 ;2836
000026  4620              MOV      r0,r4                 ;2836
000028  f7fffffe          BL       SD_FindSCR
00002c  4605              MOV      r5,r0                 ;2836
00002e  b10d              CBZ      r5,|L40.52|
000030  4628              MOV      r0,r5                 ;2839
000032  e7f6              B        |L40.34|
                  |L40.52|
000034  9801              LDR      r0,[sp,#4]            ;2843
000036  f4003080          AND      r0,r0,#0x10000        ;2843
00003a  b198              CBZ      r0,|L40.100|
00003c  2250              MOVS     r2,#0x50              ;2846
00003e  5b12              LDRH     r2,[r2,r4]            ;2846
000040  0411              LSLS     r1,r2,#16             ;2846
000042  6820              LDR      r0,[r4,#0]            ;2846
000044  f7fffffe          BL       SDMMC_CmdAppCommand
000048  4605              MOV      r5,r0                 ;2846
00004a  b10d              CBZ      r5,|L40.80|
00004c  4628              MOV      r0,r5                 ;2849
00004e  e7e8              B        |L40.34|
                  |L40.80|
000050  2100              MOVS     r1,#0                 ;2853
000052  6820              LDR      r0,[r4,#0]            ;2853
000054  f7fffffe          BL       SDMMC_CmdBusWidth
000058  4605              MOV      r5,r0                 ;2853
00005a  b10d              CBZ      r5,|L40.96|
00005c  4628              MOV      r0,r5                 ;2856
00005e  e7e0              B        |L40.34|
                  |L40.96|
000060  2000              MOVS     r0,#0                 ;2859
000062  e7de              B        |L40.34|
                  |L40.100|
000064  f04f6080          MOV      r0,#0x4000000         ;2863
000068  e7db              B        |L40.34|
;;;2866     
                          ENDP


                          AREA ||i.SD_WideBus_Enable||, CODE, READONLY, ALIGN=1

                  SD_WideBus_Enable PROC
;;;2777     */
;;;2778   static uint32_t SD_WideBus_Enable(SD_HandleTypeDef *hsd)
000000  b57c              PUSH     {r2-r6,lr}
;;;2779   {
000002  4604              MOV      r4,r0
;;;2780     uint32_t scr[2U] = {0U, 0U};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
;;;2781     uint32_t errorstate = HAL_SD_ERROR_NONE;
00000a  2500              MOVS     r5,#0
;;;2782     
;;;2783     if((SDIO_GetResponse(hsd->Instance, SDIO_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
00000c  2100              MOVS     r1,#0
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       SDIO_GetResponse
000014  f0007000          AND      r0,r0,#0x2000000
000018  f1b07f00          CMP      r0,#0x2000000
00001c  d102              BNE      |L41.36|
;;;2784     {
;;;2785       return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
00001e  f44f6000          MOV      r0,#0x800
                  |L41.34|
;;;2786     }
;;;2787     
;;;2788     /* Get SCR Register */
;;;2789     errorstate = SD_FindSCR(hsd, scr);
;;;2790     if(errorstate != HAL_OK)
;;;2791     {
;;;2792       return errorstate;
;;;2793     }
;;;2794     
;;;2795     /* If requested card supports wide bus operation */
;;;2796     if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
;;;2797     {
;;;2798       /* Send CMD55 APP_CMD with argument as card's RCA.*/
;;;2799       errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
;;;2800       if(errorstate != HAL_OK)
;;;2801       {
;;;2802         return errorstate;
;;;2803       }
;;;2804       
;;;2805       /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
;;;2806       errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
;;;2807       if(errorstate != HAL_OK)
;;;2808       {
;;;2809         return errorstate;
;;;2810       }
;;;2811   
;;;2812       return HAL_SD_ERROR_NONE;
;;;2813     }
;;;2814     else
;;;2815     {
;;;2816       return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
;;;2817     }
;;;2818   }
000022  bd7c              POP      {r2-r6,pc}
                  |L41.36|
000024  4669              MOV      r1,sp                 ;2789
000026  4620              MOV      r0,r4                 ;2789
000028  f7fffffe          BL       SD_FindSCR
00002c  4605              MOV      r5,r0                 ;2789
00002e  b10d              CBZ      r5,|L41.52|
000030  4628              MOV      r0,r5                 ;2792
000032  e7f6              B        |L41.34|
                  |L41.52|
000034  9801              LDR      r0,[sp,#4]            ;2796
000036  f4002080          AND      r0,r0,#0x40000        ;2796
00003a  b198              CBZ      r0,|L41.100|
00003c  2250              MOVS     r2,#0x50              ;2799
00003e  5b12              LDRH     r2,[r2,r4]            ;2799
000040  0411              LSLS     r1,r2,#16             ;2799
000042  6820              LDR      r0,[r4,#0]            ;2799
000044  f7fffffe          BL       SDMMC_CmdAppCommand
000048  4605              MOV      r5,r0                 ;2799
00004a  b10d              CBZ      r5,|L41.80|
00004c  4628              MOV      r0,r5                 ;2802
00004e  e7e8              B        |L41.34|
                  |L41.80|
000050  2102              MOVS     r1,#2                 ;2806
000052  6820              LDR      r0,[r4,#0]            ;2806
000054  f7fffffe          BL       SDMMC_CmdBusWidth
000058  4605              MOV      r5,r0                 ;2806
00005a  b10d              CBZ      r5,|L41.96|
00005c  4628              MOV      r0,r5                 ;2809
00005e  e7e0              B        |L41.34|
                  |L41.96|
000060  2000              MOVS     r0,#0                 ;2812
000062  e7de              B        |L41.34|
                  |L41.100|
000064  f04f6080          MOV      r0,#0x4000000         ;2816
000068  e7db              B        |L41.34|
;;;2819   
                          ENDP


                          AREA ||i.SD_Write_IT||, CODE, READONLY, ALIGN=1

                  SD_Write_IT PROC
;;;2988     */
;;;2989   static HAL_StatusTypeDef SD_Write_IT(SD_HandleTypeDef *hsd)
000000  b570              PUSH     {r4-r6,lr}
;;;2990   {
000002  4604              MOV      r4,r0
;;;2991     uint32_t count = 0U;
000004  2500              MOVS     r5,#0
;;;2992     uint32_t* tmp;
;;;2993     
;;;2994     tmp = (uint32_t*)hsd->pTxBuffPtr;
000006  6a26              LDR      r6,[r4,#0x20]
;;;2995     
;;;2996     /* Write data to SDIO Tx FIFO */
;;;2997     for(count = 0U; count < 8U; count++)
000008  bf00              NOP      
00000a  e005              B        |L42.24|
                  |L42.12|
;;;2998     {
;;;2999       SDIO_WriteFIFO(hsd->Instance, (tmp + count));
00000c  eb060185          ADD      r1,r6,r5,LSL #2
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       SDIO_WriteFIFO
000016  1c6d              ADDS     r5,r5,#1              ;2997
                  |L42.24|
000018  2d08              CMP      r5,#8                 ;2997
00001a  d3f7              BCC      |L42.12|
;;;3000     }
;;;3001     
;;;3002     hsd->pTxBuffPtr += 8U;
00001c  6a20              LDR      r0,[r4,#0x20]
00001e  3020              ADDS     r0,r0,#0x20
000020  6220              STR      r0,[r4,#0x20]
;;;3003     
;;;3004     return HAL_OK;
000022  2000              MOVS     r0,#0
;;;3005   }
000024  bd70              POP      {r4-r6,pc}
;;;3006   
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_sd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_hal_sd_c_b96143bd____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f4xx_hal_sd_c_b96143bd____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_hal_sd_c_b96143bd____REVSH|
#line 402
|__asm___18_stm32f4xx_hal_sd_c_b96143bd____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_hal_sd_c_b96143bd____RRX|
#line 587
|__asm___18_stm32f4xx_hal_sd_c_b96143bd____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
