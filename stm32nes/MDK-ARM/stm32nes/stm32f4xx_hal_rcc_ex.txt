; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_hal_rcc_ex.o --depend=stm32nes\stm32f4xx_hal_rcc_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_hal_rcc_ex.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_rcc_ex.c]
                          THUMB

                          AREA ||i.HAL_RCCEx_DisablePLLI2S||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisablePLLI2S PROC
;;;2891     */
;;;2892   HAL_StatusTypeDef HAL_RCCEx_DisablePLLI2S(void)
000000  b570              PUSH     {r4-r6,lr}
;;;2893   {
;;;2894     uint32_t tickstart;
;;;2895   
;;;2896     /* Disable the PLLI2S */
;;;2897     __HAL_RCC_PLLI2S_DISABLE();
000002  490c              LDR      r1,|L1.52|
000004  2000              MOVS     r0,#0
000006  6688              STR      r0,[r1,#0x68]
;;;2898   
;;;2899     /* Wait till PLLI2S is disabled */
;;;2900     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
;;;2901     while(READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
00000c  4d0a              LDR      r5,|L1.56|
00000e  4604              MOV      r4,r0                 ;2900
000010  6828              LDR      r0,[r5,#0]
000012  f0106f00          TST      r0,#0x8000000
000016  d00a              BEQ      |L1.46|
                  |L1.24|
;;;2902     {
;;;2903       if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
000018  f7fffffe          BL       HAL_GetTick
00001c  1b00              SUBS     r0,r0,r4
00001e  2802              CMP      r0,#2
000020  d901              BLS      |L1.38|
;;;2904       {
;;;2905         /* return in case of Timeout detected */
;;;2906         return HAL_TIMEOUT;
000022  2003              MOVS     r0,#3
;;;2907       }
;;;2908     }
;;;2909   
;;;2910     return HAL_OK;
;;;2911   }
000024  bd70              POP      {r4-r6,pc}
                  |L1.38|
000026  6828              LDR      r0,[r5,#0]            ;2901
000028  f0106f00          TST      r0,#0x8000000         ;2901
00002c  d1f4              BNE      |L1.24|
                  |L1.46|
00002e  2000              MOVS     r0,#0                 ;2910
000030  bd70              POP      {r4-r6,pc}
;;;2912   
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x42470000
                  |L1.56|
                          DCD      0x40023800

                          AREA ||i.HAL_RCCEx_DisablePLLSAI||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_DisablePLLSAI PROC
;;;2995     */
;;;2996   HAL_StatusTypeDef HAL_RCCEx_DisablePLLSAI(void)
000000  b570              PUSH     {r4-r6,lr}
;;;2997   {
;;;2998     uint32_t tickstart;
;;;2999   
;;;3000     /* Disable the PLLSAI */
;;;3001     __HAL_RCC_PLLSAI_DISABLE();
000002  490c              LDR      r1,|L2.52|
000004  2000              MOVS     r0,#0
000006  6708              STR      r0,[r1,#0x70]
;;;3002   
;;;3003     /* Wait till PLLSAI is disabled */
;;;3004     tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
;;;3005     while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
00000c  4d0a              LDR      r5,|L2.56|
00000e  4604              MOV      r4,r0                 ;3004
000010  6828              LDR      r0,[r5,#0]
000012  f0105f00          TST      r0,#0x20000000
000016  d00a              BEQ      |L2.46|
                  |L2.24|
;;;3006     {
;;;3007       if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
000018  f7fffffe          BL       HAL_GetTick
00001c  1b00              SUBS     r0,r0,r4
00001e  2802              CMP      r0,#2
000020  d901              BLS      |L2.38|
;;;3008       {
;;;3009         /* return in case of Timeout detected */
;;;3010         return HAL_TIMEOUT;
000022  2003              MOVS     r0,#3
;;;3011       }
;;;3012     }
;;;3013   
;;;3014     return HAL_OK;
;;;3015   }
000024  bd70              POP      {r4-r6,pc}
                  |L2.38|
000026  6828              LDR      r0,[r5,#0]            ;3005
000028  f0105f00          TST      r0,#0x20000000        ;3005
00002c  d1f4              BNE      |L2.24|
                  |L2.46|
00002e  2000              MOVS     r0,#0                 ;3014
000030  bd70              POP      {r4-r6,pc}
;;;3016   
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x42470000
                  |L2.56|
                          DCD      0x40023800

                          AREA ||i.HAL_RCCEx_EnablePLLI2S||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnablePLLI2S PROC
;;;2808     */
;;;2809   HAL_StatusTypeDef HAL_RCCEx_EnablePLLI2S(RCC_PLLI2SInitTypeDef  *PLLI2SInit)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2810   {
;;;2811     uint32_t tickstart;
;;;2812   
;;;2813     /* Check for parameters */
;;;2814     assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SInit->PLLI2SN));
;;;2815     assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SInit->PLLI2SR));
;;;2816   #if defined(RCC_PLLI2SCFGR_PLLI2SM)
;;;2817     assert_param(IS_RCC_PLLI2SM_VALUE(PLLI2SInit->PLLI2SM));
;;;2818   #endif /* RCC_PLLI2SCFGR_PLLI2SM */
;;;2819   #if defined(RCC_PLLI2SCFGR_PLLI2SP)
;;;2820     assert_param(IS_RCC_PLLI2SP_VALUE(PLLI2SInit->PLLI2SP));
;;;2821   #endif /* RCC_PLLI2SCFGR_PLLI2SP */
;;;2822   #if defined(RCC_PLLI2SCFGR_PLLI2SQ)
;;;2823     assert_param(IS_RCC_PLLI2SQ_VALUE(PLLI2SInit->PLLI2SQ));
;;;2824   #endif /* RCC_PLLI2SCFGR_PLLI2SQ */
;;;2825   
;;;2826     /* Disable the PLLI2S */
;;;2827     __HAL_RCC_PLLI2S_DISABLE();
000004  4f1b              LDR      r7,|L3.116|
000006  4606              MOV      r6,r0                 ;2810
000008  2000              MOVS     r0,#0
00000a  66b8              STR      r0,[r7,#0x68]
;;;2828   
;;;2829     /* Wait till PLLI2S is disabled */
;;;2830     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
;;;2831     while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) != RESET)
000010  4d19              LDR      r5,|L3.120|
000012  4604              MOV      r4,r0                 ;2830
000014  6828              LDR      r0,[r5,#0]
000016  f0106f00          TST      r0,#0x8000000
00001a  d008              BEQ      |L3.46|
                  |L3.28|
;;;2832     {
;;;2833       if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
00001c  f7fffffe          BL       HAL_GetTick
000020  1b00              SUBS     r0,r0,r4
000022  2802              CMP      r0,#2
000024  d81b              BHI      |L3.94|
000026  6828              LDR      r0,[r5,#0]            ;2831
000028  f0106f00          TST      r0,#0x8000000         ;2831
00002c  d1f6              BNE      |L3.28|
                  |L3.46|
;;;2834       {
;;;2835         /* return in case of Timeout detected */
;;;2836         return HAL_TIMEOUT;
;;;2837       }
;;;2838     }
;;;2839   
;;;2840     /* Configure the PLLI2S division factors */
;;;2841   #if defined(STM32F446xx)
;;;2842     /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
;;;2843     /* I2SPCLK = PLLI2S_VCO / PLLI2SP */
;;;2844     /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */
;;;2845     /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
;;;2846     __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SM, PLLI2SInit->PLLI2SN, \
;;;2847                             PLLI2SInit->PLLI2SP, PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);
;;;2848   #elif defined(STM32F412Zx) || defined(STM32F412Vx) || defined(STM32F412Rx) || defined(STM32F412Cx) ||\
;;;2849         defined(STM32F413xx) || defined(STM32F423xx)
;;;2850     /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM)*/
;;;2851     /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */
;;;2852     /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
;;;2853     __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SM, PLLI2SInit->PLLI2SN, \
;;;2854                             PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);
;;;2855   #elif defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) ||\
;;;2856         defined(STM32F469xx) || defined(STM32F479xx)
;;;2857     /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * PLLI2SN */
;;;2858     /* I2SQCLK = PLLI2S_VCO / PLLI2SQ */
;;;2859     /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
;;;2860     __HAL_RCC_PLLI2S_SAICLK_CONFIG(PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SQ, PLLI2SInit->PLLI2SR);
00002e  6830              LDR      r0,[r6,#0]
000030  7a31              LDRB     r1,[r6,#8]
000032  0180              LSLS     r0,r0,#6
000034  ea406001          ORR      r0,r0,r1,LSL #24
000038  7931              LDRB     r1,[r6,#4]
00003a  ea407001          ORR      r0,r0,r1,LSL #28
00003e  490f              LDR      r1,|L3.124|
000040  6008              STR      r0,[r1,#0]
;;;2861   #elif defined(STM32F411xE)
;;;2862     /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLI2SM) */
;;;2863     /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
;;;2864     __HAL_RCC_PLLI2S_I2SCLK_CONFIG(PLLI2SInit->PLLI2SM, PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SR);
;;;2865   #else
;;;2866     /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x PLLI2SN */
;;;2867     /* I2SRCLK = PLLI2S_VCO / PLLI2SR */
;;;2868     __HAL_RCC_PLLI2S_CONFIG(PLLI2SInit->PLLI2SN, PLLI2SInit->PLLI2SR);
;;;2869   #endif /* STM32F446xx */
;;;2870   
;;;2871     /* Enable the PLLI2S */
;;;2872     __HAL_RCC_PLLI2S_ENABLE();
000042  2001              MOVS     r0,#1
000044  66b8              STR      r0,[r7,#0x68]
;;;2873   
;;;2874     /* Wait till PLLI2S is ready */
;;;2875     tickstart = HAL_GetTick();
000046  f7fffffe          BL       HAL_GetTick
00004a  4604              MOV      r4,r0
;;;2876     while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY) == RESET)
00004c  6828              LDR      r0,[r5,#0]
00004e  f0106f00          TST      r0,#0x8000000
000052  d10b              BNE      |L3.108|
                  |L3.84|
;;;2877     {
;;;2878       if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
000054  f7fffffe          BL       HAL_GetTick
000058  1b00              SUBS     r0,r0,r4
00005a  2802              CMP      r0,#2
00005c  d902              BLS      |L3.100|
                  |L3.94|
;;;2879       {
;;;2880         /* return in case of Timeout detected */
;;;2881         return HAL_TIMEOUT;
00005e  2003              MOVS     r0,#3
;;;2882       }
;;;2883     }
;;;2884   
;;;2885    return HAL_OK;
;;;2886   }
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L3.100|
000064  6828              LDR      r0,[r5,#0]            ;2876
000066  f0106f00          TST      r0,#0x8000000         ;2876
00006a  d0f3              BEQ      |L3.84|
                  |L3.108|
00006c  2000              MOVS     r0,#0                 ;2885
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;2887   
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      0x42470000
                  |L3.120|
                          DCD      0x40023800
                  |L3.124|
                          DCD      0x40023884

                          AREA ||i.HAL_RCCEx_EnablePLLSAI||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_EnablePLLSAI PROC
;;;2921     */
;;;2922   HAL_StatusTypeDef HAL_RCCEx_EnablePLLSAI(RCC_PLLSAIInitTypeDef  *PLLSAIInit)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2923   {
;;;2924     uint32_t tickstart;
;;;2925   
;;;2926     /* Check for parameters */
;;;2927     assert_param(IS_RCC_PLLSAIN_VALUE(PLLSAIInit->PLLSAIN));
;;;2928     assert_param(IS_RCC_PLLSAIQ_VALUE(PLLSAIInit->PLLSAIQ));
;;;2929   #if defined(RCC_PLLSAICFGR_PLLSAIM)
;;;2930     assert_param(IS_RCC_PLLSAIM_VALUE(PLLSAIInit->PLLSAIM));
;;;2931   #endif /* RCC_PLLSAICFGR_PLLSAIM */
;;;2932   #if defined(RCC_PLLSAICFGR_PLLSAIP)
;;;2933     assert_param(IS_RCC_PLLSAIP_VALUE(PLLSAIInit->PLLSAIP));
;;;2934   #endif /* RCC_PLLSAICFGR_PLLSAIP */
;;;2935   #if defined(RCC_PLLSAICFGR_PLLSAIR)
;;;2936     assert_param(IS_RCC_PLLSAIR_VALUE(PLLSAIInit->PLLSAIR));
;;;2937   #endif /* RCC_PLLSAICFGR_PLLSAIR */
;;;2938   
;;;2939     /* Disable the PLLSAI */
;;;2940     __HAL_RCC_PLLSAI_DISABLE();
000004  4f1b              LDR      r7,|L4.116|
000006  4606              MOV      r6,r0                 ;2923
000008  2000              MOVS     r0,#0
00000a  6738              STR      r0,[r7,#0x70]
;;;2941   
;;;2942     /* Wait till PLLSAI is disabled */
;;;2943     tickstart = HAL_GetTick();
00000c  f7fffffe          BL       HAL_GetTick
;;;2944     while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
000010  4d19              LDR      r5,|L4.120|
000012  4604              MOV      r4,r0                 ;2943
000014  6828              LDR      r0,[r5,#0]
000016  f0105f00          TST      r0,#0x20000000
00001a  d008              BEQ      |L4.46|
                  |L4.28|
;;;2945     {
;;;2946       if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
00001c  f7fffffe          BL       HAL_GetTick
000020  1b00              SUBS     r0,r0,r4
000022  2802              CMP      r0,#2
000024  d81b              BHI      |L4.94|
000026  6828              LDR      r0,[r5,#0]            ;2944
000028  f0105f00          TST      r0,#0x20000000        ;2944
00002c  d1f6              BNE      |L4.28|
                  |L4.46|
;;;2947       {
;;;2948         /* return in case of Timeout detected */
;;;2949         return HAL_TIMEOUT;
;;;2950       }
;;;2951     }
;;;2952   
;;;2953     /* Configure the PLLSAI division factors */
;;;2954   #if defined(STM32F446xx)
;;;2955     /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) * (PLLSAIN/PLLSAIM) */
;;;2956     /* SAIPCLK = PLLSAI_VCO / PLLSAIP */
;;;2957     /* SAIQCLK = PLLSAI_VCO / PLLSAIQ */
;;;2958     /* SAIRCLK = PLLSAI_VCO / PLLSAIR */
;;;2959     __HAL_RCC_PLLSAI_CONFIG(PLLSAIInit->PLLSAIM, PLLSAIInit->PLLSAIN, \
;;;2960                             PLLSAIInit->PLLSAIP, PLLSAIInit->PLLSAIQ, 0U);
;;;2961   #elif defined(STM32F469xx) || defined(STM32F479xx)
;;;2962     /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) * PLLSAIN */
;;;2963     /* SAIPCLK = PLLSAI_VCO / PLLSAIP */
;;;2964     /* SAIQCLK = PLLSAI_VCO / PLLSAIQ */
;;;2965     /* SAIRCLK = PLLSAI_VCO / PLLSAIR */
;;;2966     __HAL_RCC_PLLSAI_CONFIG(PLLSAIInit->PLLSAIN, PLLSAIInit->PLLSAIP, \
;;;2967                             PLLSAIInit->PLLSAIQ, PLLSAIInit->PLLSAIR);
;;;2968   #else
;;;2969     /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x PLLSAIN */
;;;2970     /* SAIQCLK = PLLSAI_VCO / PLLSAIQ */
;;;2971     /* SAIRCLK = PLLSAI_VCO / PLLSAIR */
;;;2972     __HAL_RCC_PLLSAI_CONFIG(PLLSAIInit->PLLSAIN, PLLSAIInit->PLLSAIQ, PLLSAIInit->PLLSAIR);
00002e  6830              LDR      r0,[r6,#0]
000030  7931              LDRB     r1,[r6,#4]
000032  0180              LSLS     r0,r0,#6
000034  ea406001          ORR      r0,r0,r1,LSL #24
000038  7a31              LDRB     r1,[r6,#8]
00003a  ea407001          ORR      r0,r0,r1,LSL #28
00003e  490f              LDR      r1,|L4.124|
000040  6008              STR      r0,[r1,#0]
;;;2973   #endif /* STM32F446xx */
;;;2974   
;;;2975     /* Enable the PLLSAI */
;;;2976     __HAL_RCC_PLLSAI_ENABLE();
000042  2001              MOVS     r0,#1
000044  6738              STR      r0,[r7,#0x70]
;;;2977   
;;;2978     /* Wait till PLLSAI is ready */
;;;2979     tickstart = HAL_GetTick();
000046  f7fffffe          BL       HAL_GetTick
00004a  4604              MOV      r4,r0
;;;2980     while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
00004c  6828              LDR      r0,[r5,#0]
00004e  f0105f00          TST      r0,#0x20000000
000052  d10b              BNE      |L4.108|
                  |L4.84|
;;;2981     {
;;;2982       if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
000054  f7fffffe          BL       HAL_GetTick
000058  1b00              SUBS     r0,r0,r4
00005a  2802              CMP      r0,#2
00005c  d902              BLS      |L4.100|
                  |L4.94|
;;;2983       {
;;;2984         /* return in case of Timeout detected */
;;;2985         return HAL_TIMEOUT;
00005e  2003              MOVS     r0,#3
;;;2986       }
;;;2987     }
;;;2988   
;;;2989    return HAL_OK;
;;;2990   }
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L4.100|
000064  6828              LDR      r0,[r5,#0]            ;2980
000066  f0105f00          TST      r0,#0x20000000        ;2980
00006a  d0f3              BEQ      |L4.84|
                  |L4.108|
00006c  2000              MOVS     r0,#0                 ;2989
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;2991   
                          ENDP

000072  0000              DCW      0x0000
                  |L4.116|
                          DCD      0x42470000
                  |L4.120|
                          DCD      0x40023800
                  |L4.124|
                          DCD      0x40023888

                          AREA ||i.HAL_RCCEx_GetPeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKConfig PROC
;;;2403     */
;;;2404   void HAL_RCCEx_GetPeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  213f              MOVS     r1,#0x3f
;;;2405   {
;;;2406     uint32_t tempreg;
;;;2407   
;;;2408     /* Set all possible values for the extended clock type parameter------------*/
;;;2409     PeriphClkInit->PeriphClockSelection = RCC_PERIPHCLK_I2S | RCC_PERIPHCLK_SAI_PLLSAI | RCC_PERIPHCLK_SAI_PLLI2S | RCC_PERIPHCLK_LTDC | RCC_PERIPHCLK_TIM | RCC_PERIPHCLK_RTC;
;;;2410   
;;;2411     /* Get the PLLI2S Clock configuration -----------------------------------------------*/
;;;2412     PeriphClkInit->PLLI2S.PLLI2SN = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
000002  6001              STR      r1,[r0,#0]
000004  491c              LDR      r1,|L5.120|
000006  680a              LDR      r2,[r1,#0]
000008  f3c21288          UBFX     r2,r2,#6,#9
;;;2413     PeriphClkInit->PLLI2S.PLLI2SR = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
00000c  6042              STR      r2,[r0,#4]
00000e  680a              LDR      r2,[r1,#0]
000010  f3c27202          UBFX     r2,r2,#28,#3
;;;2414     PeriphClkInit->PLLI2S.PLLI2SQ = (uint32_t)((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
000014  6082              STR      r2,[r0,#8]
000016  6809              LDR      r1,[r1,#0]
000018  f3c16103          UBFX     r1,r1,#24,#4
;;;2415     /* Get the PLLSAI Clock configuration -----------------------------------------------*/
;;;2416     PeriphClkInit->PLLSAI.PLLSAIN = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);
00001c  60c1              STR      r1,[r0,#0xc]
00001e  4917              LDR      r1,|L5.124|
000020  680a              LDR      r2,[r1,#0]
000022  f3c21288          UBFX     r2,r2,#6,#9
;;;2417     PeriphClkInit->PLLSAI.PLLSAIR = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
000026  6102              STR      r2,[r0,#0x10]
000028  680a              LDR      r2,[r1,#0]
00002a  f3c27202          UBFX     r2,r2,#28,#3
;;;2418     PeriphClkInit->PLLSAI.PLLSAIQ = (uint32_t)((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
00002e  6182              STR      r2,[r0,#0x18]
000030  6809              LDR      r1,[r1,#0]
000032  f3c16103          UBFX     r1,r1,#24,#4
;;;2419     /* Get the PLLSAI/PLLI2S division factors -----------------------------------------------*/
;;;2420     PeriphClkInit->PLLI2SDivQ = (uint32_t)((RCC->DCKCFGR & RCC_DCKCFGR_PLLI2SDIVQ) >> RCC_DCKCFGR_PLLI2SDIVQ_Pos);
000036  6141              STR      r1,[r0,#0x14]
000038  4911              LDR      r1,|L5.128|
00003a  680a              LDR      r2,[r1,#0]
00003c  f002021f          AND      r2,r2,#0x1f
;;;2421     PeriphClkInit->PLLSAIDivQ = (uint32_t)((RCC->DCKCFGR & RCC_DCKCFGR_PLLSAIDIVQ) >> RCC_DCKCFGR_PLLSAIDIVQ_Pos);
000040  61c2              STR      r2,[r0,#0x1c]
000042  680a              LDR      r2,[r1,#0]
000044  f3c22204          UBFX     r2,r2,#8,#5
;;;2422     PeriphClkInit->PLLSAIDivR = (uint32_t)(RCC->DCKCFGR & RCC_DCKCFGR_PLLSAIDIVR);
000048  6202              STR      r2,[r0,#0x20]
00004a  680a              LDR      r2,[r1,#0]
00004c  f4023240          AND      r2,r2,#0x30000
;;;2423     /* Get the RTC Clock configuration -----------------------------------------------*/
;;;2424     tempreg = (RCC->CFGR & RCC_CFGR_RTCPRE);
000050  6242              STR      r2,[r0,#0x24]
000052  4a0c              LDR      r2,|L5.132|
000054  6812              LDR      r2,[r2,#0]
;;;2425     PeriphClkInit->RTCClockSelection = (uint32_t)((tempreg) | (RCC->BDCR & RCC_BDCR_RTCSEL));
000056  4b0c              LDR      r3,|L5.136|
000058  f40212f8          AND      r2,r2,#0x1f0000       ;2424
00005c  681b              LDR      r3,[r3,#0]
00005e  f4037340          AND      r3,r3,#0x300
000062  431a              ORRS     r2,r2,r3
;;;2426   
;;;2427     if ((RCC->DCKCFGR & RCC_DCKCFGR_TIMPRE) == RESET)
000064  6282              STR      r2,[r0,#0x28]
000066  6809              LDR      r1,[r1,#0]
000068  f0117180          ANDS     r1,r1,#0x1000000
;;;2428     {
;;;2429       PeriphClkInit->TIMPresSelection = RCC_TIMPRES_DESACTIVATED;
;;;2430     }
;;;2431     else
;;;2432     {
;;;2433       PeriphClkInit->TIMPresSelection = RCC_TIMPRES_ACTIVATED;
00006c  bf18              IT       NE
00006e  2101              MOVNE    r1,#1
000070  f880102c          STRB     r1,[r0,#0x2c]         ;2429
;;;2434     }
;;;2435   }
000074  4770              BX       lr
;;;2436   
                          ENDP

000076  0000              DCW      0x0000
                  |L5.120|
                          DCD      0x40023884
                  |L5.124|
                          DCD      0x40023888
                  |L5.128|
                          DCD      0x4002388c
                  |L5.132|
                          DCD      0x40023808
                  |L5.136|
                          DCD      0x40023870

                          AREA ||i.HAL_RCCEx_GetPeriphCLKFreq||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_GetPeriphCLKFreq PROC
;;;2444     */
;;;2445   uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
000000  4601              MOV      r1,r0
;;;2446   {
;;;2447     /* This variable used to store the I2S clock frequency (value in Hz) */
;;;2448     uint32_t frequency = 0U;
000002  2000              MOVS     r0,#0
;;;2449     /* This variable used to store the VCO Input (value in Hz) */
;;;2450     uint32_t vcoinput = 0U;
;;;2451     uint32_t srcclk = 0U;
;;;2452     /* This variable used to store the VCO Output (value in Hz) */
;;;2453     uint32_t vcooutput = 0U;
;;;2454     switch (PeriphClk)
000004  2901              CMP      r1,#1
;;;2455     {
;;;2456     case RCC_PERIPHCLK_I2S:
;;;2457       {
;;;2458         /* Get the current I2S source */
;;;2459         srcclk = __HAL_RCC_GET_I2S_SOURCE();
;;;2460         switch (srcclk)
;;;2461         {
;;;2462         /* Check if I2S clock selection is External clock mapped on the I2S_CKIN pin used as I2S clock */
;;;2463         case RCC_I2SCLKSOURCE_EXT:
;;;2464           {
;;;2465             /* Set the I2S clock to the external clock  value */
;;;2466             frequency = EXTERNAL_CLOCK_VALUE;
;;;2467             break;
;;;2468           }
;;;2469         /* Check if I2S clock selection is PLLI2S VCO output clock divided by PLLI2SR used as I2S clock */
;;;2470         case RCC_I2SCLKSOURCE_PLLI2S:
;;;2471           {
;;;2472             /* Configure the PLLI2S division factor */
;;;2473             /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
;;;2474             if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
;;;2475             {
;;;2476               /* Get the I2S source clock value */
;;;2477               vcoinput = (uint32_t)(HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
;;;2478             }
;;;2479             else
;;;2480             {
;;;2481               /* Get the I2S source clock value */
;;;2482               vcoinput = (uint32_t)(HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
;;;2483             }
;;;2484   
;;;2485             /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
;;;2486             vcooutput = (uint32_t)(vcoinput * (((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6U) & (RCC_PLLI2SCFGR_PLLI2SN >> 6U)));
;;;2487             /* I2S_CLK = PLLI2S_VCO Output/PLLI2SR */
;;;2488             frequency = (uint32_t)(vcooutput /(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28U) & (RCC_PLLI2SCFGR_PLLI2SR >> 28U)));
;;;2489             break;
;;;2490           }
;;;2491           /* Clock not enabled for I2S */
;;;2492         default:
;;;2493           {
;;;2494             frequency = 0U;
;;;2495             break;
;;;2496           }
;;;2497         }
;;;2498         break;
;;;2499       }
;;;2500     }
;;;2501     return frequency;
;;;2502   }
000006  bf18              IT       NE
000008  4770              BXNE     lr
00000a  4910              LDR      r1,|L6.76|
00000c  6809              LDR      r1,[r1,#0]            ;2459
00000e  f4110100          ANDS     r1,r1,#0x800000       ;2459
000012  d003              BEQ      |L6.28|
000014  2901              CMP      r1,#1                 ;2460
000016  bf08              IT       EQ                    ;2466
000018  480d              LDREQ    r0,|L6.80|
00001a  4770              BX       lr
                  |L6.28|
00001c  480d              LDR      r0,|L6.84|
00001e  6801              LDR      r1,[r0,#0]            ;2474
000020  6800              LDR      r0,[r0,#0]            ;2482
000022  f4110f80          TST      r1,#0x400000          ;2474
000026  f000003f          AND      r0,r0,#0x3f           ;2482
00002a  bf14              ITE      NE                    ;2477
00002c  490a              LDRNE    r1,|L6.88|
00002e  490b              LDREQ    r1,|L6.92|
000030  fbb1f0f0          UDIV     r0,r1,r0              ;2482
000034  490a              LDR      r1,|L6.96|
000036  680a              LDR      r2,[r1,#0]            ;2486
000038  6809              LDR      r1,[r1,#0]            ;2488
00003a  f3c21288          UBFX     r2,r2,#6,#9           ;2486
00003e  4350              MULS     r0,r2,r0              ;2486
000040  f3c17102          UBFX     r1,r1,#28,#3          ;2488
000044  fbb0f0f1          UDIV     r0,r0,r1              ;2488
000048  4770              BX       lr
;;;2503   #endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      0x40023808
                  |L6.80|
                          DCD      0x00bb8000
                  |L6.84|
                          DCD      0x40023804
                  |L6.88|
                          DCD      0x007a1200
                  |L6.92|
                          DCD      0x00f42400
                  |L6.96|
                          DCD      0x40023884

                          AREA ||i.HAL_RCCEx_PeriphCLKConfig||, CODE, READONLY, ALIGN=2

                  HAL_RCCEx_PeriphCLKConfig PROC
;;;2180     */
;;;2181   HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2182   {
000004  4604              MOV      r4,r0
;;;2183     uint32_t tickstart = 0U;
;;;2184     uint32_t tmpreg1 = 0U;
;;;2185   
;;;2186     /* Check the parameters */
;;;2187     assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
;;;2188   
;;;2189     /*----------------------- SAI/I2S Configuration (PLLI2S) -------------------*/
;;;2190     /*----------------------- Common configuration SAI/I2S ---------------------*/
;;;2191     /* In Case of SAI or I2S Clock Configuration through PLLI2S, PLLI2SN division
;;;2192        factor is common parameters for both peripherals */
;;;2193     if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) ||
000006  7800              LDRB     r0,[r0,#0]
;;;2194        (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == RCC_PERIPHCLK_SAI_PLLI2S))
;;;2195     {
;;;2196       /* check for Parameters */
;;;2197       assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
;;;2198   
;;;2199       /* Disable the PLLI2S */
;;;2200       __HAL_RCC_PLLI2S_DISABLE();
000008  f8dfa240          LDR      r10,|L7.588|
;;;2201       /* Get tick */
;;;2202       tickstart = HAL_GetTick();
;;;2203       /* Wait till PLLI2S is disabled */
;;;2204       while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
;;;2205       {
;;;2206         if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
;;;2207         {
;;;2208           /* return in case of Timeout detected */
;;;2209           return HAL_TIMEOUT;
;;;2210         }
;;;2211       }
;;;2212   
;;;2213       /*---------------------------- I2S configuration -------------------------*/
;;;2214       /* In Case of I2S Clock Configuration through PLLI2S, PLLI2SR must be added
;;;2215         only for I2S configuration */
;;;2216       if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
;;;2217       {
;;;2218         /* check for Parameters */
;;;2219         assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
;;;2220         /* Configure the PLLI2S division factors */
;;;2221         /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */
;;;2222         /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
;;;2223         __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
;;;2224       }
;;;2225   
;;;2226       /*---------------------------- SAI configuration -------------------------*/
;;;2227       /* In Case of SAI Clock Configuration through PLLI2S, PLLI2SQ and PLLI2S_DIVQ must
;;;2228          be added only for SAI configuration */
;;;2229       if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == (RCC_PERIPHCLK_SAI_PLLI2S))
;;;2230       {
;;;2231         /* Check the PLLI2S division factors */
;;;2232         assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
;;;2233         assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));
;;;2234   
;;;2235         /* Read PLLI2SR value from PLLI2SCFGR register (this value is not need for SAI configuration) */
;;;2236         tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
;;;2237         /* Configure the PLLI2S division factors */
;;;2238         /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
;;;2239         /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
;;;2240         /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
;;;2241         __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ , tmpreg1);
;;;2242         /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
;;;2243         __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
00000c  4f90              LDR      r7,|L7.592|
00000e  4e91              LDR      r6,|L7.596|
000010  f0100f03          TST      r0,#3                 ;2193
;;;2244       }
;;;2245   
;;;2246       /* Enable the PLLI2S */
;;;2247       __HAL_RCC_PLLI2S_ENABLE();
000014  f04f0901          MOV      r9,#1
000018  f04f0800          MOV      r8,#0                 ;2204
00001c  d045              BEQ      |L7.170|
00001e  f8ca8068          STR      r8,[r10,#0x68]        ;2200
000022  f7fffffe          BL       HAL_GetTick
000026  4605              MOV      r5,r0                 ;2202
000028  6830              LDR      r0,[r6,#0]            ;2204
00002a  f0106f00          TST      r0,#0x8000000         ;2204
00002e  d009              BEQ      |L7.68|
                  |L7.48|
000030  f7fffffe          BL       HAL_GetTick
000034  1b40              SUBS     r0,r0,r5              ;2206
000036  2802              CMP      r0,#2                 ;2206
000038  f20080d9          BHI.W    |L7.494|
00003c  6830              LDR      r0,[r6,#0]            ;2209
00003e  f0106f00          TST      r0,#0x8000000         ;2209
000042  d1f5              BNE      |L7.48|
                  |L7.68|
000044  7820              LDRB     r0,[r4,#0]            ;2216
000046  4984              LDR      r1,|L7.600|
000048  f0100f01          TST      r0,#1                 ;2216
00004c  d005              BEQ      |L7.90|
00004e  6860              LDR      r0,[r4,#4]            ;2223
000050  7a22              LDRB     r2,[r4,#8]            ;2223
000052  0180              LSLS     r0,r0,#6              ;2223
000054  ea407002          ORR      r0,r0,r2,LSL #28      ;2223
000058  6008              STR      r0,[r1,#0]            ;2223
                  |L7.90|
00005a  7820              LDRB     r0,[r4,#0]            ;2229
00005c  f0100f02          TST      r0,#2                 ;2229
000060  d011              BEQ      |L7.134|
000062  6808              LDR      r0,[r1,#0]            ;2236
000064  6862              LDR      r2,[r4,#4]            ;2241
000066  7b23              LDRB     r3,[r4,#0xc]          ;2241
000068  0192              LSLS     r2,r2,#6              ;2241
00006a  f3c07002          UBFX     r0,r0,#28,#3          ;2236
00006e  ea426203          ORR      r2,r2,r3,LSL #24      ;2241
000072  ea427000          ORR      r0,r2,r0,LSL #28      ;2241
000076  6008              STR      r0,[r1,#0]            ;2241
000078  6838              LDR      r0,[r7,#0]            ;2243
00007a  f020011f          BIC      r1,r0,#0x1f           ;2243
00007e  69e0              LDR      r0,[r4,#0x1c]         ;2243
000080  1e40              SUBS     r0,r0,#1              ;2243
000082  4308              ORRS     r0,r0,r1              ;2243
000084  6038              STR      r0,[r7,#0]            ;2243
                  |L7.134|
000086  f8ca9068          STR      r9,[r10,#0x68]
;;;2248       /* Get tick */
;;;2249       tickstart = HAL_GetTick();
00008a  f7fffffe          BL       HAL_GetTick
00008e  4605              MOV      r5,r0
;;;2250       /* Wait till PLLI2S is ready */
;;;2251       while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
000090  6830              LDR      r0,[r6,#0]
000092  f0106f00          TST      r0,#0x8000000
000096  d108              BNE      |L7.170|
                  |L7.152|
;;;2252       {
;;;2253         if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
000098  f7fffffe          BL       HAL_GetTick
00009c  1b40              SUBS     r0,r0,r5
00009e  2802              CMP      r0,#2
0000a0  d87e              BHI      |L7.416|
;;;2254         {
;;;2255           /* return in case of Timeout detected */
;;;2256           return HAL_TIMEOUT;
0000a2  6830              LDR      r0,[r6,#0]
0000a4  f0106f00          TST      r0,#0x8000000
0000a8  d0f6              BEQ      |L7.152|
                  |L7.170|
;;;2257         }
;;;2258       }
;;;2259     }
;;;2260     /*--------------------------------------------------------------------------*/
;;;2261   
;;;2262     /*----------------------- SAI/LTDC Configuration (PLLSAI) ------------------*/
;;;2263     /*----------------------- Common configuration SAI/LTDC --------------------*/
;;;2264     /* In Case of SAI or LTDC Clock Configuration through PLLSAI, PLLSAIN division
;;;2265        factor is common parameters for both peripherals */
;;;2266     if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == RCC_PERIPHCLK_SAI_PLLSAI) ||
0000aa  7820              LDRB     r0,[r4,#0]
0000ac  f0100f0c          TST      r0,#0xc
0000b0  d053              BEQ      |L7.346|
;;;2267        (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC))
;;;2268     {
;;;2269       /* Check the PLLSAI division factors */
;;;2270       assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
;;;2271   
;;;2272       /* Disable PLLSAI Clock */
;;;2273       __HAL_RCC_PLLSAI_DISABLE();
0000b2  f8ca8070          STR      r8,[r10,#0x70]
;;;2274       /* Get tick */
;;;2275       tickstart = HAL_GetTick();
0000b6  f7fffffe          BL       HAL_GetTick
0000ba  4605              MOV      r5,r0
;;;2276       /* Wait till PLLSAI is disabled */
;;;2277       while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
0000bc  6830              LDR      r0,[r6,#0]
0000be  f0105f00          TST      r0,#0x20000000
0000c2  d008              BEQ      |L7.214|
                  |L7.196|
;;;2278       {
;;;2279         if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
0000c4  f7fffffe          BL       HAL_GetTick
0000c8  1b40              SUBS     r0,r0,r5
0000ca  2802              CMP      r0,#2
0000cc  d868              BHI      |L7.416|
;;;2280         {
;;;2281           /* return in case of Timeout detected */
;;;2282           return HAL_TIMEOUT;
0000ce  6830              LDR      r0,[r6,#0]
0000d0  f0105f00          TST      r0,#0x20000000
0000d4  d1f6              BNE      |L7.196|
                  |L7.214|
;;;2283         }
;;;2284       }
;;;2285   
;;;2286       /*---------------------------- SAI configuration -------------------------*/
;;;2287       /* In Case of SAI Clock Configuration through PLLSAI, PLLSAIQ and PLLSAI_DIVQ must
;;;2288          be added only for SAI configuration */
;;;2289       if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == (RCC_PERIPHCLK_SAI_PLLSAI))
0000d6  7820              LDRB     r0,[r4,#0]
;;;2290       {
;;;2291         assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
;;;2292         assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));
;;;2293   
;;;2294         /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */
;;;2295         tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
0000d8  4960              LDR      r1,|L7.604|
0000da  f0100f04          TST      r0,#4                 ;2289
0000de  d014              BEQ      |L7.266|
0000e0  6808              LDR      r0,[r1,#0]
;;;2296         /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
;;;2297         /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
;;;2298         /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
;;;2299         __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
0000e2  6922              LDR      r2,[r4,#0x10]
0000e4  7d23              LDRB     r3,[r4,#0x14]
0000e6  0192              LSLS     r2,r2,#6
0000e8  f3c07002          UBFX     r0,r0,#28,#3          ;2295
0000ec  ea426203          ORR      r2,r2,r3,LSL #24
0000f0  ea427000          ORR      r0,r2,r0,LSL #28
0000f4  6008              STR      r0,[r1,#0]
;;;2300         /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
;;;2301         __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
0000f6  6838              LDR      r0,[r7,#0]
0000f8  f06f02ff          MVN      r2,#0xff
0000fc  f42053f8          BIC      r3,r0,#0x1f00
000100  6a20              LDR      r0,[r4,#0x20]
000102  eb022000          ADD      r0,r2,r0,LSL #8
000106  4318              ORRS     r0,r0,r3
000108  6038              STR      r0,[r7,#0]
                  |L7.266|
;;;2302       }
;;;2303   
;;;2304       /*---------------------------- LTDC configuration ------------------------*/
;;;2305       if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
00010a  7820              LDRB     r0,[r4,#0]
00010c  f0100f08          TST      r0,#8
000110  d010              BEQ      |L7.308|
;;;2306       {
;;;2307         assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
;;;2308         assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));
;;;2309   
;;;2310         /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */
;;;2311         tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
000112  6808              LDR      r0,[r1,#0]
;;;2312         /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
;;;2313         /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
;;;2314         /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
;;;2315         __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, PeriphClkInit->PLLSAI.PLLSAIR);
000114  6922              LDR      r2,[r4,#0x10]
000116  f3c06003          UBFX     r0,r0,#24,#4          ;2311
00011a  0192              LSLS     r2,r2,#6
00011c  ea426000          ORR      r0,r2,r0,LSL #24
000120  7e22              LDRB     r2,[r4,#0x18]
000122  ea407002          ORR      r0,r0,r2,LSL #28
000126  6008              STR      r0,[r1,#0]
;;;2316         /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
;;;2317         __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
000128  6838              LDR      r0,[r7,#0]
00012a  6a61              LDR      r1,[r4,#0x24]
00012c  f4203040          BIC      r0,r0,#0x30000
000130  4308              ORRS     r0,r0,r1
000132  6038              STR      r0,[r7,#0]
                  |L7.308|
;;;2318       }
;;;2319       /* Enable PLLSAI Clock */
;;;2320       __HAL_RCC_PLLSAI_ENABLE();
000134  f8ca9070          STR      r9,[r10,#0x70]
;;;2321       /* Get tick */
;;;2322       tickstart = HAL_GetTick();
000138  f7fffffe          BL       HAL_GetTick
00013c  4605              MOV      r5,r0
;;;2323       /* Wait till PLLSAI is ready */
;;;2324       while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
00013e  6830              LDR      r0,[r6,#0]
000140  f0105f00          TST      r0,#0x20000000
000144  d109              BNE      |L7.346|
;;;2325       {
;;;2326         if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
000146  bf00              NOP      
                  |L7.328|
000148  f7fffffe          BL       HAL_GetTick
00014c  1b40              SUBS     r0,r0,r5
00014e  2802              CMP      r0,#2
000150  d84d              BHI      |L7.494|
;;;2327         {
;;;2328           /* return in case of Timeout detected */
;;;2329           return HAL_TIMEOUT;
000152  6830              LDR      r0,[r6,#0]
000154  f0105f00          TST      r0,#0x20000000
000158  d0f6              BEQ      |L7.328|
                  |L7.346|
;;;2330         }
;;;2331       }
;;;2332     }
;;;2333     /*--------------------------------------------------------------------------*/
;;;2334   
;;;2335     /*---------------------------- RTC configuration ---------------------------*/
;;;2336     if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
00015a  7820              LDRB     r0,[r4,#0]
00015c  f0100f20          TST      r0,#0x20
000160  d05e              BEQ      |L7.544|
;;;2337     {
;;;2338       /* Check for RTC Parameters used to output RTCCLK */
;;;2339       assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
;;;2340   
;;;2341       /* Enable Power Clock*/
;;;2342       __HAL_RCC_PWR_CLK_ENABLE();
000162  483f              LDR      r0,|L7.608|
000164  6801              LDR      r1,[r0,#0]
000166  f0415180          ORR      r1,r1,#0x10000000
00016a  6001              STR      r1,[r0,#0]
00016c  6800              LDR      r0,[r0,#0]
;;;2343   
;;;2344       /* Enable write access to Backup domain */
;;;2345       PWR->CR |= PWR_CR_DBP;
00016e  4d3d              LDR      r5,|L7.612|
000170  f0005080          AND      r0,r0,#0x10000000     ;2342
000174  9000              STR      r0,[sp,#0]
000176  6828              LDR      r0,[r5,#0]
000178  f4407080          ORR      r0,r0,#0x100
00017c  6028              STR      r0,[r5,#0]
;;;2346   
;;;2347       /* Get tick */
;;;2348       tickstart = HAL_GetTick();
00017e  f7fffffe          BL       HAL_GetTick
000182  4606              MOV      r6,r0
;;;2349   
;;;2350       while((PWR->CR & PWR_CR_DBP) == RESET)
000184  6828              LDR      r0,[r5,#0]
000186  f4107f80          TST      r0,#0x100
00018a  d108              BNE      |L7.414|
                  |L7.396|
;;;2351       {
;;;2352         if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
00018c  f7fffffe          BL       HAL_GetTick
000190  1b80              SUBS     r0,r0,r6
000192  2802              CMP      r0,#2
000194  d82b              BHI      |L7.494|
;;;2353         {
;;;2354           return HAL_TIMEOUT;
000196  6828              LDR      r0,[r5,#0]
000198  f4107f80          TST      r0,#0x100
00019c  d0f6              BEQ      |L7.396|
                  |L7.414|
;;;2355         }
;;;2356       }
;;;2357       /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */
;;;2358       tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
00019e  e000              B        |L7.418|
                  |L7.416|
0001a0  e025              B        |L7.494|
                  |L7.418|
0001a2  4f31              LDR      r7,|L7.616|
0001a4  6838              LDR      r0,[r7,#0]
0001a6  f4107040          ANDS     r0,r0,#0x300
;;;2359       if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
0001aa  d027              BEQ      |L7.508|
0001ac  8d21              LDRH     r1,[r4,#0x28]
0001ae  f4017140          AND      r1,r1,#0x300
0001b2  4281              CMP      r1,r0
0001b4  d022              BEQ      |L7.508|
;;;2360       {
;;;2361         /* Store the content of BDCR register before the reset of Backup Domain */
;;;2362         tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
0001b6  6838              LDR      r0,[r7,#0]
0001b8  f4207140          BIC      r1,r0,#0x300
;;;2363         /* RTC Clock selection can be changed only if the Backup Domain is reset */
;;;2364         __HAL_RCC_BACKUPRESET_FORCE();
0001bc  482b              LDR      r0,|L7.620|
0001be  f8c09000          STR      r9,[r0,#0]
;;;2365         __HAL_RCC_BACKUPRESET_RELEASE();
0001c2  f8c08000          STR      r8,[r0,#0]
;;;2366         /* Restore the Content of BDCR register */
;;;2367         RCC->BDCR = tmpreg1;
0001c6  6039              STR      r1,[r7,#0]
;;;2368   
;;;2369         /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
;;;2370         if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
0001c8  6838              LDR      r0,[r7,#0]
0001ca  f0100f01          TST      r0,#1
0001ce  d015              BEQ      |L7.508|
;;;2371         {
;;;2372           /* Get tick */
;;;2373           tickstart = HAL_GetTick();
0001d0  f7fffffe          BL       HAL_GetTick
0001d4  4605              MOV      r5,r0
;;;2374   
;;;2375           /* Wait till LSE is ready */
;;;2376           while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
0001d6  6838              LDR      r0,[r7,#0]
0001d8  f0100f02          TST      r0,#2
;;;2377           {
;;;2378             if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
0001dc  bf08              IT       EQ
0001de  f2413688          MOVEQ    r6,#0x1388
0001e2  d10b              BNE      |L7.508|
                  |L7.484|
0001e4  f7fffffe          BL       HAL_GetTick
0001e8  1b40              SUBS     r0,r0,r5
0001ea  42b0              CMP      r0,r6
0001ec  d902              BLS      |L7.500|
                  |L7.494|
;;;2379             {
;;;2380               return HAL_TIMEOUT;
0001ee  2003              MOVS     r0,#3
;;;2381             }
;;;2382           }
;;;2383         }
;;;2384       }
;;;2385       __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
;;;2386     }
;;;2387     /*--------------------------------------------------------------------------*/
;;;2388   
;;;2389     /*---------------------------- TIM configuration ---------------------------*/
;;;2390     if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
;;;2391     {
;;;2392       __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
;;;2393     }
;;;2394     return HAL_OK;
;;;2395   }
0001f0  e8bd8ff8          POP      {r3-r11,pc}
                  |L7.500|
0001f4  6838              LDR      r0,[r7,#0]            ;2380
0001f6  f0100f02          TST      r0,#2                 ;2380
0001fa  d0f3              BEQ      |L7.484|
                  |L7.508|
0001fc  6aa0              LDR      r0,[r4,#0x28]         ;2385
0001fe  f44f7140          MOV      r1,#0x300             ;2385
000202  ea310200          BICS     r2,r1,r0              ;2385
000206  491a              LDR      r1,|L7.624|
000208  bf1c              ITT      NE                    ;2385
00020a  6808              LDRNE    r0,[r1,#0]            ;2385
00020c  f42010f8          BICNE    r0,r0,#0x1f0000       ;2385
000210  d012              BEQ      |L7.568|
                  |L7.530|
000212  6008              STR      r0,[r1,#0]            ;2385
000214  6838              LDR      r0,[r7,#0]            ;2385
000216  8d21              LDRH     r1,[r4,#0x28]         ;2385
000218  f3c1010b          UBFX     r1,r1,#0,#12          ;2385
00021c  4308              ORRS     r0,r0,r1              ;2385
00021e  6038              STR      r0,[r7,#0]            ;2385
                  |L7.544|
000220  7820              LDRB     r0,[r4,#0]            ;2390
000222  f0100f10          TST      r0,#0x10              ;2390
000226  d004              BEQ      |L7.562|
000228  4912              LDR      r1,|L7.628|
00022a  f894002c          LDRB     r0,[r4,#0x2c]         ;2392
00022e  f8c101e0          STR      r0,[r1,#0x1e0]        ;2392
                  |L7.562|
000232  2000              MOVS     r0,#0                 ;2394
000234  e8bd8ff8          POP      {r3-r11,pc}
                  |L7.568|
000238  680a              LDR      r2,[r1,#0]            ;2385
00023a  f4207040          BIC      r0,r0,#0x300          ;2385
00023e  f42212f8          BIC      r2,r2,#0x1f0000       ;2385
000242  f0204070          BIC      r0,r0,#0xf0000000     ;2385
000246  4310              ORRS     r0,r0,r2              ;2385
000248  e7e3              B        |L7.530|
;;;2396   
                          ENDP

00024a  0000              DCW      0x0000
                  |L7.588|
                          DCD      0x42470000
                  |L7.592|
                          DCD      0x4002388c
                  |L7.596|
                          DCD      0x40023800
                  |L7.600|
                          DCD      0x40023884
                  |L7.604|
                          DCD      0x40023888
                  |L7.608|
                          DCD      0x40023840
                  |L7.612|
                          DCD      0x40007000
                  |L7.616|
                          DCD      0x40023870
                  |L7.620|
                          DCD      0x42470e40
                  |L7.624|
                          DCD      0x40023808
                  |L7.628|
                          DCD      0x42471000

                          AREA ||i.HAL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_RCC_DeInit PROC
;;;3148     */
;;;3149   HAL_StatusTypeDef HAL_RCC_DeInit(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3150   {
;;;3151     uint32_t tickstart;
;;;3152   
;;;3153     /* Get Start Tick */
;;;3154     tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
;;;3155   
;;;3156     /* Set HSION bit to the reset value */
;;;3157     SET_BIT(RCC->CR, RCC_CR_HSION);
000008  4c5a              LDR      r4,|L8.372|
00000a  4605              MOV      r5,r0                 ;3154
00000c  6820              LDR      r0,[r4,#0]
00000e  f0400001          ORR      r0,r0,#1
000012  6020              STR      r0,[r4,#0]
;;;3158   
;;;3159     /* Wait till HSI is ready */
;;;3160     while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
000014  6820              LDR      r0,[r4,#0]
000016  f0100f02          TST      r0,#2
00001a  d108              BNE      |L8.46|
                  |L8.28|
;;;3161     {
;;;3162       if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
00001c  f7fffffe          BL       HAL_GetTick
000020  1b40              SUBS     r0,r0,r5
000022  2802              CMP      r0,#2
000024  d869              BHI      |L8.250|
000026  6820              LDR      r0,[r4,#0]            ;3160
000028  f0100f02          TST      r0,#2                 ;3160
00002c  d0f6              BEQ      |L8.28|
                  |L8.46|
;;;3163       {
;;;3164         return HAL_TIMEOUT;
;;;3165       }
;;;3166     }
;;;3167   
;;;3168     /* Set HSITRIM[4:0] bits to the reset value */
;;;3169     SET_BIT(RCC->CR, RCC_CR_HSITRIM_4);
00002e  6820              LDR      r0,[r4,#0]
000030  f0400080          ORR      r0,r0,#0x80
000034  6020              STR      r0,[r4,#0]
;;;3170   
;;;3171     /* Get Start Tick */
;;;3172     tickstart = HAL_GetTick();
000036  f7fffffe          BL       HAL_GetTick
;;;3173   
;;;3174     /* Reset CFGR register */
;;;3175     CLEAR_REG(RCC->CFGR);
00003a  4d4f              LDR      r5,|L8.376|
00003c  4606              MOV      r6,r0                 ;3172
00003e  2000              MOVS     r0,#0
000040  6028              STR      r0,[r5,#0]
;;;3176   
;;;3177     /* Wait till clock switch is ready */
;;;3178     while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET)
000042  6828              LDR      r0,[r5,#0]
000044  f0100f0c          TST      r0,#0xc
;;;3179     {
;;;3180       if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
000048  bf18              IT       NE
00004a  f2413788          MOVNE    r7,#0x1388
00004e  d008              BEQ      |L8.98|
                  |L8.80|
000050  f7fffffe          BL       HAL_GetTick
000054  1b80              SUBS     r0,r0,r6
000056  42b8              CMP      r0,r7
000058  d84f              BHI      |L8.250|
00005a  6828              LDR      r0,[r5,#0]            ;3178
00005c  f0100f0c          TST      r0,#0xc               ;3178
000060  d1f6              BNE      |L8.80|
                  |L8.98|
;;;3181       {
;;;3182         return HAL_TIMEOUT;
;;;3183       }
;;;3184     }
;;;3185   
;;;3186     /* Get Start Tick */
;;;3187     tickstart = HAL_GetTick();
000062  f7fffffe          BL       HAL_GetTick
000066  4605              MOV      r5,r0
;;;3188   
;;;3189     /* Clear HSEON, HSEBYP and CSSON bits */
;;;3190     CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_CSSON);
000068  6820              LDR      r0,[r4,#0]
00006a  f4202050          BIC      r0,r0,#0xd0000
00006e  6020              STR      r0,[r4,#0]
;;;3191   
;;;3192     /* Wait till HSE is disabled */
;;;3193     while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
000070  6820              LDR      r0,[r4,#0]
000072  f4103f00          TST      r0,#0x20000
000076  d008              BEQ      |L8.138|
                  |L8.120|
;;;3194     {
;;;3195       if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
000078  f7fffffe          BL       HAL_GetTick
00007c  1b40              SUBS     r0,r0,r5
00007e  2864              CMP      r0,#0x64
000080  d83b              BHI      |L8.250|
000082  6820              LDR      r0,[r4,#0]            ;3193
000084  f4103f00          TST      r0,#0x20000           ;3193
000088  d1f6              BNE      |L8.120|
                  |L8.138|
;;;3196       {
;;;3197         return HAL_TIMEOUT;
;;;3198       }
;;;3199     }
;;;3200   
;;;3201     /* Get Start Tick */
;;;3202     tickstart = HAL_GetTick();
00008a  f7fffffe          BL       HAL_GetTick
00008e  4605              MOV      r5,r0
;;;3203   
;;;3204     /* Clear PLLON bit */
;;;3205     CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
000090  6820              LDR      r0,[r4,#0]
000092  f0207080          BIC      r0,r0,#0x1000000
000096  6020              STR      r0,[r4,#0]
;;;3206   
;;;3207     /* Wait till PLL is disabled */
;;;3208     while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
000098  6820              LDR      r0,[r4,#0]
00009a  f0107f00          TST      r0,#0x2000000
00009e  d008              BEQ      |L8.178|
                  |L8.160|
;;;3209     {
;;;3210       if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
0000a0  f7fffffe          BL       HAL_GetTick
0000a4  1b40              SUBS     r0,r0,r5
0000a6  2802              CMP      r0,#2
0000a8  d827              BHI      |L8.250|
0000aa  6820              LDR      r0,[r4,#0]            ;3208
0000ac  f0107f00          TST      r0,#0x2000000         ;3208
0000b0  d1f6              BNE      |L8.160|
                  |L8.178|
;;;3211       {
;;;3212         return HAL_TIMEOUT;
;;;3213       }
;;;3214     }
;;;3215   
;;;3216   #if defined(RCC_PLLI2S_SUPPORT)
;;;3217     /* Get Start Tick */
;;;3218     tickstart = HAL_GetTick();
0000b2  f7fffffe          BL       HAL_GetTick
0000b6  4605              MOV      r5,r0
;;;3219   
;;;3220     /* Reset PLLI2SON bit */
;;;3221     CLEAR_BIT(RCC->CR, RCC_CR_PLLI2SON);
0000b8  6820              LDR      r0,[r4,#0]
0000ba  f0206080          BIC      r0,r0,#0x4000000
0000be  6020              STR      r0,[r4,#0]
;;;3222   
;;;3223     /* Wait till PLLI2S is disabled */
;;;3224     while (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) != RESET)
0000c0  6820              LDR      r0,[r4,#0]
0000c2  f0106f00          TST      r0,#0x8000000
0000c6  d008              BEQ      |L8.218|
                  |L8.200|
;;;3225     {
;;;3226       if ((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
0000c8  f7fffffe          BL       HAL_GetTick
0000cc  1b40              SUBS     r0,r0,r5
0000ce  2802              CMP      r0,#2
0000d0  d813              BHI      |L8.250|
0000d2  6820              LDR      r0,[r4,#0]            ;3224
0000d4  f0106f00          TST      r0,#0x8000000         ;3224
0000d8  d1f6              BNE      |L8.200|
                  |L8.218|
;;;3227       {
;;;3228         return HAL_TIMEOUT;
;;;3229       }
;;;3230     }
;;;3231   #endif /* RCC_PLLI2S_SUPPORT */
;;;3232   
;;;3233   #if defined(RCC_PLLSAI_SUPPORT)
;;;3234     /* Get Start Tick */
;;;3235     tickstart = HAL_GetTick();
0000da  f7fffffe          BL       HAL_GetTick
0000de  4605              MOV      r5,r0
;;;3236   
;;;3237     /* Reset PLLSAI bit */
;;;3238     CLEAR_BIT(RCC->CR, RCC_CR_PLLSAION);
0000e0  6820              LDR      r0,[r4,#0]
0000e2  f0205080          BIC      r0,r0,#0x10000000
0000e6  6020              STR      r0,[r4,#0]
;;;3239   
;;;3240     /* Wait till PLLSAI is disabled */
;;;3241     while (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) != RESET)
0000e8  6820              LDR      r0,[r4,#0]
0000ea  f0105f00          TST      r0,#0x20000000
0000ee  d00b              BEQ      |L8.264|
                  |L8.240|
;;;3242     {
;;;3243       if ((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
0000f0  f7fffffe          BL       HAL_GetTick
0000f4  1b40              SUBS     r0,r0,r5
0000f6  2802              CMP      r0,#2
0000f8  d902              BLS      |L8.256|
                  |L8.250|
;;;3244       {
;;;3245         return HAL_TIMEOUT;
0000fa  2003              MOVS     r0,#3
;;;3246       }
;;;3247     }
;;;3248   #endif /* RCC_PLLSAI_SUPPORT */
;;;3249   
;;;3250     /* Once PLL, PLLI2S and PLLSAI are OFF, reset PLLCFGR register to default value */
;;;3251   #if defined(STM32F412Cx) || defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || \
;;;3252       defined(STM32F423xx) || defined(STM32F446xx) || defined(STM32F469xx) || defined(STM32F479xx)
;;;3253     RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2 | RCC_PLLCFGR_PLLR_1;
;;;3254   #elif defined(STM32F410Tx) || defined(STM32F410Cx) || defined(STM32F410Rx)
;;;3255     RCC->PLLCFGR = RCC_PLLCFGR_PLLR_0 | RCC_PLLCFGR_PLLR_1 | RCC_PLLCFGR_PLLR_2 | RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_0 | RCC_PLLCFGR_PLLQ_1 | RCC_PLLCFGR_PLLQ_2 | RCC_PLLCFGR_PLLQ_3;
;;;3256   #else
;;;3257     RCC->PLLCFGR = RCC_PLLCFGR_PLLM_4 | RCC_PLLCFGR_PLLN_6 | RCC_PLLCFGR_PLLN_7 | RCC_PLLCFGR_PLLQ_2;
;;;3258   #endif /* STM32F412Cx || STM32F412Rx || STM32F412Vx || STM32F412Zx || STM32F413xx || STM32F423xx || STM32F446xx || STM32F469xx || STM32F479xx */
;;;3259   
;;;3260     /* Reset PLLI2SCFGR register to default value */
;;;3261   #if defined(STM32F412Cx) || defined(STM32F412Rx) || defined(STM32F412Vx) || defined(STM32F412Zx) || defined(STM32F413xx) || \
;;;3262       defined(STM32F423xx) || defined(STM32F446xx)
;;;3263     RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SM_4 | RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 | RCC_PLLI2SCFGR_PLLI2SR_1;
;;;3264   #elif defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx)
;;;3265     RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SR_1;
;;;3266   #elif defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
;;;3267     RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SQ_2 | RCC_PLLI2SCFGR_PLLI2SR_1;
;;;3268   #elif defined(STM32F411xE)
;;;3269     RCC->PLLI2SCFGR = RCC_PLLI2SCFGR_PLLI2SM_4 | RCC_PLLI2SCFGR_PLLI2SN_6 | RCC_PLLI2SCFGR_PLLI2SN_7 | RCC_PLLI2SCFGR_PLLI2SR_1;
;;;3270   #endif /* STM32F412Cx || STM32F412Rx || STM32F412Vx || STM32F412Zx || STM32F413xx || STM32F423xx || STM32F446xx */
;;;3271   
;;;3272     /* Reset PLLSAICFGR register */
;;;3273   #if defined(STM32F427xx) || defined(STM32F429xx) || defined(STM32F437xx) || defined(STM32F439xx) || defined(STM32F469xx) || defined(STM32F479xx)
;;;3274     RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2 | RCC_PLLSAICFGR_PLLSAIR_1;
;;;3275   #elif defined(STM32F446xx)
;;;3276     RCC->PLLSAICFGR = RCC_PLLSAICFGR_PLLSAIM_4 | RCC_PLLSAICFGR_PLLSAIN_6 | RCC_PLLSAICFGR_PLLSAIN_7 | RCC_PLLSAICFGR_PLLSAIQ_2;
;;;3277   #endif /* STM32F427xx || STM32F429xx || STM32F437xx || STM32F439xx || STM32F469xx || STM32F479xx */
;;;3278   
;;;3279     /* Disable all interrupts */
;;;3280     CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE);
;;;3281   
;;;3282   #if defined(RCC_CIR_PLLI2SRDYIE)
;;;3283     CLEAR_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYIE);
;;;3284   #endif /* RCC_CIR_PLLI2SRDYIE */
;;;3285   
;;;3286   #if defined(RCC_CIR_PLLSAIRDYIE)
;;;3287     CLEAR_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYIE);
;;;3288   #endif /* RCC_CIR_PLLSAIRDYIE */
;;;3289   
;;;3290     /* Clear all interrupt flags */
;;;3291     SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_CSSC);
;;;3292   
;;;3293   #if defined(RCC_CIR_PLLI2SRDYC)
;;;3294     SET_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYC);
;;;3295   #endif /* RCC_CIR_PLLI2SRDYC */
;;;3296   
;;;3297   #if defined(RCC_CIR_PLLSAIRDYC)
;;;3298     SET_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYC);
;;;3299   #endif /* RCC_CIR_PLLSAIRDYC */
;;;3300   
;;;3301     /* Clear LSION bit */
;;;3302     CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
;;;3303   
;;;3304     /* Reset all CSR flags */
;;;3305     SET_BIT(RCC->CSR, RCC_CSR_RMVF);
;;;3306   
;;;3307     /* Update the SystemCoreClock global variable */
;;;3308     SystemCoreClock = HSI_VALUE;
;;;3309   
;;;3310     /* Adapt Systick interrupt period */
;;;3311     if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
;;;3312     {
;;;3313       return HAL_ERROR;
;;;3314     }
;;;3315     else
;;;3316     {
;;;3317       return HAL_OK;
;;;3318     }
;;;3319   }
0000fc  e8bd81f0          POP      {r4-r8,pc}
                  |L8.256|
000100  6820              LDR      r0,[r4,#0]            ;3241
000102  f0105f00          TST      r0,#0x20000000        ;3241
000106  d1f3              BNE      |L8.240|
                  |L8.264|
000108  491d              LDR      r1,|L8.384|
00010a  481c              LDR      r0,|L8.380|
00010c  6008              STR      r0,[r1,#0]            ;3257
00010e  491e              LDR      r1,|L8.392|
000110  481c              LDR      r0,|L8.388|
000112  6008              STR      r0,[r1,#0]            ;3267
000114  1d09              ADDS     r1,r1,#4              ;3274
000116  6008              STR      r0,[r1,#0]            ;3274
000118  481c              LDR      r0,|L8.396|
00011a  6801              LDR      r1,[r0,#0]            ;3280
00011c  f42151f8          BIC      r1,r1,#0x1f00         ;3280
000120  6001              STR      r1,[r0,#0]            ;3280
000122  6801              LDR      r1,[r0,#0]            ;3283
000124  f4215100          BIC      r1,r1,#0x2000         ;3283
000128  6001              STR      r1,[r0,#0]            ;3283
00012a  6801              LDR      r1,[r0,#0]            ;3287
00012c  f4214180          BIC      r1,r1,#0x4000         ;3287
000130  6001              STR      r1,[r0,#0]            ;3287
000132  6801              LDR      r1,[r0,#0]            ;3291
000134  f441011f          ORR      r1,r1,#0x9f0000       ;3291
000138  6001              STR      r1,[r0,#0]            ;3291
00013a  6801              LDR      r1,[r0,#0]            ;3294
00013c  f4411100          ORR      r1,r1,#0x200000       ;3294
000140  6001              STR      r1,[r0,#0]            ;3294
000142  6801              LDR      r1,[r0,#0]            ;3298
000144  f4410180          ORR      r1,r1,#0x400000       ;3298
000148  6001              STR      r1,[r0,#0]            ;3298
00014a  4811              LDR      r0,|L8.400|
00014c  6801              LDR      r1,[r0,#0]            ;3302
00014e  f0210101          BIC      r1,r1,#1              ;3302
000152  6001              STR      r1,[r0,#0]            ;3302
000154  6801              LDR      r1,[r0,#0]            ;3305
000156  f0417180          ORR      r1,r1,#0x1000000      ;3305
00015a  6001              STR      r1,[r0,#0]            ;3305
00015c  490e              LDR      r1,|L8.408|
00015e  480d              LDR      r0,|L8.404|
000160  6008              STR      r0,[r1,#0]            ;3311  ; SystemCoreClock
000162  2000              MOVS     r0,#0                 ;3311
000164  f7fffffe          BL       HAL_InitTick
000168  2800              CMP      r0,#0                 ;3311
00016a  bf18              IT       NE                    ;3313
00016c  2001              MOVNE    r0,#1                 ;3313
00016e  e8bd81f0          POP      {r4-r8,pc}
;;;3320   
                          ENDP

000172  0000              DCW      0x0000
                  |L8.372|
                          DCD      0x40023800
                  |L8.376|
                          DCD      0x40023808
                  |L8.380|
                          DCD      0x04003010
                  |L8.384|
                          DCD      0x40023804
                  |L8.388|
                          DCD      0x24003000
                  |L8.392|
                          DCD      0x40023884
                  |L8.396|
                          DCD      0x4002380c
                  |L8.400|
                          DCD      0x40023874
                  |L8.404|
                          DCD      0x00f42400
                  |L8.408|
                          DCD      SystemCoreClock

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_rcc_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____REVSH|
#line 402
|__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____RRX|
#line 587
|__asm___22_stm32f4xx_hal_rcc_ex_c_bed13b44____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
