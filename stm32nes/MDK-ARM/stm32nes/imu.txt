; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\imu.o --depend=stm32nes\imu.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\imu.crf ..\Src\imu.c]
                          THUMB

                          AREA ||i.IMU_dataAvailable||, CODE, READONLY, ALIGN=2

                  IMU_dataAvailable PROC
;;;120    
;;;121    uint8_t IMU_dataAvailable(void){
000000  b510              PUSH     {r4,lr}
;;;122    	//If we have an interrupt pin connection available, check if data is available.
;;;123    	//If int pin is NULL, then we'll rely on receivePacket() to timeout
;;;124    	//See issue 13: https://github.com/sparkfun/SparkFun_BNO080_Arduino_Library/issues/13
;;;125    	if (gpio_read(APU_IRQ)) return 2;
000002  4811              LDR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
000006  f4007000          AND      r0,r0,#0x200
00000a  f5b07f00          CMP      r0,#0x200
00000e  d101              BNE      |L1.20|
000010  2002              MOVS     r0,#2
                  |L1.18|
;;;126    
;;;127    	if (IMU_receivePacket()){
;;;128    		//Check to see if this packet is a sensor reporting its data to us
;;;129    		if (shtpHeader[2] == CHANNEL_REPORTS && shtpData[0] == SHTP_REPORT_BASE_TIMESTAMP)
;;;130    		{
;;;131    			IMU_parseInputReport(); //This will update the rawAccelX, etc variables depending on which feature report is found
;;;132    			return 1;
;;;133    		}
;;;134    		else if (shtpHeader[2] == CHANNEL_CONTROL)
;;;135    		{
;;;136    			IMU_parseCommandReport(); //This will update responses to commands, calibrationStatus, etc.
;;;137    			return 1;
;;;138    		}
;;;139    	}
;;;140    	return 0;
;;;141    }
000012  bd10              POP      {r4,pc}
                  |L1.20|
000014  f7fffffe          BL       IMU_receivePacket
000018  b198              CBZ      r0,|L1.66|
00001a  480c              LDR      r0,|L1.76|
00001c  7880              LDRB     r0,[r0,#2]            ;129  ; shtpHeader
00001e  2803              CMP      r0,#3                 ;129
000020  d107              BNE      |L1.50|
000022  480b              LDR      r0,|L1.80|
000024  7800              LDRB     r0,[r0,#0]            ;129  ; shtpData
000026  28fb              CMP      r0,#0xfb              ;129
000028  d103              BNE      |L1.50|
00002a  f7fffffe          BL       IMU_parseInputReport
00002e  2001              MOVS     r0,#1                 ;132
000030  e7ef              B        |L1.18|
                  |L1.50|
000032  4806              LDR      r0,|L1.76|
000034  7880              LDRB     r0,[r0,#2]            ;134  ; shtpHeader
000036  2802              CMP      r0,#2                 ;134
000038  d103              BNE      |L1.66|
00003a  f7fffffe          BL       IMU_parseCommandReport
00003e  2001              MOVS     r0,#1                 ;137
000040  e7e7              B        |L1.18|
                  |L1.66|
000042  2000              MOVS     r0,#0                 ;140
000044  e7e5              B        |L1.18|
;;;142    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
                          DCD      0x40020c10
                  |L1.76|
                          DCD      shtpHeader
                  |L1.80|
                          DCD      shtpData

                          AREA ||i.IMU_enableAccel||, CODE, READONLY, ALIGN=1

                  IMU_enableAccel PROC
;;;366    
;;;367    void IMU_enableAccel(uint16_t freq)
000000  b510              PUSH     {r4,lr}
;;;368    {
000002  4604              MOV      r4,r0
;;;369    	IMU_setFeatureCommand(SENSOR_REPORTID_ACCELEROMETER, freq,0);
000004  2200              MOVS     r2,#0
000006  4621              MOV      r1,r4
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       IMU_setFeatureCommand
;;;370    }
00000e  bd10              POP      {r4,pc}
;;;371    
                          ENDP


                          AREA ||i.IMU_enableGyro||, CODE, READONLY, ALIGN=1

                  IMU_enableGyro PROC
;;;356    
;;;357    void IMU_enableGyro(uint16_t freq)
000000  b510              PUSH     {r4,lr}
;;;358    {
000002  4604              MOV      r4,r0
;;;359    	IMU_setFeatureCommand(SENSOR_REPORTID_GYROSCOPE, freq,0);
000004  2200              MOVS     r2,#0
000006  4621              MOV      r1,r4
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       IMU_setFeatureCommand
;;;360    }
00000e  bd10              POP      {r4,pc}
;;;361    
                          ENDP


                          AREA ||i.IMU_enableRotation||, CODE, READONLY, ALIGN=1

                  IMU_enableRotation PROC
;;;361    
;;;362    void IMU_enableRotation(uint16_t freq)
000000  b510              PUSH     {r4,lr}
;;;363    {
000002  4604              MOV      r4,r0
;;;364    	IMU_setFeatureCommand(SENSOR_REPORTID_ROTATION_VECTOR, freq,0);
000004  2200              MOVS     r2,#0
000006  4621              MOV      r1,r4
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       IMU_setFeatureCommand
;;;365    }
00000e  bd10              POP      {r4,pc}
;;;366    
                          ENDP


                          AREA ||i.IMU_init||, CODE, READONLY, ALIGN=2

                  IMU_init PROC
;;;142    
;;;143    uint8_t IMU_init(void) {
000000  b510              PUSH     {r4,lr}
;;;144    	LL_SPI_Enable(IMU_SPI);
000002  bf00              NOP      
000004  4825              LDR      r0,|L5.156|
000006  6800              LDR      r0,[r0,#0]
000008  f0400040          ORR      r0,r0,#0x40
00000c  4923              LDR      r1,|L5.156|
00000e  6008              STR      r0,[r1,#0]
000010  bf00              NOP      
;;;145    
;;;146    	gpio_set(APU_NSS);
000012  1589              ASRS     r1,r1,#22
000014  4822              LDR      r0,|L5.160|
000016  f7fffffe          BL       LL_GPIO_SetOutputPin
;;;147    	gpio_set(APU_IO1);
00001a  f44f6100          MOV      r1,#0x800
00001e  4820              LDR      r0,|L5.160|
000020  f7fffffe          BL       LL_GPIO_SetOutputPin
;;;148    	gpio_set(APU_IO2);
000024  f44f5180          MOV      r1,#0x1000
000028  481d              LDR      r0,|L5.160|
00002a  f7fffffe          BL       LL_GPIO_SetOutputPin
;;;149    
;;;150    	gpio_reset(APU_RST);
00002e  f44f6180          MOV      r1,#0x400
000032  481b              LDR      r0,|L5.160|
000034  f7fffffe          BL       LL_GPIO_ResetOutputPin
;;;151    	delay(2);
000038  2002              MOVS     r0,#2
00003a  491a              LDR      r1,|L5.164|
00003c  6008              STR      r0,[r1,#0]  ; __delay
00003e  bf00              NOP      
000040  bf00              NOP      
                  |L5.66|
000042  4918              LDR      r1,|L5.164|
000044  6809              LDR      r1,[r1,#0]  ; __delay
000046  2900              CMP      r1,#0
000048  d1fb              BNE      |L5.66|
00004a  bf00              NOP      
;;;152    	gpio_set(APU_RST);
00004c  f44f6180          MOV      r1,#0x400
000050  4813              LDR      r0,|L5.160|
000052  f7fffffe          BL       LL_GPIO_SetOutputPin
;;;153    
;;;154    	if (!IMU_waitForSPI()) return 0;
000056  f7fffffe          BL       IMU_waitForSPI
00005a  b908              CBNZ     r0,|L5.96|
00005c  2000              MOVS     r0,#0
                  |L5.94|
;;;155    	// shtpData[0] = 1; //Reset
;;;156    
;;;157    	// //Attempt to start communication with sensor
;;;158    	// IMU_sendPacket(CHANNEL_EXECUTABLE, 1); //Transmit packet on channel 1, 1 byte
;;;159    
;;;160    	// //Read all incoming data and flush it
;;;161    	// delay(50);
;;;162    	// while (IMU_receivePacket());
;;;163    	// delay(50);
;;;164    	// while (IMU_receivePacket());
;;;165    	
;;;166    	IMU_waitForSPI();
;;;167    	IMU_receivePacket();
;;;168    
;;;169    	IMU_waitForSPI();
;;;170    	IMU_receivePacket();
;;;171    
;;;172    	shtpData[0] = SHTP_REPORT_PRODUCT_ID_REQUEST; //Request the product ID and reset info
;;;173    	shtpData[1] = 0;							  //Reserved
;;;174    
;;;175    	IMU_sendPacket(CHANNEL_CONTROL, 2);
;;;176    	IMU_waitForSPI();
;;;177    	if (IMU_receivePacket())
;;;178    	{
;;;179    		if (shtpData[0] == SHTP_REPORT_PRODUCT_ID_RESPONSE)
;;;180    			return 1;
;;;181    	}
;;;182    	return 0;
;;;183    }
00005e  bd10              POP      {r4,pc}
                  |L5.96|
000060  f7fffffe          BL       IMU_waitForSPI
000064  f7fffffe          BL       IMU_receivePacket
000068  f7fffffe          BL       IMU_waitForSPI
00006c  f7fffffe          BL       IMU_receivePacket
000070  20f9              MOVS     r0,#0xf9              ;172
000072  490d              LDR      r1,|L5.168|
000074  7008              STRB     r0,[r1,#0]            ;172
000076  2000              MOVS     r0,#0                 ;173
000078  7048              STRB     r0,[r1,#1]            ;173
00007a  2102              MOVS     r1,#2                 ;175
00007c  4608              MOV      r0,r1                 ;175
00007e  f7fffffe          BL       IMU_sendPacket
000082  f7fffffe          BL       IMU_waitForSPI
000086  f7fffffe          BL       IMU_receivePacket
00008a  b128              CBZ      r0,|L5.152|
00008c  4806              LDR      r0,|L5.168|
00008e  7800              LDRB     r0,[r0,#0]            ;179  ; shtpData
000090  28f8              CMP      r0,#0xf8              ;179
000092  d101              BNE      |L5.152|
000094  2001              MOVS     r0,#1                 ;180
000096  e7e2              B        |L5.94|
                  |L5.152|
000098  2000              MOVS     r0,#0                 ;182
00009a  e7e0              B        |L5.94|
;;;184    
                          ENDP

                  |L5.156|
                          DCD      0x40003800
                  |L5.160|
                          DCD      0x40020c00
                  |L5.164|
                          DCD      __delay
                  |L5.168|
                          DCD      shtpData

                          AREA ||i.IMU_parseCommandReport||, CODE, READONLY, ALIGN=2

                  IMU_parseCommandReport PROC
;;;184    
;;;185    void IMU_parseCommandReport(void) {
000000  4806              LDR      r0,|L6.28|
;;;186    	if (shtpData[0] == SHTP_REPORT_COMMAND_RESPONSE)
000002  7800              LDRB     r0,[r0,#0]  ; shtpData
000004  28f1              CMP      r0,#0xf1
000006  d107              BNE      |L6.24|
;;;187    	{
;;;188    		//The BNO080 responds with this report to command requests. It's up to use to remember which command we issued.
;;;189    		uint8_t command = shtpData[2]; //This is the Command byte of the response
000008  4904              LDR      r1,|L6.28|
00000a  7888              LDRB     r0,[r1,#2]  ; shtpData
;;;190    
;;;191    		if (command == COMMAND_ME_CALIBRATE)
00000c  2807              CMP      r0,#7
00000e  d102              BNE      |L6.22|
;;;192    		{
;;;193    			calibrationStatus = shtpData[5 + 0]; //R0 - Status (0 = success, non-zero = fail)
000010  7949              LDRB     r1,[r1,#5]  ; shtpData
000012  4a03              LDR      r2,|L6.32|
000014  7011              STRB     r1,[r2,#0]
                  |L6.22|
;;;194    		}
;;;195    	}
000016  bf00              NOP      
                  |L6.24|
;;;196    }
000018  4770              BX       lr
;;;197    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      shtpData
                  |L6.32|
                          DCD      calibrationStatus

                          AREA ||i.IMU_parseInputReport||, CODE, READONLY, ALIGN=2

                  IMU_parseInputReport PROC
;;;198    
;;;199    void IMU_parseInputReport(void) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;200    	//Calculate the number of data bytes in this packet
;;;201    	int16_t dataLength = ((uint16_t)shtpHeader[1] << 8 | shtpHeader[0]);
000004  4d73              LDR      r5,|L7.468|
000006  782d              LDRB     r5,[r5,#0]  ; shtpHeader
000008  f8dfc1c8          LDR      r12,|L7.468|
00000c  f89cc001          LDRB     r12,[r12,#1]  ; shtpHeader
000010  ea45250c          ORR      r5,r5,r12,LSL #8
000014  b22c              SXTH     r4,r5
;;;202    	dataLength &= ~(1 << 15); //Clear the MSbit. This bit indicates if this package is a continuation of the last.
000016  f4244500          BIC      r5,r4,#0x8000
00001a  b22c              SXTH     r4,r5
;;;203    	//Ignore it for now. TODO catch this as an error and exit
;;;204    
;;;205    	dataLength -= 4; //Remove the header bytes from the data count
00001c  1f25              SUBS     r5,r4,#4
00001e  b22c              SXTH     r4,r5
;;;206    
;;;207    	timeStamp = ((uint32_t)shtpData[4] << (8 * 3)) | (shtpData[3] << (8 * 2)) | (shtpData[2] << (8 * 1)) | (shtpData[1] << (8 * 0));
000020  4d6d              LDR      r5,|L7.472|
000022  792d              LDRB     r5,[r5,#4]  ; shtpData
000024  062d              LSLS     r5,r5,#24
000026  f8dfc1b0          LDR      r12,|L7.472|
00002a  f89cc003          LDRB     r12,[r12,#3]  ; shtpData
00002e  ea45450c          ORR      r5,r5,r12,LSL #16
000032  f8dfc1a4          LDR      r12,|L7.472|
000036  f89cc002          LDRB     r12,[r12,#2]  ; shtpData
00003a  ea45250c          ORR      r5,r5,r12,LSL #8
00003e  f8dfc198          LDR      r12,|L7.472|
000042  f89cc001          LDRB     r12,[r12,#1]  ; shtpData
000046  ea45050c          ORR      r5,r5,r12
00004a  f8dfc190          LDR      r12,|L7.476|
00004e  f8cc5000          STR      r5,[r12,#0]  ; timeStamp
;;;208    
;;;209    	uint8_t status = shtpData[5 + 2] & 0x03; //Get status bits
000052  4d61              LDR      r5,|L7.472|
000054  79ed              LDRB     r5,[r5,#7]  ; shtpData
000056  f0050103          AND      r1,r5,#3
;;;210    	uint16_t data1 = (uint16_t)shtpData[5 + 5] << 8 | shtpData[5 + 4];
00005a  4d5f              LDR      r5,|L7.472|
00005c  7a6d              LDRB     r5,[r5,#9]  ; shtpData
00005e  f8dfc178          LDR      r12,|L7.472|
000062  f89cc00a          LDRB     r12,[r12,#0xa]  ; shtpData
000066  ea45220c          ORR      r2,r5,r12,LSL #8
;;;211    	uint16_t data2 = (uint16_t)shtpData[5 + 7] << 8 | shtpData[5 + 6];
00006a  4d5b              LDR      r5,|L7.472|
00006c  7aed              LDRB     r5,[r5,#0xb]  ; shtpData
00006e  f8dfc168          LDR      r12,|L7.472|
000072  f89cc00c          LDRB     r12,[r12,#0xc]  ; shtpData
000076  ea45230c          ORR      r3,r5,r12,LSL #8
;;;212    	uint16_t data3 = (uint16_t)shtpData[5 + 9] << 8 | shtpData[5 + 8];
00007a  4d57              LDR      r5,|L7.472|
00007c  7b6d              LDRB     r5,[r5,#0xd]  ; shtpData
00007e  f8dfc158          LDR      r12,|L7.472|
000082  f89cc00e          LDRB     r12,[r12,#0xe]  ; shtpData
000086  ea45200c          ORR      r0,r5,r12,LSL #8
;;;213    	uint16_t data4 = 0;
00008a  2600              MOVS     r6,#0
;;;214    	uint16_t data5 = 0;
00008c  2700              MOVS     r7,#0
;;;215    
;;;216    	if (dataLength - 5 > 9)
00008e  1f65              SUBS     r5,r4,#5
000090  2d09              CMP      r5,#9
000092  dd07              BLE      |L7.164|
;;;217    	{
;;;218    		data4 = (uint16_t)shtpData[5 + 11] << 8 | shtpData[5 + 10];
000094  4d50              LDR      r5,|L7.472|
000096  7bed              LDRB     r5,[r5,#0xf]  ; shtpData
000098  f8dfc13c          LDR      r12,|L7.472|
00009c  f89cc010          LDRB     r12,[r12,#0x10]  ; shtpData
0000a0  ea45260c          ORR      r6,r5,r12,LSL #8
                  |L7.164|
;;;219    	}
;;;220    	if (dataLength - 5 > 11)
0000a4  1f65              SUBS     r5,r4,#5
0000a6  2d0b              CMP      r5,#0xb
0000a8  dd07              BLE      |L7.186|
;;;221    	{
;;;222    		data5 = (uint16_t)shtpData[5 + 13] << 8 | shtpData[5 + 12];
0000aa  4d4b              LDR      r5,|L7.472|
0000ac  7c6d              LDRB     r5,[r5,#0x11]  ; shtpData
0000ae  f8dfc128          LDR      r12,|L7.472|
0000b2  f89cc012          LDRB     r12,[r12,#0x12]  ; shtpData
0000b6  ea45270c          ORR      r7,r5,r12,LSL #8
                  |L7.186|
;;;223    	}
;;;224    
;;;225    	//Store these generic values to their proper global variable
;;;226    	if (shtpData[5] == SENSOR_REPORTID_ACCELEROMETER)
0000ba  4d47              LDR      r5,|L7.472|
0000bc  796d              LDRB     r5,[r5,#5]  ; shtpData
0000be  2d01              CMP      r5,#1
0000c0  d108              BNE      |L7.212|
;;;227    	{
;;;228    		accelAccuracy = status;
0000c2  4d47              LDR      r5,|L7.480|
0000c4  8029              STRH     r1,[r5,#0]
;;;229    		rawAccelX = data1;
0000c6  4d47              LDR      r5,|L7.484|
0000c8  802a              STRH     r2,[r5,#0]
;;;230    		rawAccelY = data2;
0000ca  4d47              LDR      r5,|L7.488|
0000cc  802b              STRH     r3,[r5,#0]
;;;231    		rawAccelZ = data3;
0000ce  4d47              LDR      r5,|L7.492|
0000d0  8028              STRH     r0,[r5,#0]
0000d2  e07d              B        |L7.464|
                  |L7.212|
;;;232    	}
;;;233    	else if (shtpData[5] == SENSOR_REPORTID_LINEAR_ACCELERATION)
0000d4  4d40              LDR      r5,|L7.472|
0000d6  796d              LDRB     r5,[r5,#5]  ; shtpData
0000d8  2d04              CMP      r5,#4
0000da  d108              BNE      |L7.238|
;;;234    	{
;;;235    		accelLinAccuracy = status;
0000dc  4d44              LDR      r5,|L7.496|
0000de  8029              STRH     r1,[r5,#0]
;;;236    		rawLinAccelX = data1;
0000e0  4d44              LDR      r5,|L7.500|
0000e2  802a              STRH     r2,[r5,#0]
;;;237    		rawLinAccelY = data2;
0000e4  4d44              LDR      r5,|L7.504|
0000e6  802b              STRH     r3,[r5,#0]
;;;238    		rawLinAccelZ = data3;
0000e8  4d44              LDR      r5,|L7.508|
0000ea  8028              STRH     r0,[r5,#0]
0000ec  e070              B        |L7.464|
                  |L7.238|
;;;239    	}
;;;240    	else if (shtpData[5] == SENSOR_REPORTID_GYROSCOPE)
0000ee  4d3a              LDR      r5,|L7.472|
0000f0  796d              LDRB     r5,[r5,#5]  ; shtpData
0000f2  2d02              CMP      r5,#2
0000f4  d108              BNE      |L7.264|
;;;241    	{
;;;242    		gyroAccuracy = status;
0000f6  4d42              LDR      r5,|L7.512|
0000f8  8029              STRH     r1,[r5,#0]
;;;243    		rawGyroX = data1;
0000fa  4d42              LDR      r5,|L7.516|
0000fc  802a              STRH     r2,[r5,#0]
;;;244    		rawGyroY = data2;
0000fe  4d42              LDR      r5,|L7.520|
000100  802b              STRH     r3,[r5,#0]
;;;245    		rawGyroZ = data3;
000102  4d42              LDR      r5,|L7.524|
000104  8028              STRH     r0,[r5,#0]
000106  e063              B        |L7.464|
                  |L7.264|
;;;246    	}
;;;247    	else if (shtpData[5] == SENSOR_REPORTID_MAGNETIC_FIELD)
000108  4d33              LDR      r5,|L7.472|
00010a  796d              LDRB     r5,[r5,#5]  ; shtpData
00010c  2d03              CMP      r5,#3
00010e  d108              BNE      |L7.290|
;;;248    	{
;;;249    		magAccuracy = status;
000110  4d3f              LDR      r5,|L7.528|
000112  8029              STRH     r1,[r5,#0]
;;;250    		rawMagX = data1;
000114  4d3f              LDR      r5,|L7.532|
000116  802a              STRH     r2,[r5,#0]
;;;251    		rawMagY = data2;
000118  4d3f              LDR      r5,|L7.536|
00011a  802b              STRH     r3,[r5,#0]
;;;252    		rawMagZ = data3;
00011c  4d3f              LDR      r5,|L7.540|
00011e  8028              STRH     r0,[r5,#0]
000120  e056              B        |L7.464|
                  |L7.290|
;;;253    	}
;;;254    	else if (shtpData[5] == SENSOR_REPORTID_ROTATION_VECTOR || shtpData[5] == SENSOR_REPORTID_GAME_ROTATION_VECTOR)
000122  4d2d              LDR      r5,|L7.472|
000124  796d              LDRB     r5,[r5,#5]  ; shtpData
000126  2d05              CMP      r5,#5
000128  d003              BEQ      |L7.306|
00012a  4d2b              LDR      r5,|L7.472|
00012c  796d              LDRB     r5,[r5,#5]  ; shtpData
00012e  2d08              CMP      r5,#8
000130  d10c              BNE      |L7.332|
                  |L7.306|
;;;255    	{
;;;256    		quatAccuracy = status;
000132  4d3b              LDR      r5,|L7.544|
000134  8029              STRH     r1,[r5,#0]
;;;257    		rawQuatI = data1;
000136  4d3b              LDR      r5,|L7.548|
000138  802a              STRH     r2,[r5,#0]
;;;258    		rawQuatJ = data2;
00013a  4d3b              LDR      r5,|L7.552|
00013c  802b              STRH     r3,[r5,#0]
;;;259    		rawQuatK = data3;
00013e  4d3b              LDR      r5,|L7.556|
000140  8028              STRH     r0,[r5,#0]
;;;260    		rawQuatReal = data4;
000142  4d3b              LDR      r5,|L7.560|
000144  802e              STRH     r6,[r5,#0]
;;;261    		rawQuatRadianAccuracy = data5; //Only available on rotation vector, not game rot vector
000146  4d3b              LDR      r5,|L7.564|
000148  802f              STRH     r7,[r5,#0]
00014a  e041              B        |L7.464|
                  |L7.332|
;;;262    	}
;;;263    	else if (shtpData[5] == SENSOR_REPORTID_STEP_COUNTER)
00014c  4d22              LDR      r5,|L7.472|
00014e  796d              LDRB     r5,[r5,#5]  ; shtpData
000150  2d11              CMP      r5,#0x11
000152  d102              BNE      |L7.346|
;;;264    	{
;;;265    		stepCount = data3; //Bytes 8/9
000154  4d38              LDR      r5,|L7.568|
000156  8028              STRH     r0,[r5,#0]
000158  e03a              B        |L7.464|
                  |L7.346|
;;;266    	}
;;;267    	else if (shtpData[5] == SENSOR_REPORTID_STABILITY_CLASSIFIER)
00015a  4d1f              LDR      r5,|L7.472|
00015c  796d              LDRB     r5,[r5,#5]  ; shtpData
00015e  2d13              CMP      r5,#0x13
000160  d106              BNE      |L7.368|
;;;268    	{
;;;269    		stabilityClassifier = shtpData[5 + 4]; //Byte 4 only
000162  4d1d              LDR      r5,|L7.472|
000164  7a6d              LDRB     r5,[r5,#9]  ; shtpData
000166  f8dfc0d4          LDR      r12,|L7.572|
00016a  f88c5000          STRB     r5,[r12,#0]
00016e  e02f              B        |L7.464|
                  |L7.368|
;;;270    	}
;;;271    	else if (shtpData[5] == SENSOR_REPORTID_PERSONAL_ACTIVITY_CLASSIFIER)
000170  4d19              LDR      r5,|L7.472|
000172  796d              LDRB     r5,[r5,#5]  ; shtpData
000174  2d1e              CMP      r5,#0x1e
000176  d11a              BNE      |L7.430|
;;;272    	{
;;;273    		activityClassifier = shtpData[5 + 5]; //Most likely state
000178  4d17              LDR      r5,|L7.472|
00017a  7aad              LDRB     r5,[r5,#0xa]  ; shtpData
00017c  f8dfc0c0          LDR      r12,|L7.576|
000180  f88c5000          STRB     r5,[r12,#0]
;;;274    
;;;275    		//Load activity classification confidences into the array
;;;276    		for (uint8_t x = 0; x < 9; x++)					   //Hardcoded to max of 9. TODO - bring in array size
000184  2500              MOVS     r5,#0
000186  e00f              B        |L7.424|
                  |L7.392|
;;;277    			_activityConfidences[x] = shtpData[5 + 6 + x]; //5 bytes of timestamp, byte 6 is first confidence byte
000188  f1050c0b          ADD      r12,r5,#0xb
00018c  f8df8048          LDR      r8,|L7.472|
000190  f818c00c          LDRB     r12,[r8,r12]
000194  f8df80ac          LDR      r8,|L7.580|
000198  f8d88000          LDR      r8,[r8,#0]  ; _activityConfidences
00019c  f808c005          STRB     r12,[r8,r5]
0001a0  f1050c01          ADD      r12,r5,#1             ;276
0001a4  f00c05ff          AND      r5,r12,#0xff          ;276
                  |L7.424|
0001a8  2d09              CMP      r5,#9                 ;276
0001aa  dbed              BLT      |L7.392|
0001ac  e010              B        |L7.464|
                  |L7.430|
;;;278    	}
;;;279    	else if (shtpData[5] == SHTP_REPORT_COMMAND_RESPONSE)
0001ae  4d0a              LDR      r5,|L7.472|
0001b0  796d              LDRB     r5,[r5,#5]  ; shtpData
0001b2  2df1              CMP      r5,#0xf1
0001b4  d10c              BNE      |L7.464|
;;;280    	{
;;;281    		// Serial.println("!");
;;;282    		//The BNO080 responds with this report to command requests. It's up to use to remember which command we issued.
;;;283    		uint8_t command = shtpData[5 + 2]; //This is the Command byte of the response
0001b6  f8dfc020          LDR      r12,|L7.472|
0001ba  f89c5007          LDRB     r5,[r12,#7]  ; shtpData
;;;284    
;;;285    		if (command == COMMAND_ME_CALIBRATE)
0001be  2d07              CMP      r5,#7
0001c0  d105              BNE      |L7.462|
;;;286    		{
;;;287    			// Serial.println("ME Cal report found!");
;;;288    			calibrationStatus = shtpData[5 + 5]; //R0 - Status (0 = success, non-zero = fail)
0001c2  f89cc00a          LDRB     r12,[r12,#0xa]  ; shtpData
0001c6  f8df8080          LDR      r8,|L7.584|
0001ca  f888c000          STRB     r12,[r8,#0]
                  |L7.462|
;;;289    		}
;;;290    	}
0001ce  bf00              NOP      
                  |L7.464|
;;;291    	else
;;;292    	{
;;;293    		//This sensor report ID is unhandled.
;;;294    		//See reference manual to add additional feature reports as needed
;;;295    	}
;;;296    }
0001d0  e8bd81f0          POP      {r4-r8,pc}
;;;297    
                          ENDP

                  |L7.468|
                          DCD      shtpHeader
                  |L7.472|
                          DCD      shtpData
                  |L7.476|
                          DCD      timeStamp
                  |L7.480|
                          DCD      accelAccuracy
                  |L7.484|
                          DCD      rawAccelX
                  |L7.488|
                          DCD      rawAccelY
                  |L7.492|
                          DCD      rawAccelZ
                  |L7.496|
                          DCD      accelLinAccuracy
                  |L7.500|
                          DCD      rawLinAccelX
                  |L7.504|
                          DCD      rawLinAccelY
                  |L7.508|
                          DCD      rawLinAccelZ
                  |L7.512|
                          DCD      gyroAccuracy
                  |L7.516|
                          DCD      rawGyroX
                  |L7.520|
                          DCD      rawGyroY
                  |L7.524|
                          DCD      rawGyroZ
                  |L7.528|
                          DCD      magAccuracy
                  |L7.532|
                          DCD      rawMagX
                  |L7.536|
                          DCD      rawMagY
                  |L7.540|
                          DCD      rawMagZ
                  |L7.544|
                          DCD      quatAccuracy
                  |L7.548|
                          DCD      rawQuatI
                  |L7.552|
                          DCD      rawQuatJ
                  |L7.556|
                          DCD      rawQuatK
                  |L7.560|
                          DCD      rawQuatReal
                  |L7.564|
                          DCD      rawQuatRadianAccuracy
                  |L7.568|
                          DCD      stepCount
                  |L7.572|
                          DCD      stabilityClassifier
                  |L7.576|
                          DCD      activityClassifier
                  |L7.580|
                          DCD      _activityConfidences
                  |L7.584|
                          DCD      calibrationStatus

                          AREA ||i.IMU_receivePacket||, CODE, READONLY, ALIGN=2

                  IMU_receivePacket PROC
;;;49     
;;;50     uint8_t IMU_receivePacket(void) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;51     	if (gpio_read(APU_IRQ)) return 0; //Data is not available
000004  4823              LDR      r0,|L8.148|
000006  6800              LDR      r0,[r0,#0]
000008  f4007000          AND      r0,r0,#0x200
00000c  f5b07f00          CMP      r0,#0x200
000010  d102              BNE      |L8.24|
000012  2000              MOVS     r0,#0
                  |L8.20|
;;;52     
;;;53     	//Old way: if (waitForSPI() == false) return (false); //Something went wrong
;;;54     
;;;55     	//Get first four bytes to find out how much data we need to read
;;;56     	gpio_reset(APU_NSS);
;;;57     
;;;58     	//Get the first four bytes, aka the packet header
;;;59     	uint8_t packetLSB = IMU_transfer(0);
;;;60     	uint8_t packetMSB = IMU_transfer(0);
;;;61     	uint8_t channelNumber = IMU_transfer(0);
;;;62     	uint8_t sequenceNumber = IMU_transfer(0); //Not sure if we need to store this or not
;;;63     
;;;64     	//Store the header info
;;;65     	shtpHeader[0] = packetLSB;
;;;66     	shtpHeader[1] = packetMSB;
;;;67     	shtpHeader[2] = channelNumber;
;;;68     	shtpHeader[3] = sequenceNumber;
;;;69     
;;;70     	//Calculate the number of data bytes in this packet
;;;71     	int16_t dataLength = ((uint16_t)packetMSB << 8 | packetLSB);
;;;72     	dataLength &= ~(1 << 15); //Clear the MSbit.
;;;73     	//This bit indicates if this package is a continuation of the last. Ignore it for now.
;;;74     	//TODO catch this as an error and exit
;;;75     	if (dataLength == 0) return 0; //Packet is empty
;;;76     	dataLength -= 4; //Remove the header bytes from the data count
;;;77     
;;;78     	//Read incoming data into the shtpData array
;;;79     	for (uint16_t dataSpot = 0; dataSpot < dataLength; dataSpot++)
;;;80     	{
;;;81     		uint8_t incoming = IMU_transfer(0xFF);
;;;82     		if (dataSpot < MAX_PACKET_SIZE)	//BNO080 can respond with upto 270 bytes, avoid overflow
;;;83     			shtpData[dataSpot] = incoming; //Store data into the shtpData array
;;;84     	}
;;;85     	gpio_set(APU_NSS);
;;;86     
;;;87     	return 1;
;;;88     }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L8.24|
000018  f44f7180          MOV      r1,#0x100             ;56
00001c  481d              LDR      r0,|L8.148|
00001e  3810              SUBS     r0,r0,#0x10           ;56
000020  f7fffffe          BL       LL_GPIO_ResetOutputPin
000024  2000              MOVS     r0,#0                 ;59
000026  f7fffffe          BL       IMU_transfer
00002a  4605              MOV      r5,r0                 ;59
00002c  2000              MOVS     r0,#0                 ;60
00002e  f7fffffe          BL       IMU_transfer
000032  4606              MOV      r6,r0                 ;60
000034  2000              MOVS     r0,#0                 ;61
000036  f7fffffe          BL       IMU_transfer
00003a  4680              MOV      r8,r0                 ;61
00003c  2000              MOVS     r0,#0                 ;62
00003e  f7fffffe          BL       IMU_transfer
000042  4607              MOV      r7,r0                 ;62
000044  4814              LDR      r0,|L8.152|
000046  7005              STRB     r5,[r0,#0]            ;65
000048  7046              STRB     r6,[r0,#1]            ;66
00004a  f8808002          STRB     r8,[r0,#2]            ;67
00004e  4601              MOV      r1,r0                 ;68
000050  70cf              STRB     r7,[r1,#3]            ;68
000052  ea452006          ORR      r0,r5,r6,LSL #8       ;71
000056  b204              SXTH     r4,r0                 ;71
000058  f4244000          BIC      r0,r4,#0x8000         ;72
00005c  b204              SXTH     r4,r0                 ;72
00005e  b90c              CBNZ     r4,|L8.100|
000060  2000              MOVS     r0,#0                 ;75
000062  e7d7              B        |L8.20|
                  |L8.100|
000064  1f20              SUBS     r0,r4,#4              ;76
000066  b204              SXTH     r4,r0                 ;76
000068  2200              MOVS     r2,#0                 ;79
00006a  e009              B        |L8.128|
                  |L8.108|
00006c  20ff              MOVS     r0,#0xff              ;81
00006e  f7fffffe          BL       IMU_transfer
000072  4603              MOV      r3,r0                 ;81
000074  2a80              CMP      r2,#0x80              ;82
000076  da01              BGE      |L8.124|
000078  4808              LDR      r0,|L8.156|
00007a  5483              STRB     r3,[r0,r2]            ;83
                  |L8.124|
00007c  1c50              ADDS     r0,r2,#1              ;79
00007e  b282              UXTH     r2,r0                 ;79
                  |L8.128|
000080  42a2              CMP      r2,r4                 ;79
000082  dbf3              BLT      |L8.108|
000084  f44f7180          MOV      r1,#0x100             ;85
000088  4802              LDR      r0,|L8.148|
00008a  3810              SUBS     r0,r0,#0x10           ;85
00008c  f7fffffe          BL       LL_GPIO_SetOutputPin
000090  2001              MOVS     r0,#1                 ;87
000092  e7bf              B        |L8.20|
;;;89     
                          ENDP

                  |L8.148|
                          DCD      0x40020c10
                  |L8.152|
                          DCD      shtpHeader
                  |L8.156|
                          DCD      shtpData

                          AREA ||i.IMU_sendPacket||, CODE, READONLY, ALIGN=2

                  IMU_sendPacket PROC
;;;97     
;;;98     uint8_t IMU_sendPacket(uint8_t channelNumber, uint8_t dataLength)
000000  b570              PUSH     {r4-r6,lr}
;;;99     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;100    	uint8_t packetLength = dataLength + 4; //Add four bytes for the header
000006  1d28              ADDS     r0,r5,#4
000008  b2c6              UXTB     r6,r0
;;;101    	//Wait for BNO080 to indicate it is available for communication
;;;102    	if (IMU_waitForSPI() == 0) return 0; //Something went wrong
00000a  f7fffffe          BL       IMU_waitForSPI
00000e  b908              CBNZ     r0,|L9.20|
000010  2000              MOVS     r0,#0
                  |L9.18|
;;;103    
;;;104    	gpio_reset(APU_NSS);
;;;105    
;;;106    	//Send the 4 byte packet header
;;;107    	IMU_transfer(packetLength & 0xFF);			 //Packet length LSB
;;;108    	IMU_transfer(packetLength >> 8);				 //Packet length MSB
;;;109    	IMU_transfer(channelNumber);					 //Channel number
;;;110    	IMU_transfer(sequenceNumber[channelNumber]++); //Send the sequence number, increments with each packet sent, different counter for each channel
;;;111    
;;;112    	//Send the user's data packet
;;;113    	for (uint8_t i = 0; i < dataLength; i++)
;;;114    	{
;;;115    		IMU_transfer(shtpData[i]);
;;;116    	}
;;;117    	gpio_set(APU_NSS);
;;;118     	return 1;
;;;119    }
000012  bd70              POP      {r4-r6,pc}
                  |L9.20|
000014  f44f7180          MOV      r1,#0x100             ;104
000018  4812              LDR      r0,|L9.100|
00001a  f7fffffe          BL       LL_GPIO_ResetOutputPin
00001e  b2f0              UXTB     r0,r6                 ;107
000020  f7fffffe          BL       IMU_transfer
000024  1230              ASRS     r0,r6,#8              ;108
000026  f7fffffe          BL       IMU_transfer
00002a  4620              MOV      r0,r4                 ;109
00002c  f7fffffe          BL       IMU_transfer
000030  490d              LDR      r1,|L9.104|
000032  5d08              LDRB     r0,[r1,r4]            ;110
000034  5d09              LDRB     r1,[r1,r4]            ;110
000036  1c49              ADDS     r1,r1,#1              ;110
000038  4b0b              LDR      r3,|L9.104|
00003a  5519              STRB     r1,[r3,r4]            ;110
00003c  f7fffffe          BL       IMU_transfer
000040  2200              MOVS     r2,#0                 ;113
000042  e005              B        |L9.80|
                  |L9.68|
000044  4909              LDR      r1,|L9.108|
000046  5c88              LDRB     r0,[r1,r2]            ;115
000048  f7fffffe          BL       IMU_transfer
00004c  1c50              ADDS     r0,r2,#1              ;113
00004e  b2c2              UXTB     r2,r0                 ;113
                  |L9.80|
000050  42aa              CMP      r2,r5                 ;113
000052  dbf7              BLT      |L9.68|
000054  f44f7180          MOV      r1,#0x100             ;117
000058  4802              LDR      r0,|L9.100|
00005a  f7fffffe          BL       LL_GPIO_SetOutputPin
00005e  2001              MOVS     r0,#1                 ;118
000060  e7d7              B        |L9.18|
;;;120    
                          ENDP

000062  0000              DCW      0x0000
                  |L9.100|
                          DCD      0x40020c00
                  |L9.104|
                          DCD      sequenceNumber
                  |L9.108|
                          DCD      shtpData

                          AREA ||i.IMU_setFeatureCommand||, CODE, READONLY, ALIGN=2

                  IMU_setFeatureCommand PROC
;;;306    //Also sets the specific config word. Useful for personal activity classifier
;;;307    void IMU_setFeatureCommand(uint8_t reportID, uint16_t freq, uint32_t specificConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;308    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;309    	int64_t microsBetweenReports = (int64_t)freq * 1000L;
00000a  f44f707a          MOV      r0,#0x3e8
00000e  fba84000          UMULL    r4,r0,r8,r0
000012  4605              MOV      r5,r0
;;;310    
;;;311    	shtpData[0] = SHTP_REPORT_SET_FEATURE_COMMAND;	 //Set feature command. Reference page 55
000014  20fd              MOVS     r0,#0xfd
000016  4913              LDR      r1,|L10.100|
000018  7008              STRB     r0,[r1,#0]
;;;312    	shtpData[1] = reportID;							   //Feature Report ID. 0x01 = Accelerometer, 0x05 = Rotation vector
00001a  4608              MOV      r0,r1
00001c  7047              STRB     r7,[r0,#1]
;;;313    	shtpData[2] = 0;								   //Feature flags
00001e  2000              MOVS     r0,#0
000020  7088              STRB     r0,[r1,#2]
;;;314    	shtpData[3] = 0;								   //Change sensitivity (LSB)
000022  70c8              STRB     r0,[r1,#3]
;;;315    	shtpData[4] = 0;								   //Change sensitivity (MSB)
000024  7108              STRB     r0,[r1,#4]
;;;316    	shtpData[5] = (microsBetweenReports >> 0) & 0xFF;  //Report interval (LSB) in microseconds. 0x7A120 = 500ms
000026  714c              STRB     r4,[r1,#5]
;;;317    	shtpData[6] = (microsBetweenReports >> 8) & 0xFF;  //Report interval
000028  0a20              LSRS     r0,r4,#8
00002a  ea406005          ORR      r0,r0,r5,LSL #24
00002e  7188              STRB     r0,[r1,#6]
;;;318    	shtpData[7] = (microsBetweenReports >> 16) & 0xFF; //Report interval
000030  0c20              LSRS     r0,r4,#16
000032  ea404005          ORR      r0,r0,r5,LSL #16
000036  71c8              STRB     r0,[r1,#7]
;;;319    	shtpData[8] = (microsBetweenReports >> 24) & 0xFF; //Report interval (MSB)
000038  0e20              LSRS     r0,r4,#24
00003a  ea402005          ORR      r0,r0,r5,LSL #8
00003e  7208              STRB     r0,[r1,#8]
;;;320    	shtpData[9] = 0;								   //Batch Interval (LSB)
000040  2000              MOVS     r0,#0
000042  7248              STRB     r0,[r1,#9]
;;;321    	shtpData[10] = 0;								   //Batch Interval
000044  7288              STRB     r0,[r1,#0xa]
;;;322    	shtpData[11] = 0;								   //Batch Interval
000046  72c8              STRB     r0,[r1,#0xb]
;;;323    	shtpData[12] = 0;								   //Batch Interval (MSB)
000048  7308              STRB     r0,[r1,#0xc]
;;;324    	shtpData[13] = (specificConfig >> 0) & 0xFF;	   //Sensor-specific config (LSB)
00004a  734e              STRB     r6,[r1,#0xd]
;;;325    	shtpData[14] = (specificConfig >> 8) & 0xFF;	   //Sensor-specific config
00004c  0a30              LSRS     r0,r6,#8
00004e  7388              STRB     r0,[r1,#0xe]
;;;326    	shtpData[15] = (specificConfig >> 16) & 0xFF;	  //Sensor-specific config
000050  0c30              LSRS     r0,r6,#16
000052  73c8              STRB     r0,[r1,#0xf]
;;;327    	shtpData[16] = (specificConfig >> 24) & 0xFF;	  //Sensor-specific config (MSB)
000054  0e30              LSRS     r0,r6,#24
000056  7408              STRB     r0,[r1,#0x10]
;;;328    
;;;329    	//Transmit packet on channel 2, 17 bytes
;;;330    	IMU_sendPacket(CHANNEL_CONTROL, 17);
000058  2111              MOVS     r1,#0x11
00005a  2002              MOVS     r0,#2
00005c  f7fffffe          BL       IMU_sendPacket
;;;331    }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;332    
                          ENDP

                  |L10.100|
                          DCD      shtpData

                          AREA ||i.IMU_transfer||, CODE, READONLY, ALIGN=2

                  IMU_transfer PROC
;;;42     
;;;43     uint8_t IMU_transfer(uint8_t byte) {
000000  4601              MOV      r1,r0
;;;44     	while (!(IMU_SPI->SR & SPI_SR_TXE));
000002  bf00              NOP      
                  |L11.4|
000004  480b              LDR      r0,|L11.52|
000006  6800              LDR      r0,[r0,#0]
000008  f0000002          AND      r0,r0,#2
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L11.4|
;;;45     	LL_SPI_TransmitData8(IMU_SPI,byte);
000010  bf00              NOP      
000012  4808              LDR      r0,|L11.52|
000014  3808              SUBS     r0,r0,#8
000016  60c1              STR      r1,[r0,#0xc]
000018  bf00              NOP      
;;;46     	while (!(IMU_SPI->SR & SPI_SR_RXNE));
00001a  bf00              NOP      
                  |L11.28|
00001c  4805              LDR      r0,|L11.52|
00001e  6800              LDR      r0,[r0,#0]
000020  f0000001          AND      r0,r0,#1
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L11.28|
;;;47     	return LL_SPI_ReceiveData8(IMU_SPI);
000028  bf00              NOP      
00002a  4802              LDR      r0,|L11.52|
00002c  3808              SUBS     r0,r0,#8
00002e  68c0              LDR      r0,[r0,#0xc]
000030  b2c0              UXTB     r0,r0
;;;48     }
000032  4770              BX       lr
;;;49     
                          ENDP

                  |L11.52|
                          DCD      0x40003808

                          AREA ||i.IMU_waitForSPI||, CODE, READONLY, ALIGN=2

                  IMU_waitForSPI PROC
;;;89     
;;;90     uint8_t IMU_waitForSPI(void){
000000  2100              MOVS     r1,#0
;;;91     	for (uint8_t i=0; i<125;i++){
000002  e014              B        |L12.46|
                  |L12.4|
;;;92     		if (!gpio_read(APU_IRQ)) return 1;
000004  480c              LDR      r0,|L12.56|
000006  6800              LDR      r0,[r0,#0]
000008  f4007000          AND      r0,r0,#0x200
00000c  f5b07f00          CMP      r0,#0x200
000010  d001              BEQ      |L12.22|
000012  2001              MOVS     r0,#1
                  |L12.20|
;;;93     		delay(1);
;;;94     	}
;;;95     	return 0;
;;;96     }
000014  4770              BX       lr
                  |L12.22|
000016  2001              MOVS     r0,#1                 ;93
000018  4a08              LDR      r2,|L12.60|
00001a  6010              STR      r0,[r2,#0]            ;93  ; __delay
00001c  bf00              NOP                            ;93
00001e  bf00              NOP                            ;93
                  |L12.32|
000020  4a06              LDR      r2,|L12.60|
000022  6812              LDR      r2,[r2,#0]            ;93  ; __delay
000024  2a00              CMP      r2,#0                 ;93
000026  d1fb              BNE      |L12.32|
000028  bf00              NOP                            ;93
00002a  1c48              ADDS     r0,r1,#1              ;91
00002c  b2c1              UXTB     r1,r0                 ;91
                  |L12.46|
00002e  297d              CMP      r1,#0x7d              ;91
000030  dbe8              BLT      |L12.4|
000032  2000              MOVS     r0,#0                 ;95
000034  e7ee              B        |L12.20|
;;;97     
                          ENDP

000036  0000              DCW      0x0000
                  |L12.56|
                          DCD      0x40020c10
                  |L12.60|
                          DCD      __delay

                          AREA ||i.LL_GPIO_ResetOutputPin||, CODE, READONLY, ALIGN=1

                  LL_GPIO_ResetOutputPin PROC
;;;926      */
;;;927    __STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
000000  040a              LSLS     r2,r1,#16
;;;928    {
;;;929      WRITE_REG(GPIOx->BSRR, (PinMask << 16));
000002  6182              STR      r2,[r0,#0x18]
;;;930    }
000004  4770              BX       lr
;;;931    
                          ENDP


                          AREA ||i.LL_GPIO_SetOutputPin||, CODE, READONLY, ALIGN=1

                  LL_GPIO_SetOutputPin PROC
;;;897      */
;;;898    __STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
000000  6181              STR      r1,[r0,#0x18]
;;;899    {
;;;900      WRITE_REG(GPIOx->BSRR, PinMask);
;;;901    }
000002  4770              BX       lr
;;;902    
                          ENDP


                          AREA ||i.getAccelFlick||, CODE, READONLY, ALIGN=2

                  getAccelFlick PROC
;;;436    
;;;437    uint8_t getAccelFlick(void) {
000000  b510              PUSH     {r4,lr}
;;;438    	// float x=getAccelX(),y=getAccelY(),z=getAccelZ();
;;;439    	// float mag = square(x)+square(y)+square(z);
;;;440    	// static uint32_t last_ticks = 0;
;;;441    	// if (imu_control && mag > 110 && square(y)>65) {
;;;442    	// 	last_ticks = get_ticks();
;;;443    	// 	return 1;
;;;444    	// }
;;;445    	// if (get_ticks()-last_ticks<200) return 1;
;;;446    	// if (getAccelY())
;;;447    	if (imu_control && getRoll()<-75.0f && getRoll() > -115.0f) return 1;
000002  480c              LDR      r0,|L15.52|
000004  7800              LDRB     r0,[r0,#0]  ; imu_control
000006  b198              CBZ      r0,|L15.48|
000008  f7fffffe          BL       getRoll
00000c  eddf0a0a          VLDR     s1,|L15.56|
000010  eeb40ae0          VCMPE.F32 s0,s1
000014  eef1fa10          VMRS     APSR_nzcv,FPSCR
000018  d20a              BCS      |L15.48|
00001a  f7fffffe          BL       getRoll
00001e  eddf0a07          VLDR     s1,|L15.60|
000022  eeb40ae0          VCMPE.F32 s0,s1
000026  eef1fa10          VMRS     APSR_nzcv,FPSCR
00002a  dd01              BLE      |L15.48|
00002c  2001              MOVS     r0,#1
                  |L15.46|
;;;448    	return 0;
;;;449    }
00002e  bd10              POP      {r4,pc}
                  |L15.48|
000030  2000              MOVS     r0,#0                 ;448
000032  e7fc              B        |L15.46|
                          ENDP

                  |L15.52|
                          DCD      imu_control
                  |L15.56|
000038  c2960000          DCFS     0xc2960000 ; -75
                  |L15.60|
00003c  c2e60000          DCFS     0xc2e60000 ; -115

                          AREA ||i.getAccelLeft||, CODE, READONLY, ALIGN=2

                  getAccelLeft PROC
;;;425    }
;;;426    uint8_t getAccelLeft(void) {
000000  b510              PUSH     {r4,lr}
;;;427        // if (imu_control && getAccelX()<-5.0f) return 1;
;;;428        if (imu_control && getPitch()>30.0f) return 1;
000002  4808              LDR      r0,|L16.36|
000004  7800              LDRB     r0,[r0,#0]  ; imu_control
000006  b150              CBZ      r0,|L16.30|
000008  f7fffffe          BL       getPitch
00000c  eef30a0e          VMOV.F32 s1,#30.00000000
000010  eeb40ae0          VCMPE.F32 s0,s1
000014  eef1fa10          VMRS     APSR_nzcv,FPSCR
000018  dd01              BLE      |L16.30|
00001a  2001              MOVS     r0,#1
                  |L16.28|
;;;429        return 0;
;;;430    }
00001c  bd10              POP      {r4,pc}
                  |L16.30|
00001e  2000              MOVS     r0,#0                 ;429
000020  e7fc              B        |L16.28|
;;;431    uint8_t getAccelRight(void) {
                          ENDP

000022  0000              DCW      0x0000
                  |L16.36|
                          DCD      imu_control

                          AREA ||i.getAccelRight||, CODE, READONLY, ALIGN=2

                  getAccelRight PROC
;;;430    }
;;;431    uint8_t getAccelRight(void) {
000000  b510              PUSH     {r4,lr}
;;;432        // if (imu_control && getAccelX()>5.0f) return 1;
;;;433        if (imu_control && getPitch()<-30.0f) return 1;
000002  4808              LDR      r0,|L17.36|
000004  7800              LDRB     r0,[r0,#0]  ; imu_control
000006  b150              CBZ      r0,|L17.30|
000008  f7fffffe          BL       getPitch
00000c  eefb0a0e          VMOV.F32 s1,#-30.00000000
000010  eeb40ae0          VCMPE.F32 s0,s1
000014  eef1fa10          VMRS     APSR_nzcv,FPSCR
000018  d201              BCS      |L17.30|
00001a  2001              MOVS     r0,#1
                  |L17.28|
;;;434        return 0;
;;;435    }
00001c  bd10              POP      {r4,pc}
                  |L17.30|
00001e  2000              MOVS     r0,#0                 ;434
000020  e7fc              B        |L17.28|
;;;436    
                          ENDP

000022  0000              DCW      0x0000
                  |L17.36|
                          DCD      imu_control

                          AREA ||i.getAccelX||, CODE, READONLY, ALIGN=2

                  getAccelX PROC
;;;413    
;;;414    float getAccelX(void) {return  qToFloat(rawAccelX, accelerometer_Q1); }
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L18.20|
000004  7801              LDRB     r1,[r0,#0]  ; accelerometer_Q1
000006  4804              LDR      r0,|L18.24|
000008  8800              LDRH     r0,[r0,#0]  ; rawAccelX
00000a  b200              SXTH     r0,r0
00000c  f7fffffe          BL       qToFloat
000010  bd10              POP      {r4,pc}
;;;415    float getAccelY(void) {return qToFloat(rawAccelY, accelerometer_Q1); }
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      accelerometer_Q1
                  |L18.24|
                          DCD      rawAccelX

                          AREA ||i.getAccelY||, CODE, READONLY, ALIGN=2

                  getAccelY PROC
;;;414    float getAccelX(void) {return  qToFloat(rawAccelX, accelerometer_Q1); }
;;;415    float getAccelY(void) {return qToFloat(rawAccelY, accelerometer_Q1); }
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L19.20|
000004  7801              LDRB     r1,[r0,#0]  ; accelerometer_Q1
000006  4804              LDR      r0,|L19.24|
000008  8800              LDRH     r0,[r0,#0]  ; rawAccelY
00000a  b200              SXTH     r0,r0
00000c  f7fffffe          BL       qToFloat
000010  bd10              POP      {r4,pc}
;;;416    float getAccelZ(void) {return qToFloat(rawAccelZ, accelerometer_Q1); }
                          ENDP

000012  0000              DCW      0x0000
                  |L19.20|
                          DCD      accelerometer_Q1
                  |L19.24|
                          DCD      rawAccelY

                          AREA ||i.getAccelZ||, CODE, READONLY, ALIGN=2

                  getAccelZ PROC
;;;415    float getAccelY(void) {return qToFloat(rawAccelY, accelerometer_Q1); }
;;;416    float getAccelZ(void) {return qToFloat(rawAccelZ, accelerometer_Q1); }
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L20.20|
000004  7801              LDRB     r1,[r0,#0]  ; accelerometer_Q1
000006  4804              LDR      r0,|L20.24|
000008  8800              LDRH     r0,[r0,#0]  ; rawAccelZ
00000a  b200              SXTH     r0,r0
00000c  f7fffffe          BL       qToFloat
000010  bd10              POP      {r4,pc}
;;;417    
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      accelerometer_Q1
                  |L20.24|
                          DCD      rawAccelZ

                          AREA ||i.getGyroX||, CODE, READONLY, ALIGN=2

                  getGyroX PROC
;;;372    //Return the gyro component
;;;373    float getGyroX(void) {return qToFloat(rawGyroX, gyro_Q1); }
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L21.20|
000004  7801              LDRB     r1,[r0,#0]  ; gyro_Q1
000006  4804              LDR      r0,|L21.24|
000008  8800              LDRH     r0,[r0,#0]  ; rawGyroX
00000a  b200              SXTH     r0,r0
00000c  f7fffffe          BL       qToFloat
000010  bd10              POP      {r4,pc}
;;;374    float getGyroY(void) {return qToFloat(rawGyroY, gyro_Q1); }
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      gyro_Q1
                  |L21.24|
                          DCD      rawGyroX

                          AREA ||i.getGyroY||, CODE, READONLY, ALIGN=2

                  getGyroY PROC
;;;373    float getGyroX(void) {return qToFloat(rawGyroX, gyro_Q1); }
;;;374    float getGyroY(void) {return qToFloat(rawGyroY, gyro_Q1); }
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L22.20|
000004  7801              LDRB     r1,[r0,#0]  ; gyro_Q1
000006  4804              LDR      r0,|L22.24|
000008  8800              LDRH     r0,[r0,#0]  ; rawGyroY
00000a  b200              SXTH     r0,r0
00000c  f7fffffe          BL       qToFloat
000010  bd10              POP      {r4,pc}
;;;375    float getGyroZ(void) {return qToFloat(rawGyroZ, gyro_Q1); }
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      gyro_Q1
                  |L22.24|
                          DCD      rawGyroY

                          AREA ||i.getGyroZ||, CODE, READONLY, ALIGN=2

                  getGyroZ PROC
;;;374    float getGyroY(void) {return qToFloat(rawGyroY, gyro_Q1); }
;;;375    float getGyroZ(void) {return qToFloat(rawGyroZ, gyro_Q1); }
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L23.20|
000004  7801              LDRB     r1,[r0,#0]  ; gyro_Q1
000006  4804              LDR      r0,|L23.24|
000008  8800              LDRH     r0,[r0,#0]  ; rawGyroZ
00000a  b200              SXTH     r0,r0
00000c  f7fffffe          BL       qToFloat
000010  bd10              POP      {r4,pc}
;;;376    // //Return the gyro component
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      gyro_Q1
                  |L23.24|
                          DCD      rawGyroZ

                          AREA ||i.getIMUControl||, CODE, READONLY, ALIGN=2

                  getIMUControl PROC
;;;422    }
;;;423    uint8_t getIMUControl(void){ 
000000  4801              LDR      r0,|L24.8|
;;;424    	return imu_control;
000002  7800              LDRB     r0,[r0,#0]  ; imu_control
;;;425    }
000004  4770              BX       lr
;;;426    uint8_t getAccelLeft(void) {
                          ENDP

000006  0000              DCW      0x0000
                  |L24.8|
                          DCD      imu_control

                          AREA ||i.getPitch||, CODE, READONLY, ALIGN=2

                  getPitch PROC
;;;396    }
;;;397    float getPitch(void) {
000000  b510              PUSH     {r4,lr}
000002  ed2d8b0c          VPUSH    {d8-d13}
000006  b084              SUB      sp,sp,#0x10
;;;398    	float q1 = getQuatReal(), q2 = getQuatI(), q3 = getQuatJ(), q4 = getQuatK();
000008  f7fffffe          BL       getQuatReal
00000c  eeb08a40          VMOV.F32 s16,s0
000010  f7fffffe          BL       getQuatI
000014  eef08a40          VMOV.F32 s17,s0
000018  f7fffffe          BL       getQuatJ
00001c  eeb09a40          VMOV.F32 s18,s0
000020  f7fffffe          BL       getQuatK
000024  eef09a40          VMOV.F32 s19,s0
;;;399    	float sinp = +2.0f * (q1* q3- q4 * q2);
000028  ee280a09          VMUL.F32 s0,s16,s18
00002c  ee090ae8          VMLS.F32 s0,s19,s17
000030  eef00a00          VMOV.F32 s1,#2.00000000
000034  ee200a20          VMUL.F32 s0,s0,s1
000038  ee104a10          VMOV     r4,s0
;;;400    	if (fabs(sinp) >= 1.0f)
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       __aeabi_f2d
000042  ec410b1b          VMOV     d11,r0,r1
000046  eeb00a4b          VMOV.F32 s0,s22
00004a  eef00a6b          VMOV.F32 s1,s23
00004e  f7fffffe          BL       __hardfp_fabs
000052  eeb0aa40          VMOV.F32 s20,s0
000056  eef0aa60          VMOV.F32 s21,s1
00005a  ed9f0b2e          VLDR     d0,|L25.276|
00005e  ec532b10          VMOV     r2,r3,d0
000062  ec510b1a          VMOV     r0,r1,d10
000066  f7fffffe          BL       __aeabi_cdrcmple
00006a  d82d              BHI      |L25.200|
;;;401    		return copysign(3.1415926535897932384626f/2.0f, sinp)*CONVERT_TO_DEGS; // use 90 degrees if out of range
00006c  ed9f0b2b          VLDR     d0,|L25.284|
000070  ed8d0b00          VSTR     d0,[sp,#0]
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       __aeabi_f2d
00007a  e9cd0102          STRD     r0,r1,[sp,#8]
00007e  9901              LDR      r1,[sp,#4]
000080  9803              LDR      r0,[sp,#0xc]
000082  f361001e          BFI      r0,r1,#0,#31
000086  9001              STR      r0,[sp,#4]
000088  ed9d0b00          VLDR     d0,[sp,#0]
00008c  eeb0ca40          VMOV.F32 s24,s0
000090  eef0ca60          VMOV.F32 s25,s1
000094  ed9f0b23          VLDR     d0,|L25.292|
000098  ec532b10          VMOV     r2,r3,d0
00009c  ec510b1c          VMOV     r0,r1,d12
0000a0  f7fffffe          BL       __aeabi_dmul
0000a4  ec410b1b          VMOV     d11,r0,r1
0000a8  ed9f0b20          VLDR     d0,|L25.300|
0000ac  ec532b10          VMOV     r2,r3,d0
0000b0  f7fffffe          BL       __aeabi_ddiv
0000b4  ec410b1a          VMOV     d10,r0,r1
0000b8  f7fffffe          BL       __aeabi_d2f
0000bc  ee000a10          VMOV     s0,r0
                  |L25.192|
;;;402    	else
;;;403    		return asin(sinp)*CONVERT_TO_DEGS;
;;;404    }
0000c0  b004              ADD      sp,sp,#0x10
0000c2  ecbd8b0c          VPOP     {d8-d13}
0000c6  bd10              POP      {r4,pc}
                  |L25.200|
0000c8  4620              MOV      r0,r4                 ;403
0000ca  f7fffffe          BL       __aeabi_f2d
0000ce  ec410b1d          VMOV     d13,r0,r1             ;403
0000d2  eeb00a4d          VMOV.F32 s0,s26                ;403
0000d6  eef00a6d          VMOV.F32 s1,s27                ;403
0000da  f7fffffe          BL       __hardfp_asin
0000de  eeb0ca40          VMOV.F32 s24,s0                ;403
0000e2  eef0ca60          VMOV.F32 s25,s1                ;403
0000e6  ed9f0b0f          VLDR     d0,|L25.292|
0000ea  ec532b10          VMOV     r2,r3,d0              ;403
0000ee  ec510b1c          VMOV     r0,r1,d12             ;403
0000f2  f7fffffe          BL       __aeabi_dmul
0000f6  ec410b1b          VMOV     d11,r0,r1             ;403
0000fa  ed9f0b0c          VLDR     d0,|L25.300|
0000fe  ec532b10          VMOV     r2,r3,d0              ;403
000102  f7fffffe          BL       __aeabi_ddiv
000106  ec410b1a          VMOV     d10,r0,r1             ;403
00010a  f7fffffe          BL       __aeabi_d2f
00010e  ee000a10          VMOV     s0,r0                 ;403
000112  e7d5              B        |L25.192|
;;;405    float getYaw(void){
                          ENDP

                  |L25.276|
000114  00000000          DCFD     0x3ff0000000000000 ; 1
000118  3ff00000
                  |L25.284|
00011c  60000000          DCFD     0x3ff921fb60000000 ; 1.5707963705062866
000120  3ff921fb
                  |L25.292|
000124  00000000          DCFD     0x4066800000000000 ; 180
000128  40668000
                  |L25.300|
00012c  60000000          DCFD     0x400921fb60000000 ; 3.1415927410125732
000130  400921fb

                          AREA ||i.getQuatI||, CODE, READONLY, ALIGN=2

                  getQuatI PROC
;;;377    // uint8_t getGyroAccuracy(void) {return gyroAccuracy; }
;;;378    float getQuatI(void) {return qToFloat(rawQuatI, rotationVector_Q1); }
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L26.20|
000004  7801              LDRB     r1,[r0,#0]  ; rotationVector_Q1
000006  4804              LDR      r0,|L26.24|
000008  8800              LDRH     r0,[r0,#0]  ; rawQuatI
00000a  b200              SXTH     r0,r0
00000c  f7fffffe          BL       qToFloat
000010  bd10              POP      {r4,pc}
;;;379    float getQuatJ(void) {return  qToFloat(rawQuatJ, rotationVector_Q1); }
                          ENDP

000012  0000              DCW      0x0000
                  |L26.20|
                          DCD      rotationVector_Q1
                  |L26.24|
                          DCD      rawQuatI

                          AREA ||i.getQuatJ||, CODE, READONLY, ALIGN=2

                  getQuatJ PROC
;;;378    float getQuatI(void) {return qToFloat(rawQuatI, rotationVector_Q1); }
;;;379    float getQuatJ(void) {return  qToFloat(rawQuatJ, rotationVector_Q1); }
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L27.20|
000004  7801              LDRB     r1,[r0,#0]  ; rotationVector_Q1
000006  4804              LDR      r0,|L27.24|
000008  8800              LDRH     r0,[r0,#0]  ; rawQuatJ
00000a  b200              SXTH     r0,r0
00000c  f7fffffe          BL       qToFloat
000010  bd10              POP      {r4,pc}
;;;380    float getQuatK(void) {return qToFloat(rawQuatK, rotationVector_Q1); }
                          ENDP

000012  0000              DCW      0x0000
                  |L27.20|
                          DCD      rotationVector_Q1
                  |L27.24|
                          DCD      rawQuatJ

                          AREA ||i.getQuatK||, CODE, READONLY, ALIGN=2

                  getQuatK PROC
;;;379    float getQuatJ(void) {return  qToFloat(rawQuatJ, rotationVector_Q1); }
;;;380    float getQuatK(void) {return qToFloat(rawQuatK, rotationVector_Q1); }
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L28.20|
000004  7801              LDRB     r1,[r0,#0]  ; rotationVector_Q1
000006  4804              LDR      r0,|L28.24|
000008  8800              LDRH     r0,[r0,#0]  ; rawQuatK
00000a  b200              SXTH     r0,r0
00000c  f7fffffe          BL       qToFloat
000010  bd10              POP      {r4,pc}
;;;381    float getQuatReal(void) {return qToFloat(rawQuatReal, rotationVector_Q1); }
                          ENDP

000012  0000              DCW      0x0000
                  |L28.20|
                          DCD      rotationVector_Q1
                  |L28.24|
                          DCD      rawQuatK

                          AREA ||i.getQuatReal||, CODE, READONLY, ALIGN=2

                  getQuatReal PROC
;;;380    float getQuatK(void) {return qToFloat(rawQuatK, rotationVector_Q1); }
;;;381    float getQuatReal(void) {return qToFloat(rawQuatReal, rotationVector_Q1); }
000000  b510              PUSH     {r4,lr}
000002  4804              LDR      r0,|L29.20|
000004  7801              LDRB     r1,[r0,#0]  ; rotationVector_Q1
000006  4804              LDR      r0,|L29.24|
000008  8800              LDRH     r0,[r0,#0]  ; rawQuatReal
00000a  b200              SXTH     r0,r0
00000c  f7fffffe          BL       qToFloat
000010  bd10              POP      {r4,pc}
;;;382    
                          ENDP

000012  0000              DCW      0x0000
                  |L29.20|
                          DCD      rotationVector_Q1
                  |L29.24|
                          DCD      rawQuatReal

                          AREA ||i.getRoll||, CODE, READONLY, ALIGN=2

                  getRoll PROC
;;;387    }
;;;388    float getRoll(void) {
000000  b570              PUSH     {r4-r6,lr}
000002  ed2d8b10          VPUSH    {d8-d15}
;;;389    	float q1 = getQuatReal(), q2 = getQuatI(), q3 = getQuatJ(), q4 = getQuatK();
000006  f7fffffe          BL       getQuatReal
00000a  eeb08a40          VMOV.F32 s16,s0
00000e  f7fffffe          BL       getQuatI
000012  eef08a40          VMOV.F32 s17,s0
000016  f7fffffe          BL       getQuatJ
00001a  eeb09a40          VMOV.F32 s18,s0
00001e  f7fffffe          BL       getQuatK
000022  eef09a40          VMOV.F32 s19,s0
;;;390    	float q12_q32 = square(q1) - square(q3);
000026  eeb00a48          VMOV.F32 s0,s16
00002a  ee600a00          VMUL.F32 s1,s0,s0
00002e  eeb00a49          VMOV.F32 s0,s18
000032  ee201a00          VMUL.F32 s2,s0,s0
000036  ee300ac1          VSUB.F32 s0,s1,s2
00003a  eeb0fa40          VMOV.F32 s30,s0
;;;391    	float q22_q42 = square(q2) - square(q4);
00003e  eeb00a68          VMOV.F32 s0,s17
000042  ee600a00          VMUL.F32 s1,s0,s0
000046  eeb00a69          VMOV.F32 s0,s19
00004a  ee201a00          VMUL.F32 s2,s0,s0
00004e  ee300ac1          VSUB.F32 s0,s1,s2
000052  eef0fa40          VMOV.F32 s31,s0
;;;392    	float sinr_cosp = +2.0f * (q1* q2+ q3* q4);
000056  ee280a28          VMUL.F32 s0,s16,s17
00005a  ee090a29          VMLA.F32 s0,s18,s19
00005e  eef00a00          VMOV.F32 s1,#2.00000000
000062  ee200a20          VMUL.F32 s0,s0,s1
000066  ee104a10          VMOV     r4,s0
;;;393    	float cosr_cosp = q12_q32 - q22_q42;
00006a  ee3f0a6f          VSUB.F32 s0,s30,s31
00006e  ee105a10          VMOV     r5,s0
;;;394    	return atan2(sinr_cosp, cosr_cosp)*CONVERT_TO_DEGS;
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       __aeabi_f2d
000078  ec410b1d          VMOV     d13,r0,r1
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       __aeabi_f2d
000082  ec410b1e          VMOV     d14,r0,r1
000086  eeb01a4d          VMOV.F32 s2,s26
00008a  eef01a6d          VMOV.F32 s3,s27
00008e  eeb00a4e          VMOV.F32 s0,s28
000092  eef00a6e          VMOV.F32 s1,s29
000096  f7fffffe          BL       __hardfp_atan2
00009a  eeb0ca40          VMOV.F32 s24,s0
00009e  eef0ca60          VMOV.F32 s25,s1
0000a2  ed9f0b0c          VLDR     d0,|L30.212|
0000a6  ec532b10          VMOV     r2,r3,d0
0000aa  ec510b1c          VMOV     r0,r1,d12
0000ae  f7fffffe          BL       __aeabi_dmul
0000b2  ec410b1b          VMOV     d11,r0,r1
0000b6  ed9f0b09          VLDR     d0,|L30.220|
0000ba  ec532b10          VMOV     r2,r3,d0
0000be  f7fffffe          BL       __aeabi_ddiv
0000c2  ec410b1a          VMOV     d10,r0,r1
0000c6  f7fffffe          BL       __aeabi_d2f
0000ca  ee000a10          VMOV     s0,r0
;;;395    
;;;396    }
0000ce  ecbd8b10          VPOP     {d8-d15}
0000d2  bd70              POP      {r4-r6,pc}
;;;397    float getPitch(void) {
                          ENDP

                  |L30.212|
0000d4  00000000          DCFD     0x4066800000000000 ; 180
0000d8  40668000
                  |L30.220|
0000dc  60000000          DCFD     0x400921fb60000000 ; 3.1415927410125732
0000e0  400921fb

                          AREA ||i.getYaw||, CODE, READONLY, ALIGN=2

                  getYaw PROC
;;;404    }
;;;405    float getYaw(void){
000000  b570              PUSH     {r4-r6,lr}
000002  ed2d8b10          VPUSH    {d8-d15}
;;;406    	float q1 = getQuatReal(), q2 = getQuatI(), q3 = getQuatJ(), q4 = getQuatK();
000006  f7fffffe          BL       getQuatReal
00000a  eeb08a40          VMOV.F32 s16,s0
00000e  f7fffffe          BL       getQuatI
000012  eef08a40          VMOV.F32 s17,s0
000016  f7fffffe          BL       getQuatJ
00001a  eeb09a40          VMOV.F32 s18,s0
00001e  f7fffffe          BL       getQuatK
000022  eef09a40          VMOV.F32 s19,s0
;;;407    	float q12_q32 = square(q1) - square(q3);
000026  eeb00a48          VMOV.F32 s0,s16
00002a  ee600a00          VMUL.F32 s1,s0,s0
00002e  eeb00a49          VMOV.F32 s0,s18
000032  ee201a00          VMUL.F32 s2,s0,s0
000036  ee300ac1          VSUB.F32 s0,s1,s2
00003a  eeb0fa40          VMOV.F32 s30,s0
;;;408    	float q22_q42 = square(q2) - square(q4);
00003e  eeb00a68          VMOV.F32 s0,s17
000042  ee600a00          VMUL.F32 s1,s0,s0
000046  eeb00a69          VMOV.F32 s0,s19
00004a  ee201a00          VMUL.F32 s2,s0,s0
00004e  ee300ac1          VSUB.F32 s0,s1,s2
000052  eef0fa40          VMOV.F32 s31,s0
;;;409    	float siny_cosp = +2.0f * (q1* q4 + q2* q3);
000056  ee280a29          VMUL.F32 s0,s16,s19
00005a  ee080a89          VMLA.F32 s0,s17,s18
00005e  eef00a00          VMOV.F32 s1,#2.00000000
000062  ee200a20          VMUL.F32 s0,s0,s1
000066  ee104a10          VMOV     r4,s0
;;;410    	float cosy_cosp = q12_q32 - q22_q42;  
00006a  ee3f0a6f          VSUB.F32 s0,s30,s31
00006e  ee105a10          VMOV     r5,s0
;;;411    	return atan2(siny_cosp, cosy_cosp)*CONVERT_TO_DEGS;
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       __aeabi_f2d
000078  ec410b1d          VMOV     d13,r0,r1
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       __aeabi_f2d
000082  ec410b1e          VMOV     d14,r0,r1
000086  eeb01a4d          VMOV.F32 s2,s26
00008a  eef01a6d          VMOV.F32 s3,s27
00008e  eeb00a4e          VMOV.F32 s0,s28
000092  eef00a6e          VMOV.F32 s1,s29
000096  f7fffffe          BL       __hardfp_atan2
00009a  eeb0ca40          VMOV.F32 s24,s0
00009e  eef0ca60          VMOV.F32 s25,s1
0000a2  ed9f0b0c          VLDR     d0,|L31.212|
0000a6  ec532b10          VMOV     r2,r3,d0
0000aa  ec510b1c          VMOV     r0,r1,d12
0000ae  f7fffffe          BL       __aeabi_dmul
0000b2  ec410b1b          VMOV     d11,r0,r1
0000b6  ed9f0b09          VLDR     d0,|L31.220|
0000ba  ec532b10          VMOV     r2,r3,d0
0000be  f7fffffe          BL       __aeabi_ddiv
0000c2  ec410b1a          VMOV     d10,r0,r1
0000c6  f7fffffe          BL       __aeabi_d2f
0000ca  ee000a10          VMOV     s0,r0
;;;412    }
0000ce  ecbd8b10          VPOP     {d8-d15}
0000d2  bd70              POP      {r4-r6,pc}
;;;413    
                          ENDP

                  |L31.212|
0000d4  00000000          DCFD     0x4066800000000000 ; 180
0000d8  40668000
                  |L31.220|
0000dc  60000000          DCFD     0x400921fb60000000 ; 3.1415927410125732
0000e0  400921fb

                          AREA ||i.qToFloat||, CODE, READONLY, ALIGN=2

                  qToFloat PROC
;;;297    
;;;298    float qToFloat(int16_t fixedPointValue, uint8_t qPoint)
000000  b570              PUSH     {r4-r6,lr}
;;;299    {
000002  ed2d8b0a          VPUSH    {d8-d12}
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;300    	float qFloat = fixedPointValue;
00000a  ee004a10          VMOV     s0,r4
00000e  eeb80ac0          VCVT.F32.S32 s0,s0
000012  eeb08a40          VMOV.F32 s16,s0
;;;301    	qFloat *= pow(2, qPoint * -1);
000016  4268              RSBS     r0,r5,#0
000018  f7fffffe          BL       __aeabi_i2d
00001c  ec410b1c          VMOV     d12,r0,r1
000020  eeb01a4c          VMOV.F32 s2,s24
000024  eef01a6c          VMOV.F32 s3,s25
000028  ed9f0b0e          VLDR     d0,|L32.100|
00002c  f7fffffe          BL       __hardfp_pow
000030  eeb0aa40          VMOV.F32 s20,s0
000034  eef0aa60          VMOV.F32 s21,s1
000038  ee180a10          VMOV     r0,s16
00003c  f7fffffe          BL       __aeabi_f2d
000040  ec410b1b          VMOV     d11,r0,r1
000044  ec532b1a          VMOV     r2,r3,d10
000048  f7fffffe          BL       __aeabi_dmul
00004c  ec410b19          VMOV     d9,r0,r1
000050  f7fffffe          BL       __aeabi_d2f
000054  ee080a10          VMOV     s16,r0
;;;302    	return (qFloat);
000058  eeb00a48          VMOV.F32 s0,s16
;;;303    }
00005c  ecbd8b0a          VPOP     {d8-d12}
000060  bd70              POP      {r4-r6,pc}
;;;304    
                          ENDP

000062  0000              DCW      0x0000
                  |L32.100|
000064  00000000          DCFD     0x4000000000000000 ; 2
000068  40000000

                          AREA ||i.toggleIMUControl||, CODE, READONLY, ALIGN=2

                  toggleIMUControl PROC
;;;418    static uint8_t imu_control = 0;
;;;419    uint8_t toggleIMUControl(void){
000000  4805              LDR      r0,|L33.24|
;;;420    	imu_control = !imu_control;
000002  7800              LDRB     r0,[r0,#0]  ; imu_control
000004  b908              CBNZ     r0,|L33.10|
000006  2001              MOVS     r0,#1
000008  e000              B        |L33.12|
                  |L33.10|
00000a  2000              MOVS     r0,#0
                  |L33.12|
00000c  4902              LDR      r1,|L33.24|
00000e  7008              STRB     r0,[r1,#0]
;;;421    	return imu_control;
000010  4608              MOV      r0,r1
000012  7800              LDRB     r0,[r0,#0]  ; imu_control
;;;422    }
000014  4770              BX       lr
;;;423    uint8_t getIMUControl(void){ 
                          ENDP

000016  0000              DCW      0x0000
                  |L33.24|
                          DCD      imu_control

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  shtpData
                          %        128
                  metaData
                          %        36

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  STREAM_OFFSET_TAB
000000  10284058          DCB      0x10,0x28,0x40,0x58
000004  7088a0b8          DCB      0x70,0x88,0xa0,0xb8
                  aRCC_PLLSAIDIVRPrescTable
000008  02040810          DCB      0x02,0x04,0x08,0x10
                  OFFSET_TAB_CCMRx
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  040404            DCB      0x04,0x04,0x04
                  SHIFT_TAB_OCxx
000013  00                DCB      0x00
000014  00080000          DCB      0x00,0x08,0x00,0x00
000018  0008              DCB      0x00,0x08
                  SHIFT_TAB_ICxx
00001a  0000              DCB      0x00,0x00
00001c  08000000          DCB      0x08,0x00,0x00,0x00
000020  08                DCB      0x08
                  SHIFT_TAB_CCxP
000021  000204            DCB      0x00,0x02,0x04
000024  06080a0c          DCB      0x06,0x08,0x0a,0x0c
                  SHIFT_TAB_OISx
000028  00010203          DCB      0x00,0x01,0x02,0x03
00002c  040506            DCB      0x04,0x05,0x06

                          AREA ||.data||, DATA, ALIGN=2

                  shtpHeader
                          DCD      0x00000000
                  sequenceNumber
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  0000              DCB      0x00,0x00
                  commandSequenceNumber
00000a  0000              DCB      0x00,0x00
                  rawAccelX
00000c  0000              DCB      0x00,0x00
                  rawAccelY
00000e  0000              DCB      0x00,0x00
                  rawAccelZ
000010  0000              DCB      0x00,0x00
                  accelAccuracy
000012  0000              DCB      0x00,0x00
                  rawLinAccelX
000014  0000              DCB      0x00,0x00
                  rawLinAccelY
000016  0000              DCB      0x00,0x00
                  rawLinAccelZ
000018  0000              DCB      0x00,0x00
                  accelLinAccuracy
00001a  0000              DCB      0x00,0x00
                  rawGyroX
00001c  0000              DCB      0x00,0x00
                  rawGyroY
00001e  0000              DCB      0x00,0x00
                  rawGyroZ
000020  0000              DCB      0x00,0x00
                  gyroAccuracy
000022  0000              DCB      0x00,0x00
                  rawMagX
000024  0000              DCB      0x00,0x00
                  rawMagY
000026  0000              DCB      0x00,0x00
                  rawMagZ
000028  0000              DCB      0x00,0x00
                  magAccuracy
00002a  0000              DCB      0x00,0x00
                  rawQuatI
00002c  0000              DCB      0x00,0x00
                  rawQuatJ
00002e  0000              DCB      0x00,0x00
                  rawQuatK
000030  0000              DCB      0x00,0x00
                  rawQuatReal
000032  0000              DCB      0x00,0x00
                  rawQuatRadianAccuracy
000034  0000              DCB      0x00,0x00
                  quatAccuracy
000036  0000              DCB      0x00,0x00
                  stepCount
000038  00000000          DCB      0x00,0x00,0x00,0x00
                  timeStamp
                          DCD      0x00000000
                  stabilityClassifier
000040  00                DCB      0x00
                  activityClassifier
000041  000000            DCB      0x00,0x00,0x00
                  _activityConfidences
                          DCD      0x00000000
                  calibrationStatus
000048  0000              DCB      0x00,0x00
                  rotationVector_Q1
00004a  000e              DCW      0x000e
                  accelerometer_Q1
00004c  0008              DCW      0x0008
                  linear_accelerometer_Q1
00004e  0008              DCW      0x0008
                  gyro_Q1
000050  0009              DCW      0x0009
                  magnetometer_Q1
000052  0004              DCW      0x0004
                  imu_control
000054  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\Src\\imu.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_imu_c_60885fe7____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___5_imu_c_60885fe7____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_imu_c_60885fe7____REVSH|
#line 402
|__asm___5_imu_c_60885fe7____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_imu_c_60885fe7____RRX|
#line 587
|__asm___5_imu_c_60885fe7____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
