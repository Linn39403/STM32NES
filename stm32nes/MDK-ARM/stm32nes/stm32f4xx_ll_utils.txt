; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_ll_utils.o --depend=stm32nes\stm32f4xx_ll_utils.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_ll_utils.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_utils.c]
                          THUMB

                          AREA ||i.LL_Init1msTick||, CODE, READONLY, ALIGN=1

                  LL_Init1msTick PROC
;;;274      */
;;;275    void LL_Init1msTick(uint32_t HCLKFrequency)
000000  f44f717a          MOV      r1,#0x3e8
;;;276    {
;;;277      /* Use frequency provided in argument */
;;;278      LL_InitTick(HCLKFrequency, 1000U);
000004  fbb0f2f1          UDIV     r2,r0,r1
000008  1e52              SUBS     r2,r2,#1
00000a  f04f23e0          MOV      r3,#0xe000e000
00000e  615a              STR      r2,[r3,#0x14]
000010  2200              MOVS     r2,#0
000012  619a              STR      r2,[r3,#0x18]
000014  2205              MOVS     r2,#5
000016  611a              STR      r2,[r3,#0x10]
000018  bf00              NOP      
;;;279    }
00001a  4770              BX       lr
;;;280    
                          ENDP


                          AREA ||i.LL_PLL_ConfigSystemClock_HSE||, CODE, READONLY, ALIGN=2

                  LL_PLL_ConfigSystemClock_HSE PROC
;;;419      */
;;;420    ErrorStatus LL_PLL_ConfigSystemClock_HSE(uint32_t HSEFrequency, uint32_t HSEBypass,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;421                                             LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
;;;422    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;423      ErrorStatus status = SUCCESS;
00000c  f04f0801          MOV      r8,#1
;;;424      uint32_t pllfreq = 0U;
000010  f04f0900          MOV      r9,#0
;;;425    
;;;426      /* Check the parameters */
;;;427      assert_param(IS_LL_UTILS_HSE_FREQUENCY(HSEFrequency));
;;;428      assert_param(IS_LL_UTILS_HSE_BYPASS(HSEBypass));
;;;429    
;;;430      /* Check if one of the PLL is enabled */
;;;431      if(UTILS_PLL_IsBusy() == SUCCESS)
000014  f7fffffe          BL       UTILS_PLL_IsBusy
000018  2801              CMP      r0,#1
00001a  d135              BNE      |L2.136|
;;;432      {
;;;433        /* Calculate the new PLL output frequency */
;;;434        pllfreq = UTILS_GetPLLOutputFrequency(HSEFrequency, UTILS_PLLInitStruct);
00001c  4621              MOV      r1,r4
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       UTILS_GetPLLOutputFrequency
000024  4681              MOV      r9,r0
;;;435    
;;;436        /* Enable HSE if not enabled */
;;;437        if(LL_RCC_HSE_IsReady() != 1U)
000026  f7fffffe          BL       LL_RCC_HSE_IsReady
00002a  2801              CMP      r0,#1
00002c  d020              BEQ      |L2.112|
;;;438        {
;;;439          /* Check if need to enable HSE bypass feature or not */
;;;440          if(HSEBypass == LL_UTILS_HSEBYPASS_ON)
00002e  2d01              CMP      r5,#1
000030  d108              BNE      |L2.68|
;;;441          {
;;;442            LL_RCC_HSE_EnableBypass();
000032  bf00              NOP      
000034  4817              LDR      r0,|L2.148|
000036  6800              LDR      r0,[r0,#0]
000038  f4402080          ORR      r0,r0,#0x40000
00003c  4915              LDR      r1,|L2.148|
00003e  6008              STR      r0,[r1,#0]
000040  bf00              NOP      
000042  e008              B        |L2.86|
                  |L2.68|
;;;443          }
;;;444          else
;;;445          {
;;;446            LL_RCC_HSE_DisableBypass();
000044  bf00              NOP      
000046  4813              LDR      r0,|L2.148|
000048  6800              LDR      r0,[r0,#0]
00004a  f4202080          BIC      r0,r0,#0x40000
00004e  4911              LDR      r1,|L2.148|
000050  6008              STR      r0,[r1,#0]
000052  bf00              NOP      
000054  bf00              NOP      
                  |L2.86|
;;;447          }
;;;448    
;;;449          /* Enable HSE */
;;;450          LL_RCC_HSE_Enable();
000056  bf00              NOP      
000058  480e              LDR      r0,|L2.148|
00005a  6800              LDR      r0,[r0,#0]
00005c  f4403080          ORR      r0,r0,#0x10000
000060  490c              LDR      r1,|L2.148|
000062  6008              STR      r0,[r1,#0]
000064  bf00              NOP      
;;;451          while (LL_RCC_HSE_IsReady() != 1U)
000066  bf00              NOP      
                  |L2.104|
000068  f7fffffe          BL       LL_RCC_HSE_IsReady
00006c  2801              CMP      r0,#1
00006e  d1fb              BNE      |L2.104|
                  |L2.112|
;;;452          {
;;;453            /* Wait for HSE ready */
;;;454          }
;;;455        }
;;;456    
;;;457        /* Configure PLL */
;;;458        LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN,
000070  f44f0080          MOV      r0,#0x400000
000074  e894000e          LDM      r4,{r1-r3}
000078  f7fffffe          BL       LL_RCC_PLL_ConfigDomain_SYS
;;;459                                    UTILS_PLLInitStruct->PLLP);
;;;460    
;;;461        /* Enable PLL and switch system clock to PLL */
;;;462        status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
00007c  4631              MOV      r1,r6
00007e  4648              MOV      r0,r9
000080  f7fffffe          BL       UTILS_EnablePLLAndSwitchSystem
000084  4680              MOV      r8,r0
000086  e001              B        |L2.140|
                  |L2.136|
;;;463      }
;;;464      else
;;;465      {
;;;466        /* Current PLL configuration cannot be modified */
;;;467        status = ERROR;
000088  f04f0800          MOV      r8,#0
                  |L2.140|
;;;468      }
;;;469    
;;;470      return status;
00008c  4640              MOV      r0,r8
;;;471    }
00008e  e8bd87f0          POP      {r4-r10,pc}
;;;472    
                          ENDP

000092  0000              DCW      0x0000
                  |L2.148|
                          DCD      0x40023800

                          AREA ||i.LL_PLL_ConfigSystemClock_HSI||, CODE, READONLY, ALIGN=2

                  LL_PLL_ConfigSystemClock_HSI PROC
;;;362      */
;;;363    ErrorStatus LL_PLL_ConfigSystemClock_HSI(LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;364                                             LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
;;;365    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;366      ErrorStatus status = SUCCESS;
000008  2601              MOVS     r6,#1
;;;367      uint32_t pllfreq = 0U;
00000a  2700              MOVS     r7,#0
;;;368    
;;;369      /* Check if one of the PLL is enabled */
;;;370      if(UTILS_PLL_IsBusy() == SUCCESS)
00000c  f7fffffe          BL       UTILS_PLL_IsBusy
000010  2801              CMP      r0,#1
000012  d120              BNE      |L3.86|
;;;371      {
;;;372        /* Calculate the new PLL output frequency */
;;;373        pllfreq = UTILS_GetPLLOutputFrequency(HSI_VALUE, UTILS_PLLInitStruct);
000014  4621              MOV      r1,r4
000016  4812              LDR      r0,|L3.96|
000018  f7fffffe          BL       UTILS_GetPLLOutputFrequency
00001c  4607              MOV      r7,r0
;;;374    
;;;375        /* Enable HSI if not enabled */
;;;376        if(LL_RCC_HSI_IsReady() != 1U)
00001e  f7fffffe          BL       LL_RCC_HSI_IsReady
000022  2801              CMP      r0,#1
000024  d00c              BEQ      |L3.64|
;;;377        {
;;;378          LL_RCC_HSI_Enable();
000026  bf00              NOP      
000028  480e              LDR      r0,|L3.100|
00002a  6800              LDR      r0,[r0,#0]
00002c  f0400001          ORR      r0,r0,#1
000030  490c              LDR      r1,|L3.100|
000032  6008              STR      r0,[r1,#0]
000034  bf00              NOP      
;;;379          while (LL_RCC_HSI_IsReady() != 1U)
000036  bf00              NOP      
                  |L3.56|
000038  f7fffffe          BL       LL_RCC_HSI_IsReady
00003c  2801              CMP      r0,#1
00003e  d1fb              BNE      |L3.56|
                  |L3.64|
;;;380          {
;;;381            /* Wait for HSI ready */
;;;382          }
;;;383        }
;;;384    
;;;385        /* Configure PLL */
;;;386        LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, UTILS_PLLInitStruct->PLLM, UTILS_PLLInitStruct->PLLN,
000040  2000              MOVS     r0,#0
000042  e894000e          LDM      r4,{r1-r3}
000046  f7fffffe          BL       LL_RCC_PLL_ConfigDomain_SYS
;;;387                                    UTILS_PLLInitStruct->PLLP);
;;;388    
;;;389        /* Enable PLL and switch system clock to PLL */
;;;390        status = UTILS_EnablePLLAndSwitchSystem(pllfreq, UTILS_ClkInitStruct);
00004a  4629              MOV      r1,r5
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       UTILS_EnablePLLAndSwitchSystem
000052  4606              MOV      r6,r0
000054  e000              B        |L3.88|
                  |L3.86|
;;;391      }
;;;392      else
;;;393      {
;;;394        /* Current PLL configuration cannot be modified */
;;;395        status = ERROR;
000056  2600              MOVS     r6,#0
                  |L3.88|
;;;396      }
;;;397    
;;;398      return status;
000058  4630              MOV      r0,r6
;;;399    }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;400    
                          ENDP

00005e  0000              DCW      0x0000
                  |L3.96|
                          DCD      0x00f42400
                  |L3.100|
                          DCD      0x40023800

                          AREA ||i.LL_RCC_HSE_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_HSE_IsReady PROC
;;;2986     */
;;;2987   __STATIC_INLINE uint32_t LL_RCC_HSE_IsReady(void)
000000  4802              LDR      r0,|L4.12|
;;;2988   {
;;;2989     return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
000002  6800              LDR      r0,[r0,#0]
000004  f3c04040          UBFX     r0,r0,#17,#1
;;;2990   }
000008  4770              BX       lr
;;;2991   
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      0x40023800

                          AREA ||i.LL_RCC_HSI_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_HSI_IsReady PROC
;;;3024     */
;;;3025   __STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
000000  4802              LDR      r0,|L5.12|
;;;3026   {
;;;3027     return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
000002  6800              LDR      r0,[r0,#0]
000004  f3c00040          UBFX     r0,r0,#1,#1
;;;3028   }
000008  4770              BX       lr
;;;3029   
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x40023800

                          AREA ||i.LL_RCC_PLL_ConfigDomain_SYS||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_ConfigDomain_SYS PROC
;;;4321     */
;;;4322   __STATIC_INLINE void LL_RCC_PLL_ConfigDomain_SYS(uint32_t Source, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP_R)
000000  b570              PUSH     {r4-r6,lr}
;;;4323   {
;;;4324     MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN,
000002  ea400401          ORR      r4,r0,r1
000006  ea441482          ORR      r4,r4,r2,LSL #6
00000a  4d07              LDR      r5,|L6.40|
00000c  682d              LDR      r5,[r5,#0]
00000e  4e07              LDR      r6,|L6.44|
000010  4035              ANDS     r5,r5,r6
000012  432c              ORRS     r4,r4,r5
000014  4d04              LDR      r5,|L6.40|
000016  602c              STR      r4,[r5,#0]
;;;4325                Source | PLLM | PLLN << RCC_PLLCFGR_PLLN_Pos);
;;;4326     MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, PLLP_R);
000018  462c              MOV      r4,r5
00001a  6824              LDR      r4,[r4,#0]
00001c  f4243440          BIC      r4,r4,#0x30000
000020  431c              ORRS     r4,r4,r3
000022  602c              STR      r4,[r5,#0]
;;;4327   #if defined(RCC_PLLR_SYSCLK_SUPPORT)
;;;4328     MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLR, PLLP_R);
;;;4329   #endif /* RCC_PLLR_SYSCLK_SUPPORT */
;;;4330   }
000024  bd70              POP      {r4-r6,pc}
;;;4331   
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      0x40023804
                  |L6.44|
                          DCD      0xffbf8000

                          AREA ||i.LL_RCC_PLL_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_IsReady PROC
;;;4222     */
;;;4223   __STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
000000  4802              LDR      r0,|L7.12|
;;;4224   {
;;;4225     return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
000002  6800              LDR      r0,[r0,#0]
000004  f3c06040          UBFX     r0,r0,#25,#1
;;;4226   }
000008  4770              BX       lr
;;;4227   
                          ENDP

00000a  0000              DCW      0x0000
                  |L7.12|
                          DCD      0x40023800

                          AREA ||i.LL_SetSystemCoreClock||, CODE, READONLY, ALIGN=2

                  LL_SetSystemCoreClock PROC
;;;340      */
;;;341    void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
000000  4901              LDR      r1,|L8.8|
;;;342    {
;;;343      /* HCLK clock frequency */
;;;344      SystemCoreClock = HCLKFrequency;
000002  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;345    }
000004  4770              BX       lr
;;;346    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      SystemCoreClock

                          AREA ||i.LL_mDelay||, CODE, READONLY, ALIGN=1

                  LL_mDelay PROC
;;;290      */
;;;291    void LL_mDelay(uint32_t Delay)
000000  b508              PUSH     {r3,lr}
;;;292    {
;;;293      __IO uint32_t  tmp = SysTick->CTRL;  /* Clear the COUNTFLAG first */
000002  f04f21e0          MOV      r1,#0xe000e000
000006  6909              LDR      r1,[r1,#0x10]
000008  9100              STR      r1,[sp,#0]
;;;294      /* Add this code to indicate that local variable is not used */
;;;295      ((void)tmp);
00000a  bf00              NOP      
;;;296    
;;;297      /* Add a period to guaranty minimum wait */
;;;298      if(Delay < LL_MAX_DELAY)
00000c  1c41              ADDS     r1,r0,#1
00000e  b101              CBZ      r1,|L9.18|
;;;299      {
;;;300        Delay++;
000010  1c40              ADDS     r0,r0,#1
                  |L9.18|
;;;301      }
;;;302    
;;;303      while (Delay)
000012  e006              B        |L9.34|
                  |L9.20|
;;;304      {
;;;305        if((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U)
000014  f04f21e0          MOV      r1,#0xe000e000
000018  6909              LDR      r1,[r1,#0x10]
00001a  f4013180          AND      r1,r1,#0x10000
00001e  b101              CBZ      r1,|L9.34|
;;;306        {
;;;307          Delay--;
000020  1e40              SUBS     r0,r0,#1
                  |L9.34|
000022  2800              CMP      r0,#0                 ;303
000024  d1f6              BNE      |L9.20|
;;;308        }
;;;309      }
;;;310    }
000026  bd08              POP      {r3,pc}
;;;311    
                          ENDP


                          AREA ||i.UTILS_EnablePLLAndSwitchSystem||, CODE, READONLY, ALIGN=2

                  UTILS_EnablePLLAndSwitchSystem PROC
;;;685      */
;;;686    static ErrorStatus UTILS_EnablePLLAndSwitchSystem(uint32_t SYSCLK_Frequency, LL_UTILS_ClkInitTypeDef *UTILS_ClkInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;687    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;688      ErrorStatus status = SUCCESS;
000008  2501              MOVS     r5,#1
;;;689      uint32_t hclk_frequency = 0U;
00000a  2600              MOVS     r6,#0
;;;690    
;;;691      assert_param(IS_LL_UTILS_SYSCLK_DIV(UTILS_ClkInitStruct->AHBCLKDivider));
;;;692      assert_param(IS_LL_UTILS_APB1_DIV(UTILS_ClkInitStruct->APB1CLKDivider));
;;;693      assert_param(IS_LL_UTILS_APB2_DIV(UTILS_ClkInitStruct->APB2CLKDivider));
;;;694    
;;;695      /* Calculate HCLK frequency */
;;;696      hclk_frequency = __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, UTILS_ClkInitStruct->AHBCLKDivider);
00000c  7820              LDRB     r0,[r4,#0]
00000e  f3c01003          UBFX     r0,r0,#4,#4
000012  492d              LDR      r1,|L10.200|
000014  5c08              LDRB     r0,[r1,r0]
000016  fa27f600          LSR      r6,r7,r0
;;;697    
;;;698      /* Increasing the number of wait states because of higher CPU frequency */
;;;699      if(SystemCoreClock < hclk_frequency)
00001a  482c              LDR      r0,|L10.204|
00001c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00001e  42b0              CMP      r0,r6
000020  d203              BCS      |L10.42|
;;;700      {
;;;701        /* Set FLASH latency to highest latency */
;;;702        status = UTILS_SetFlashLatency(hclk_frequency);
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       UTILS_SetFlashLatency
000028  4605              MOV      r5,r0
                  |L10.42|
;;;703      }
;;;704    
;;;705      /* Update system clock configuration */
;;;706      if(status == SUCCESS)
00002a  2d01              CMP      r5,#1
00002c  d13c              BNE      |L10.168|
;;;707      {
;;;708        /* Enable PLL */
;;;709        LL_RCC_PLL_Enable();
00002e  bf00              NOP      
000030  4827              LDR      r0,|L10.208|
000032  6800              LDR      r0,[r0,#0]
000034  f0407080          ORR      r0,r0,#0x1000000
000038  4925              LDR      r1,|L10.208|
00003a  6008              STR      r0,[r1,#0]
00003c  bf00              NOP      
;;;710        while (LL_RCC_PLL_IsReady() != 1U)
00003e  bf00              NOP      
                  |L10.64|
000040  f7fffffe          BL       LL_RCC_PLL_IsReady
000044  2801              CMP      r0,#1
000046  d1fb              BNE      |L10.64|
;;;711        {
;;;712          /* Wait for PLL ready */
;;;713        }
;;;714    
;;;715        /* Sysclk activation on the main PLL */
;;;716        LL_RCC_SetAHBPrescaler(UTILS_ClkInitStruct->AHBCLKDivider);
000048  6820              LDR      r0,[r4,#0]
00004a  4921              LDR      r1,|L10.208|
00004c  3108              ADDS     r1,r1,#8
00004e  6809              LDR      r1,[r1,#0]
000050  f02101f0          BIC      r1,r1,#0xf0
000054  4301              ORRS     r1,r1,r0
000056  4a1e              LDR      r2,|L10.208|
000058  3208              ADDS     r2,r2,#8
00005a  6011              STR      r1,[r2,#0]
00005c  bf00              NOP      
;;;717        LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
00005e  2002              MOVS     r0,#2
000060  4611              MOV      r1,r2
000062  6809              LDR      r1,[r1,#0]
000064  f0210103          BIC      r1,r1,#3
000068  4301              ORRS     r1,r1,r0
00006a  6011              STR      r1,[r2,#0]
00006c  bf00              NOP      
;;;718        while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
00006e  bf00              NOP      
                  |L10.112|
000070  bf00              NOP      
000072  4817              LDR      r0,|L10.208|
000074  3008              ADDS     r0,r0,#8
000076  6800              LDR      r0,[r0,#0]
000078  f000000c          AND      r0,r0,#0xc
00007c  2808              CMP      r0,#8
00007e  d1f7              BNE      |L10.112|
;;;719        {
;;;720          /* Wait for system clock switch to PLL */
;;;721        }
;;;722    
;;;723        /* Set APB1 & APB2 prescaler*/
;;;724        LL_RCC_SetAPB1Prescaler(UTILS_ClkInitStruct->APB1CLKDivider);
000080  6860              LDR      r0,[r4,#4]
000082  4913              LDR      r1,|L10.208|
000084  3108              ADDS     r1,r1,#8
000086  6809              LDR      r1,[r1,#0]
000088  f42151e0          BIC      r1,r1,#0x1c00
00008c  4301              ORRS     r1,r1,r0
00008e  4a10              LDR      r2,|L10.208|
000090  3208              ADDS     r2,r2,#8
000092  6011              STR      r1,[r2,#0]
000094  bf00              NOP      
;;;725        LL_RCC_SetAPB2Prescaler(UTILS_ClkInitStruct->APB2CLKDivider);
000096  68a0              LDR      r0,[r4,#8]
000098  4611              MOV      r1,r2
00009a  6809              LDR      r1,[r1,#0]
00009c  f4214160          BIC      r1,r1,#0xe000
0000a0  4301              ORRS     r1,r1,r0
0000a2  6011              STR      r1,[r2,#0]
0000a4  bf00              NOP      
0000a6  bf00              NOP      
                  |L10.168|
;;;726      }
;;;727        
;;;728      /* Decreasing the number of wait states because of lower CPU frequency */
;;;729      if(SystemCoreClock > hclk_frequency)
0000a8  4808              LDR      r0,|L10.204|
0000aa  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0000ac  42b0              CMP      r0,r6
0000ae  d903              BLS      |L10.184|
;;;730      {
;;;731        /* Set FLASH latency to lowest latency */
;;;732        status = UTILS_SetFlashLatency(hclk_frequency);
0000b0  4630              MOV      r0,r6
0000b2  f7fffffe          BL       UTILS_SetFlashLatency
0000b6  4605              MOV      r5,r0
                  |L10.184|
;;;733      }
;;;734    
;;;735      /* Update SystemCoreClock variable */
;;;736      if(status == SUCCESS)
0000b8  2d01              CMP      r5,#1
0000ba  d102              BNE      |L10.194|
;;;737      {
;;;738        LL_SetSystemCoreClock(hclk_frequency);
0000bc  4630              MOV      r0,r6
0000be  f7fffffe          BL       LL_SetSystemCoreClock
                  |L10.194|
;;;739      }
;;;740    
;;;741      return status;
0000c2  4628              MOV      r0,r5
;;;742    }
0000c4  e8bd81f0          POP      {r4-r8,pc}
;;;743    
                          ENDP

                  |L10.200|
                          DCD      AHBPrescTable
                  |L10.204|
                          DCD      SystemCoreClock
                  |L10.208|
                          DCD      0x40023800

                          AREA ||i.UTILS_GetPLLOutputFrequency||, CODE, READONLY, ALIGN=1

                  UTILS_GetPLLOutputFrequency PROC
;;;615      */
;;;616    static uint32_t UTILS_GetPLLOutputFrequency(uint32_t PLL_InputFrequency, LL_UTILS_PLLInitTypeDef *UTILS_PLLInitStruct)
000000  b510              PUSH     {r4,lr}
;;;617    {
000002  4602              MOV      r2,r0
;;;618      uint32_t pllfreq = 0U;
000004  2000              MOVS     r0,#0
;;;619    
;;;620      /* Check the parameters */
;;;621      assert_param(IS_LL_UTILS_PLLM_VALUE(UTILS_PLLInitStruct->PLLM));
;;;622      assert_param(IS_LL_UTILS_PLLN_VALUE(UTILS_PLLInitStruct->PLLN));
;;;623      assert_param(IS_LL_UTILS_PLLP_VALUE(UTILS_PLLInitStruct->PLLP));
;;;624      
;;;625      /* Check different PLL parameters according to RM                          */
;;;626      /*  - PLLM: ensure that the VCO input frequency ranges from @ref UTILS_PLLVCO_INPUT_MIN to @ref UTILS_PLLVCO_INPUT_MAX MHz.   */
;;;627      pllfreq = PLL_InputFrequency / (UTILS_PLLInitStruct->PLLM & (RCC_PLLCFGR_PLLM >> RCC_PLLCFGR_PLLM_Pos));
000006  780b              LDRB     r3,[r1,#0]
000008  f003033f          AND      r3,r3,#0x3f
00000c  fbb2f0f3          UDIV     r0,r2,r3
;;;628      assert_param(IS_LL_UTILS_PLLVCO_INPUT(pllfreq));
;;;629    
;;;630      /*  - PLLN: ensure that the VCO output frequency is between @ref UTILS_PLLVCO_OUTPUT_MIN and @ref UTILS_PLLVCO_OUTPUT_MAX .*/
;;;631      pllfreq = pllfreq * (UTILS_PLLInitStruct->PLLN & (RCC_PLLCFGR_PLLN >> RCC_PLLCFGR_PLLN_Pos));
000010  888b              LDRH     r3,[r1,#4]
000012  f3c30308          UBFX     r3,r3,#0,#9
000016  4358              MULS     r0,r3,r0
;;;632      assert_param(IS_LL_UTILS_PLLVCO_OUTPUT(pllfreq));
;;;633      
;;;634      /*  - PLLP: ensure that max frequency at @ref RCC_MAX_FREQUENCY Hz is reached     */
;;;635      pllfreq = pllfreq / (((UTILS_PLLInitStruct->PLLP >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
000018  2401              MOVS     r4,#1
00001a  688b              LDR      r3,[r1,#8]
00001c  eb044313          ADD      r3,r4,r3,LSR #16
000020  005b              LSLS     r3,r3,#1
000022  fbb0f0f3          UDIV     r0,r0,r3
;;;636      assert_param(IS_LL_UTILS_PLL_FREQUENCY(pllfreq));
;;;637    
;;;638      return pllfreq;
;;;639    }
000026  bd10              POP      {r4,pc}
;;;640    
                          ENDP


                          AREA ||i.UTILS_PLL_IsBusy||, CODE, READONLY, ALIGN=2

                  UTILS_PLL_IsBusy PROC
;;;646      */
;;;647    static ErrorStatus UTILS_PLL_IsBusy(void)
000000  b510              PUSH     {r4,lr}
;;;648    {
;;;649      ErrorStatus status = SUCCESS;
000002  2401              MOVS     r4,#1
;;;650    
;;;651      /* Check if PLL is busy*/
;;;652      if(LL_RCC_PLL_IsReady() != 0U)
000004  f7fffffe          BL       LL_RCC_PLL_IsReady
000008  b100              CBZ      r0,|L12.12|
;;;653      {
;;;654        /* PLL configuration cannot be modified */
;;;655        status = ERROR;
00000a  2400              MOVS     r4,#0
                  |L12.12|
;;;656      }
;;;657    
;;;658    #if defined(RCC_PLLSAI_SUPPORT)
;;;659      /* Check if PLLSAI is busy*/
;;;660      if(LL_RCC_PLLSAI_IsReady() != 0U)
00000c  bf00              NOP      
00000e  4807              LDR      r0,|L12.44|
000010  6800              LDR      r0,[r0,#0]
000012  f3c07040          UBFX     r0,r0,#29,#1
000016  b100              CBZ      r0,|L12.26|
;;;661      {
;;;662        /* PLLSAI1 configuration cannot be modified */
;;;663        status = ERROR;
000018  2400              MOVS     r4,#0
                  |L12.26|
;;;664      }
;;;665    #endif /*RCC_PLLSAI_SUPPORT*/
;;;666    #if defined(RCC_PLLI2S_SUPPORT)
;;;667      /* Check if PLLI2S is busy*/
;;;668      if(LL_RCC_PLLI2S_IsReady() != 0U)
00001a  bf00              NOP      
00001c  4803              LDR      r0,|L12.44|
00001e  6800              LDR      r0,[r0,#0]
000020  f3c060c0          UBFX     r0,r0,#27,#1
000024  b100              CBZ      r0,|L12.40|
;;;669      {
;;;670        /* PLLI2S configuration cannot be modified */
;;;671        status = ERROR;
000026  2400              MOVS     r4,#0
                  |L12.40|
;;;672      }
;;;673    #endif /*RCC_PLLI2S_SUPPORT*/
;;;674      return status;
000028  4620              MOV      r0,r4
;;;675    }
00002a  bd10              POP      {r4,pc}
;;;676    
                          ENDP

                  |L12.44|
                          DCD      0x40023800

                          AREA ||i.UTILS_SetFlashLatency||, CODE, READONLY, ALIGN=2

                  UTILS_SetFlashLatency PROC
;;;492      */
;;;493    static ErrorStatus UTILS_SetFlashLatency(uint32_t HCLK_Frequency)
000000  b510              PUSH     {r4,lr}
;;;494    {
000002  4602              MOV      r2,r0
;;;495      ErrorStatus status = SUCCESS;
000004  2001              MOVS     r0,#1
;;;496    
;;;497      uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
000006  2100              MOVS     r1,#0
;;;498    
;;;499      /* Frequency cannot be equal to 0 */
;;;500      if(HCLK_Frequency == 0U)
000008  b90a              CBNZ     r2,|L13.14|
;;;501      {
;;;502        status = ERROR;
00000a  2000              MOVS     r0,#0
00000c  e06c              B        |L13.232|
                  |L13.14|
;;;503      }
;;;504      else
;;;505      {
;;;506        if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)
00000e  bf00              NOP      
000010  4b36              LDR      r3,|L13.236|
000012  681b              LDR      r3,[r3,#0]
000014  f4034340          AND      r3,r3,#0xc000
000018  f5b34f40          CMP      r3,#0xc000
00001c  d119              BNE      |L13.82|
;;;507        {
;;;508    #if defined (UTILS_SCALE1_LATENCY5_FREQ)
;;;509          if((HCLK_Frequency > UTILS_SCALE1_LATENCY5_FREQ)&&(latency == LL_FLASH_LATENCY_0))
00001e  4b34              LDR      r3,|L13.240|
000020  429a              CMP      r2,r3
000022  d901              BLS      |L13.40|
000024  b901              CBNZ     r1,|L13.40|
;;;510          {
;;;511            latency = LL_FLASH_LATENCY_5;
000026  2105              MOVS     r1,#5
                  |L13.40|
;;;512          }
;;;513    #endif /*UTILS_SCALE1_LATENCY5_FREQ */
;;;514    #if defined (UTILS_SCALE1_LATENCY4_FREQ)
;;;515          if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
000028  4b32              LDR      r3,|L13.244|
00002a  429a              CMP      r2,r3
00002c  d901              BLS      |L13.50|
00002e  b901              CBNZ     r1,|L13.50|
;;;516          {
;;;517            latency = LL_FLASH_LATENCY_4;
000030  2104              MOVS     r1,#4
                  |L13.50|
;;;518          }
;;;519    #endif /* UTILS_SCALE1_LATENCY4_FREQ */
;;;520    #if defined (UTILS_SCALE1_LATENCY3_FREQ)
;;;521          if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
000032  4b31              LDR      r3,|L13.248|
000034  429a              CMP      r2,r3
000036  d901              BLS      |L13.60|
000038  b901              CBNZ     r1,|L13.60|
;;;522          {
;;;523            latency = LL_FLASH_LATENCY_3;
00003a  2103              MOVS     r1,#3
                  |L13.60|
;;;524          }
;;;525    #endif /* UTILS_SCALE1_LATENCY3_FREQ */
;;;526    #if defined (UTILS_SCALE1_LATENCY2_FREQ) 
;;;527          if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
00003c  4b2f              LDR      r3,|L13.252|
00003e  429a              CMP      r2,r3
000040  d902              BLS      |L13.72|
000042  b909              CBNZ     r1,|L13.72|
;;;528          {
;;;529            latency = LL_FLASH_LATENCY_2;
000044  2102              MOVS     r1,#2
000046  e004              B        |L13.82|
                  |L13.72|
;;;530          }
;;;531          else
;;;532          {
;;;533            if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
000048  4b2d              LDR      r3,|L13.256|
00004a  429a              CMP      r2,r3
00004c  d901              BLS      |L13.82|
00004e  b901              CBNZ     r1,|L13.82|
;;;534            {
;;;535              latency = LL_FLASH_LATENCY_1;
000050  2101              MOVS     r1,#1
                  |L13.82|
;;;536            }
;;;537          }
;;;538    #endif /* UTILS_SCALE1_LATENCY2_FREQ */
;;;539        }
;;;540        if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)
000052  bf00              NOP      
000054  4b25              LDR      r3,|L13.236|
000056  681b              LDR      r3,[r3,#0]
000058  f4034340          AND      r3,r3,#0xc000
00005c  f5b34f00          CMP      r3,#0x8000
000060  d119              BNE      |L13.150|
;;;541        {
;;;542    #if defined (UTILS_SCALE2_LATENCY5_FREQ)
;;;543          if((HCLK_Frequency > UTILS_SCALE2_LATENCY5_FREQ)&&(latency == LL_FLASH_LATENCY_0))
000062  4b23              LDR      r3,|L13.240|
000064  429a              CMP      r2,r3
000066  d901              BLS      |L13.108|
000068  b901              CBNZ     r1,|L13.108|
;;;544          {
;;;545            latency = LL_FLASH_LATENCY_5;
00006a  2105              MOVS     r1,#5
                  |L13.108|
;;;546          }
;;;547    #endif /*UTILS_SCALE1_LATENCY5_FREQ */
;;;548    #if defined (UTILS_SCALE2_LATENCY4_FREQ)
;;;549          if((HCLK_Frequency > UTILS_SCALE2_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
00006c  4b25              LDR      r3,|L13.260|
00006e  429a              CMP      r2,r3
000070  d901              BLS      |L13.118|
000072  b901              CBNZ     r1,|L13.118|
;;;550          {
;;;551            latency = LL_FLASH_LATENCY_4;
000074  2104              MOVS     r1,#4
                  |L13.118|
;;;552          }
;;;553    #endif /*UTILS_SCALE1_LATENCY4_FREQ */
;;;554    #if defined (UTILS_SCALE2_LATENCY3_FREQ)
;;;555          if((HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
000076  4b20              LDR      r3,|L13.248|
000078  429a              CMP      r2,r3
00007a  d901              BLS      |L13.128|
00007c  b901              CBNZ     r1,|L13.128|
;;;556          {
;;;557            latency = LL_FLASH_LATENCY_3;
00007e  2103              MOVS     r1,#3
                  |L13.128|
;;;558          }
;;;559    #endif /*UTILS_SCALE1_LATENCY3_FREQ */
;;;560          if((HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
000080  4b1e              LDR      r3,|L13.252|
000082  429a              CMP      r2,r3
000084  d902              BLS      |L13.140|
000086  b909              CBNZ     r1,|L13.140|
;;;561          {
;;;562            latency = LL_FLASH_LATENCY_2;
000088  2102              MOVS     r1,#2
00008a  e004              B        |L13.150|
                  |L13.140|
;;;563          }
;;;564          else
;;;565          {
;;;566            if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
00008c  4b1c              LDR      r3,|L13.256|
00008e  429a              CMP      r2,r3
000090  d901              BLS      |L13.150|
000092  b901              CBNZ     r1,|L13.150|
;;;567            {
;;;568              latency = LL_FLASH_LATENCY_1;
000094  2101              MOVS     r1,#1
                  |L13.150|
;;;569            }
;;;570          }
;;;571        }
;;;572    #if defined (LL_PWR_REGU_VOLTAGE_SCALE3)
;;;573        if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE3)
000096  bf00              NOP      
000098  4b14              LDR      r3,|L13.236|
00009a  681b              LDR      r3,[r3,#0]
00009c  f4034340          AND      r3,r3,#0xc000
0000a0  f5b34f80          CMP      r3,#0x4000
0000a4  d10f              BNE      |L13.198|
;;;574        {
;;;575    #if defined (UTILS_SCALE3_LATENCY3_FREQ)
;;;576          if((HCLK_Frequency > UTILS_SCALE3_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
0000a6  4b14              LDR      r3,|L13.248|
0000a8  429a              CMP      r2,r3
0000aa  d901              BLS      |L13.176|
0000ac  b901              CBNZ     r1,|L13.176|
;;;577          {
;;;578            latency = LL_FLASH_LATENCY_3;
0000ae  2103              MOVS     r1,#3
                  |L13.176|
;;;579          }
;;;580    #endif /*UTILS_SCALE1_LATENCY3_FREQ */
;;;581    #if defined (UTILS_SCALE3_LATENCY2_FREQ)
;;;582          if((HCLK_Frequency > UTILS_SCALE3_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
0000b0  4b12              LDR      r3,|L13.252|
0000b2  429a              CMP      r2,r3
0000b4  d902              BLS      |L13.188|
0000b6  b909              CBNZ     r1,|L13.188|
;;;583          {
;;;584            latency = LL_FLASH_LATENCY_2;
0000b8  2102              MOVS     r1,#2
0000ba  e004              B        |L13.198|
                  |L13.188|
;;;585          }
;;;586          else
;;;587          {
;;;588            if((HCLK_Frequency > UTILS_SCALE3_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
0000bc  4b10              LDR      r3,|L13.256|
0000be  429a              CMP      r2,r3
0000c0  d901              BLS      |L13.198|
0000c2  b901              CBNZ     r1,|L13.198|
;;;589            {
;;;590              latency = LL_FLASH_LATENCY_1;
0000c4  2101              MOVS     r1,#1
                  |L13.198|
;;;591            }
;;;592          }
;;;593        }
;;;594    #endif /*UTILS_SCALE1_LATENCY2_FREQ */
;;;595    #endif /* LL_PWR_REGU_VOLTAGE_SCALE3 */
;;;596    
;;;597        LL_FLASH_SetLatency(latency);
0000c6  bf00              NOP      
0000c8  4b0f              LDR      r3,|L13.264|
0000ca  681b              LDR      r3,[r3,#0]
0000cc  f023030f          BIC      r3,r3,#0xf
0000d0  430b              ORRS     r3,r3,r1
0000d2  4c0d              LDR      r4,|L13.264|
0000d4  6023              STR      r3,[r4,#0]
0000d6  bf00              NOP      
;;;598    
;;;599        /* Check that the new number of wait states is taken into account to access the Flash
;;;600           memory by reading the FLASH_ACR register */
;;;601        if(LL_FLASH_GetLatency() != latency)
0000d8  bf00              NOP      
0000da  4623              MOV      r3,r4
0000dc  681b              LDR      r3,[r3,#0]
0000de  f003030f          AND      r3,r3,#0xf
0000e2  428b              CMP      r3,r1
0000e4  d000              BEQ      |L13.232|
;;;602        {
;;;603          status = ERROR;
0000e6  2000              MOVS     r0,#0
                  |L13.232|
;;;604        }
;;;605      }
;;;606      return status;
;;;607    }
0000e8  bd10              POP      {r4,pc}
;;;608    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L13.236|
                          DCD      0x40007000
                  |L13.240|
                          DCD      0x08f0d180
                  |L13.244|
                          DCD      0x07270e00
                  |L13.248|
                          DCD      0x055d4a80
                  |L13.252|
                          DCD      0x03938700
                  |L13.256|
                          DCD      0x01c9c380
                  |L13.260|
                          DCD      0x00b71b00
                  |L13.264|
                          DCD      0x40023c00

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  aRCC_PLLSAIDIVRPrescTable
000000  02040810          DCB      0x02,0x04,0x08,0x10

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_utils.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_utils_c_fa0b8999____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f4xx_ll_utils_c_fa0b8999____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_utils_c_fa0b8999____REVSH|
#line 402
|__asm___20_stm32f4xx_ll_utils_c_fa0b8999____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_utils_c_fa0b8999____RRX|
#line 587
|__asm___20_stm32f4xx_ll_utils_c_fa0b8999____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
