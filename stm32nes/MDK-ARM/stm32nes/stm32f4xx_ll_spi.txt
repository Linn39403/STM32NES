; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_ll_spi.o --depend=stm32nes\stm32f4xx_ll_spi.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_ll_spi.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_spi.c]
                          THUMB

                          AREA ||i.LL_APB1_GRP1_ForceReset||, CODE, READONLY, ALIGN=2

                  LL_APB1_GRP1_ForceReset PROC
;;;1426   */
;;;1427   __STATIC_INLINE void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
000000  4902              LDR      r1,|L1.12|
;;;1428   {
;;;1429     SET_BIT(RCC->APB1RSTR, Periphs);
000002  6809              LDR      r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L1.12|
000008  6011              STR      r1,[r2,#0]
;;;1430   }
00000a  4770              BX       lr
;;;1431   
                          ENDP

                  |L1.12|
                          DCD      0x40023820

                          AREA ||i.LL_APB1_GRP1_ReleaseReset||, CODE, READONLY, ALIGN=2

                  LL_APB1_GRP1_ReleaseReset PROC
;;;1498   */
;;;1499   __STATIC_INLINE void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
000000  4902              LDR      r1,|L2.12|
;;;1500   {
;;;1501     CLEAR_BIT(RCC->APB1RSTR, Periphs);
000002  6809              LDR      r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L2.12|
000008  6011              STR      r1,[r2,#0]
;;;1502   }
00000a  4770              BX       lr
;;;1503   
                          ENDP

                  |L2.12|
                          DCD      0x40023820

                          AREA ||i.LL_APB2_GRP1_ForceReset||, CODE, READONLY, ALIGN=2

                  LL_APB2_GRP1_ForceReset PROC
;;;1906   */
;;;1907   __STATIC_INLINE void LL_APB2_GRP1_ForceReset(uint32_t Periphs)
000000  4902              LDR      r1,|L3.12|
;;;1908   {
;;;1909     SET_BIT(RCC->APB2RSTR, Periphs);
000002  6809              LDR      r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L3.12|
000008  6011              STR      r1,[r2,#0]
;;;1910   }
00000a  4770              BX       lr
;;;1911   
                          ENDP

                  |L3.12|
                          DCD      0x40023824

                          AREA ||i.LL_APB2_GRP1_ReleaseReset||, CODE, READONLY, ALIGN=2

                  LL_APB2_GRP1_ReleaseReset PROC
;;;1964   */
;;;1965   __STATIC_INLINE void LL_APB2_GRP1_ReleaseReset(uint32_t Periphs)
000000  4902              LDR      r1,|L4.12|
;;;1966   {
;;;1967     CLEAR_BIT(RCC->APB2RSTR, Periphs);
000002  6809              LDR      r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L4.12|
000008  6011              STR      r1,[r2,#0]
;;;1968   }
00000a  4770              BX       lr
;;;1969   
                          ENDP

                  |L4.12|
                          DCD      0x40023824

                          AREA ||i.LL_I2S_ConfigPrescaler||, CODE, READONLY, ALIGN=1

                  LL_I2S_ConfigPrescaler PROC
;;;542      */
;;;543    void LL_I2S_ConfigPrescaler(SPI_TypeDef *SPIx, uint32_t PrescalerLinear, uint32_t PrescalerParity)
000000  b510              PUSH     {r4,lr}
;;;544    {
;;;545      /* Check the I2S parameters */
;;;546      assert_param(IS_I2S_ALL_INSTANCE(SPIx));
;;;547      assert_param(IS_LL_I2S_PRESCALER_LINEAR(PrescalerLinear));
;;;548      assert_param(IS_LL_I2S_PRESCALER_PARITY(PrescalerParity));
;;;549    
;;;550      /* Write to SPIx I2SPR */
;;;551      MODIFY_REG(SPIx->I2SPR, SPI_I2SPR_I2SDIV | SPI_I2SPR_ODD, PrescalerLinear | (PrescalerParity << 8U));
000002  6a03              LDR      r3,[r0,#0x20]
000004  f36f0308          BFC      r3,#0,#9
000008  ea412402          ORR      r4,r1,r2,LSL #8
00000c  4323              ORRS     r3,r3,r4
00000e  6203              STR      r3,[r0,#0x20]
;;;552    }
000010  bd10              POP      {r4,pc}
;;;553    
                          ENDP


                          AREA ||i.LL_I2S_DeInit||, CODE, READONLY, ALIGN=1

                  LL_I2S_DeInit PROC
;;;400      */
;;;401    ErrorStatus LL_I2S_DeInit(SPI_TypeDef *SPIx)
000000  b510              PUSH     {r4,lr}
;;;402    {
000002  4604              MOV      r4,r0
;;;403      return LL_SPI_DeInit(SPIx);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       LL_SPI_DeInit
;;;404    }
00000a  bd10              POP      {r4,pc}
;;;405    
                          ENDP


                          AREA ||i.LL_I2S_Init||, CODE, READONLY, ALIGN=1

                  LL_I2S_Init PROC
;;;415      */
;;;416    ErrorStatus LL_I2S_Init(SPI_TypeDef *SPIx, LL_I2S_InitTypeDef *I2S_InitStruct)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;417    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;418      uint16_t i2sdiv = 2U, i2sodd = 0U, packetlength = 1U;
000008  2702              MOVS     r7,#2
00000a  f04f0800          MOV      r8,#0
00000e  f04f0a01          MOV      r10,#1
;;;419      uint32_t tmp = 0U;
000012  2500              MOVS     r5,#0
;;;420      uint32_t sourceclock = 0U;
000014  46a9              MOV      r9,r5
;;;421      ErrorStatus status = ERROR;
000016  46ab              MOV      r11,r5
;;;422    
;;;423      /* Check the I2S parameters */
;;;424      assert_param(IS_I2S_ALL_INSTANCE(SPIx));
;;;425      assert_param(IS_LL_I2S_MODE(I2S_InitStruct->Mode));
;;;426      assert_param(IS_LL_I2S_STANDARD(I2S_InitStruct->Standard));
;;;427      assert_param(IS_LL_I2S_DATAFORMAT(I2S_InitStruct->DataFormat));
;;;428      assert_param(IS_LL_I2S_MCLK_OUTPUT(I2S_InitStruct->MCLKOutput));
;;;429      assert_param(IS_LL_I2S_AUDIO_FREQ(I2S_InitStruct->AudioFreq));
;;;430      assert_param(IS_LL_I2S_CPOL(I2S_InitStruct->ClockPolarity));
;;;431    
;;;432      if (LL_I2S_IsEnabled(SPIx) == 0x00000000U)
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       LL_I2S_IsEnabled
00001e  2800              CMP      r0,#0
000020  d150              BNE      |L7.196|
;;;433      {
;;;434        /*---------------------------- SPIx I2SCFGR Configuration --------------------
;;;435         * Configure SPIx I2SCFGR with parameters:
;;;436         * - Mode:          SPI_I2SCFGR_I2SCFG[1:0] bit
;;;437         * - Standard:      SPI_I2SCFGR_I2SSTD[1:0] and SPI_I2SCFGR_PCMSYNC bits
;;;438         * - DataFormat:    SPI_I2SCFGR_CHLEN and SPI_I2SCFGR_DATLEN bits
;;;439         * - ClockPolarity: SPI_I2SCFGR_CKPOL bit
;;;440         */
;;;441    
;;;442        /* Write to SPIx I2SCFGR */
;;;443        MODIFY_REG(SPIx->I2SCFGR,
000022  e9d40100          LDRD     r0,r1,[r4,#0]
000026  4308              ORRS     r0,r0,r1
000028  68a1              LDR      r1,[r4,#8]
00002a  4308              ORRS     r0,r0,r1
00002c  6961              LDR      r1,[r4,#0x14]
00002e  4308              ORRS     r0,r0,r1
000030  f4406000          ORR      r0,r0,#0x800
000034  69f1              LDR      r1,[r6,#0x1c]
000036  f640323f          MOV      r2,#0xb3f
00003a  4391              BICS     r1,r1,r2
00003c  4308              ORRS     r0,r0,r1
00003e  61f0              STR      r0,[r6,#0x1c]
;;;444                   I2S_I2SCFGR_CLEAR_MASK,
;;;445                   I2S_InitStruct->Mode | I2S_InitStruct->Standard |
;;;446                   I2S_InitStruct->DataFormat | I2S_InitStruct->ClockPolarity |
;;;447                   SPI_I2SCFGR_I2SMOD);
;;;448    
;;;449        /*---------------------------- SPIx I2SPR Configuration ----------------------
;;;450         * Configure SPIx I2SPR with parameters:
;;;451         * - MCLKOutput:    SPI_I2SPR_MCKOE bit
;;;452         * - AudioFreq:     SPI_I2SPR_I2SDIV[7:0] and SPI_I2SPR_ODD bits
;;;453         */
;;;454    
;;;455        /* If the requested audio frequency is not the default, compute the prescaler (i2sodd, i2sdiv)
;;;456         * else, default values are used:  i2sodd = 0U, i2sdiv = 2U.
;;;457         */
;;;458        if (I2S_InitStruct->AudioFreq != LL_I2S_AUDIOFREQ_DEFAULT)
000040  6920              LDR      r0,[r4,#0x10]
000042  2802              CMP      r0,#2
000044  d030              BEQ      |L7.168|
;;;459        {
;;;460          /* Check the frame length (For the Prescaler computing)
;;;461           * Default value: LL_I2S_DATAFORMAT_16B (packetlength = 1U).
;;;462           */
;;;463          if (I2S_InitStruct->DataFormat != LL_I2S_DATAFORMAT_16B)
000046  68a0              LDR      r0,[r4,#8]
000048  b108              CBZ      r0,|L7.78|
;;;464          {
;;;465            /* Packet length is 32 bits */
;;;466            packetlength = 2U;
00004a  f04f0a02          MOV      r10,#2
                  |L7.78|
;;;467          }
;;;468    
;;;469          /* If an external I2S clock has to be used, the specific define should be set
;;;470          in the project configuration or in the stm32f4xx_ll_rcc.h file */
;;;471          /* Get the I2S source clock value */
;;;472          sourceclock = LL_RCC_GetI2SClockFreq(LL_RCC_I2S1_CLKSOURCE);
00004e  f44f0000          MOV      r0,#0x800000
000052  f7fffffe          BL       LL_RCC_GetI2SClockFreq
000056  4681              MOV      r9,r0
;;;473    
;;;474          /* Compute the Real divider depending on the MCLK output state with a floating point */
;;;475          if (I2S_InitStruct->MCLKOutput == LL_I2S_MCLK_OUTPUT_ENABLE)
000058  68e0              LDR      r0,[r4,#0xc]
00005a  f5b07f00          CMP      r0,#0x200
00005e  d10a              BNE      |L7.118|
;;;476          {
;;;477            /* MCLK output is enabled */
;;;478            tmp = (uint16_t)(((((sourceclock / 256U) * 10U) / I2S_InitStruct->AudioFreq)) + 5U);
000060  ea4f2019          LSR      r0,r9,#8
000064  eb000080          ADD      r0,r0,r0,LSL #2
000068  0040              LSLS     r0,r0,#1
00006a  6921              LDR      r1,[r4,#0x10]
00006c  fbb0f0f1          UDIV     r0,r0,r1
000070  1d40              ADDS     r0,r0,#5
000072  b285              UXTH     r5,r0
000074  e00b              B        |L7.142|
                  |L7.118|
;;;479          }
;;;480          else
;;;481          {
;;;482            /* MCLK output is disabled */
;;;483            tmp = (uint16_t)(((((sourceclock / (32U * packetlength)) * 10U) / I2S_InitStruct->AudioFreq)) + 5U);
000076  ea4f104a          LSL      r0,r10,#5
00007a  fbb9f0f0          UDIV     r0,r9,r0
00007e  eb000080          ADD      r0,r0,r0,LSL #2
000082  0040              LSLS     r0,r0,#1
000084  6921              LDR      r1,[r4,#0x10]
000086  fbb0f0f1          UDIV     r0,r0,r1
00008a  1d40              ADDS     r0,r0,#5
00008c  b285              UXTH     r5,r0
                  |L7.142|
;;;484          }
;;;485    
;;;486          /* Remove the floating point */
;;;487          tmp = tmp / 10U;
00008e  200a              MOVS     r0,#0xa
000090  fbb5f5f0          UDIV     r5,r5,r0
;;;488    
;;;489          /* Check the parity of the divider */
;;;490          i2sodd = (uint16_t)(tmp & (uint16_t)0x0001U);
000094  f0050801          AND      r8,r5,#1
;;;491    
;;;492          /* Compute the i2sdiv prescaler */
;;;493          i2sdiv = (uint16_t)((tmp - i2sodd) / 2U);
000098  eba50008          SUB      r0,r5,r8
00009c  f3c0074f          UBFX     r7,r0,#1,#16
;;;494    
;;;495          /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
;;;496          i2sodd = (uint16_t)(i2sodd << 8U);
0000a0  f64f70ff          MOV      r0,#0xffff
0000a4  ea002808          AND      r8,r0,r8,LSL #8
                  |L7.168|
;;;497        }
;;;498    
;;;499        /* Test if the divider is 1 or 0 or greater than 0xFF */
;;;500        if ((i2sdiv < 2U) || (i2sdiv > 0xFFU))
0000a8  2f02              CMP      r7,#2
0000aa  d301              BCC      |L7.176|
0000ac  2fff              CMP      r7,#0xff
0000ae  d902              BLS      |L7.182|
                  |L7.176|
;;;501        {
;;;502          /* Set the default values */
;;;503          i2sdiv = 2U;
0000b0  2702              MOVS     r7,#2
;;;504          i2sodd = 0U;
0000b2  f04f0800          MOV      r8,#0
                  |L7.182|
;;;505        }
;;;506    
;;;507        /* Write to SPIx I2SPR register the computed value */
;;;508        WRITE_REG(SPIx->I2SPR, i2sdiv | i2sodd | I2S_InitStruct->MCLKOutput);
0000b6  ea470008          ORR      r0,r7,r8
0000ba  68e1              LDR      r1,[r4,#0xc]
0000bc  4308              ORRS     r0,r0,r1
0000be  6230              STR      r0,[r6,#0x20]
;;;509    
;;;510        status = SUCCESS;
0000c0  f04f0b01          MOV      r11,#1
                  |L7.196|
;;;511      }
;;;512      return status;
0000c4  4658              MOV      r0,r11
;;;513    }
0000c6  e8bd9ff0          POP      {r4-r12,pc}
;;;514    
                          ENDP


                          AREA ||i.LL_I2S_InitFullDuplex||, CODE, READONLY, ALIGN=1

                  LL_I2S_InitFullDuplex PROC
;;;568      */
;;;569    ErrorStatus  LL_I2S_InitFullDuplex(SPI_TypeDef *I2Sxext, LL_I2S_InitTypeDef *I2S_InitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;570    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;571      uint16_t mode = 0U;
000008  2600              MOVS     r6,#0
;;;572      ErrorStatus status = ERROR;
00000a  2700              MOVS     r7,#0
;;;573    
;;;574      /* Check the I2S parameters */
;;;575      assert_param(IS_I2S_EXT_ALL_INSTANCE(I2Sxext));
;;;576      assert_param(IS_LL_I2S_MODE(I2S_InitStruct->Mode));
;;;577      assert_param(IS_LL_I2S_STANDARD(I2S_InitStruct->Standard));
;;;578      assert_param(IS_LL_I2S_DATAFORMAT(I2S_InitStruct->DataFormat));
;;;579      assert_param(IS_LL_I2S_CPOL(I2S_InitStruct->ClockPolarity));
;;;580    
;;;581      if (LL_I2S_IsEnabled(I2Sxext) == 0x00000000U)
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       LL_I2S_IsEnabled
000012  bb10              CBNZ     r0,|L8.90|
;;;582      {
;;;583        /*---------------------------- SPIx I2SCFGR Configuration --------------------
;;;584         * Configure SPIx I2SCFGR with parameters:
;;;585         * - Mode:          SPI_I2SCFGR_I2SCFG[1:0] bit
;;;586         * - Standard:      SPI_I2SCFGR_I2SSTD[1:0] and SPI_I2SCFGR_PCMSYNC bits
;;;587         * - DataFormat:    SPI_I2SCFGR_CHLEN and SPI_I2SCFGR_DATLEN bits
;;;588         * - ClockPolarity: SPI_I2SCFGR_CKPOL bit
;;;589         */
;;;590    
;;;591        /* Reset I2SPR registers */
;;;592        WRITE_REG(I2Sxext->I2SPR, I2S_I2SPR_CLEAR_MASK);
000014  2002              MOVS     r0,#2
000016  6228              STR      r0,[r5,#0x20]
;;;593    
;;;594        /* Get the mode to be configured for the extended I2S */
;;;595        if ((I2S_InitStruct->Mode == LL_I2S_MODE_MASTER_TX) || (I2S_InitStruct->Mode == LL_I2S_MODE_SLAVE_TX))
000018  6820              LDR      r0,[r4,#0]
00001a  f5b07f00          CMP      r0,#0x200
00001e  d001              BEQ      |L8.36|
000020  6820              LDR      r0,[r4,#0]
000022  b910              CBNZ     r0,|L8.42|
                  |L8.36|
;;;596        {
;;;597          mode = LL_I2S_MODE_SLAVE_RX;
000024  f44f7680          MOV      r6,#0x100
000028  e008              B        |L8.60|
                  |L8.42|
;;;598        }
;;;599        else
;;;600        {
;;;601          if ((I2S_InitStruct->Mode == LL_I2S_MODE_MASTER_RX) || (I2S_InitStruct->Mode == LL_I2S_MODE_SLAVE_RX))
00002a  6820              LDR      r0,[r4,#0]
00002c  f5b07f40          CMP      r0,#0x300
000030  d003              BEQ      |L8.58|
000032  6820              LDR      r0,[r4,#0]
000034  f5b07f80          CMP      r0,#0x100
000038  d100              BNE      |L8.60|
                  |L8.58|
;;;602          {
;;;603            mode = LL_I2S_MODE_SLAVE_TX;
00003a  2600              MOVS     r6,#0
                  |L8.60|
;;;604          }
;;;605        }
;;;606    
;;;607        /* Write to SPIx I2SCFGR */
;;;608        MODIFY_REG(I2Sxext->I2SCFGR,
00003c  e9d40101          LDRD     r0,r1,[r4,#4]
000040  4308              ORRS     r0,r0,r1
000042  6961              LDR      r1,[r4,#0x14]
000044  4308              ORRS     r0,r0,r1
000046  f4406000          ORR      r0,r0,#0x800
00004a  4330              ORRS     r0,r0,r6
00004c  69e9              LDR      r1,[r5,#0x1c]
00004e  f640323f          MOV      r2,#0xb3f
000052  4391              BICS     r1,r1,r2
000054  4308              ORRS     r0,r0,r1
000056  61e8              STR      r0,[r5,#0x1c]
;;;609                   I2S_I2SCFGR_CLEAR_MASK,
;;;610                   I2S_InitStruct->Standard |
;;;611                   I2S_InitStruct->DataFormat | I2S_InitStruct->ClockPolarity |
;;;612                   SPI_I2SCFGR_I2SMOD | mode);
;;;613    
;;;614        status = SUCCESS;
000058  2701              MOVS     r7,#1
                  |L8.90|
;;;615      }
;;;616      return status;
00005a  4638              MOV      r0,r7
;;;617    }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;618    #endif /* SPI_I2S_FULLDUPLEX_SUPPORT */
                          ENDP


                          AREA ||i.LL_I2S_IsEnabled||, CODE, READONLY, ALIGN=1

                  LL_I2S_IsEnabled PROC
;;;1407     */
;;;1408   __STATIC_INLINE uint32_t LL_I2S_IsEnabled(SPI_TypeDef *SPIx)
000000  4601              MOV      r1,r0
;;;1409   {
;;;1410     return (READ_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SE) == (SPI_I2SCFGR_I2SE));
000002  69c8              LDR      r0,[r1,#0x1c]
000004  f3c02080          UBFX     r0,r0,#10,#1
;;;1411   }
000008  4770              BX       lr
;;;1412   
                          ENDP


                          AREA ||i.LL_I2S_StructInit||, CODE, READONLY, ALIGN=1

                  LL_I2S_StructInit PROC
;;;520      */
;;;521    void LL_I2S_StructInit(LL_I2S_InitTypeDef *I2S_InitStruct)
000000  2100              MOVS     r1,#0
;;;522    {
;;;523      /*--------------- Reset I2S init structure parameters values -----------------*/
;;;524      I2S_InitStruct->Mode              = LL_I2S_MODE_SLAVE_TX;
000002  6001              STR      r1,[r0,#0]
;;;525      I2S_InitStruct->Standard          = LL_I2S_STANDARD_PHILIPS;
000004  6041              STR      r1,[r0,#4]
;;;526      I2S_InitStruct->DataFormat        = LL_I2S_DATAFORMAT_16B;
000006  6081              STR      r1,[r0,#8]
;;;527      I2S_InitStruct->MCLKOutput        = LL_I2S_MCLK_OUTPUT_DISABLE;
000008  60c1              STR      r1,[r0,#0xc]
;;;528      I2S_InitStruct->AudioFreq         = LL_I2S_AUDIOFREQ_DEFAULT;
00000a  2102              MOVS     r1,#2
00000c  6101              STR      r1,[r0,#0x10]
;;;529      I2S_InitStruct->ClockPolarity     = LL_I2S_POLARITY_LOW;
00000e  2100              MOVS     r1,#0
000010  6141              STR      r1,[r0,#0x14]
;;;530    }
000012  4770              BX       lr
;;;531    
                          ENDP


                          AREA ||i.LL_SPI_DeInit||, CODE, READONLY, ALIGN=2

                  LL_SPI_DeInit PROC
;;;138      */
;;;139    ErrorStatus LL_SPI_DeInit(SPI_TypeDef *SPIx)
000000  b570              PUSH     {r4-r6,lr}
;;;140    {
000002  4604              MOV      r4,r0
;;;141      ErrorStatus status = ERROR;
000004  2500              MOVS     r5,#0
;;;142    
;;;143      /* Check the parameters */
;;;144      assert_param(IS_SPI_ALL_INSTANCE(SPIx));
;;;145    
;;;146    #if defined(SPI1)
;;;147      if (SPIx == SPI1)
000006  4821              LDR      r0,|L11.140|
000008  4284              CMP      r4,r0
00000a  d106              BNE      |L11.26|
;;;148      {
;;;149        /* Force reset of SPI clock */
;;;150        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);
00000c  1480              ASRS     r0,r0,#18
00000e  f7fffffe          BL       LL_APB2_GRP1_ForceReset
;;;151    
;;;152        /* Release reset of SPI clock */
;;;153        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);
000012  14a0              ASRS     r0,r4,#18
000014  f7fffffe          BL       LL_APB2_GRP1_ReleaseReset
;;;154    
;;;155        status = SUCCESS;
000018  2501              MOVS     r5,#1
                  |L11.26|
;;;156      }
;;;157    #endif /* SPI1 */
;;;158    #if defined(SPI2)
;;;159      if (SPIx == SPI2)
00001a  481d              LDR      r0,|L11.144|
00001c  4284              CMP      r4,r0
00001e  d106              BNE      |L11.46|
;;;160      {
;;;161        /* Force reset of SPI clock */
;;;162        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_SPI2);
000020  1400              ASRS     r0,r0,#16
000022  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;163    
;;;164        /* Release reset of SPI clock */
;;;165        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_SPI2);
000026  1420              ASRS     r0,r4,#16
000028  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
;;;166    
;;;167        status = SUCCESS;
00002c  2501              MOVS     r5,#1
                  |L11.46|
;;;168      }
;;;169    #endif /* SPI2 */
;;;170    #if defined(SPI3)
;;;171      if (SPIx == SPI3)
00002e  4819              LDR      r0,|L11.148|
000030  4284              CMP      r4,r0
000032  d106              BNE      |L11.66|
;;;172      {
;;;173        /* Force reset of SPI clock */
;;;174        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_SPI3);
000034  13c0              ASRS     r0,r0,#15
000036  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;175    
;;;176        /* Release reset of SPI clock */
;;;177        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_SPI3);
00003a  13e0              ASRS     r0,r4,#15
00003c  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
;;;178    
;;;179        status = SUCCESS;
000040  2501              MOVS     r5,#1
                  |L11.66|
;;;180      }
;;;181    #endif /* SPI3 */
;;;182    #if defined(SPI4)
;;;183      if (SPIx == SPI4)
000042  4815              LDR      r0,|L11.152|
000044  4284              CMP      r4,r0
000046  d106              BNE      |L11.86|
;;;184      {
;;;185        /* Force reset of SPI clock */
;;;186        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI4);
000048  1440              ASRS     r0,r0,#17
00004a  f7fffffe          BL       LL_APB2_GRP1_ForceReset
;;;187    
;;;188        /* Release reset of SPI clock */
;;;189        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI4);
00004e  1460              ASRS     r0,r4,#17
000050  f7fffffe          BL       LL_APB2_GRP1_ReleaseReset
;;;190    
;;;191        status = SUCCESS;
000054  2501              MOVS     r5,#1
                  |L11.86|
;;;192      }
;;;193    #endif /* SPI4 */
;;;194    #if defined(SPI5)
;;;195      if (SPIx == SPI5)
000056  4811              LDR      r0,|L11.156|
000058  4284              CMP      r4,r0
00005a  d108              BNE      |L11.110|
;;;196      {
;;;197        /* Force reset of SPI clock */
;;;198        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI5);
00005c  f44f1080          MOV      r0,#0x100000
000060  f7fffffe          BL       LL_APB2_GRP1_ForceReset
;;;199    
;;;200        /* Release reset of SPI clock */
;;;201        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI5);
000064  f44f1080          MOV      r0,#0x100000
000068  f7fffffe          BL       LL_APB2_GRP1_ReleaseReset
;;;202    
;;;203        status = SUCCESS;
00006c  2501              MOVS     r5,#1
                  |L11.110|
;;;204      }
;;;205    #endif /* SPI5 */
;;;206    #if defined(SPI6)
;;;207      if (SPIx == SPI6)
00006e  480c              LDR      r0,|L11.160|
000070  4284              CMP      r4,r0
000072  d108              BNE      |L11.134|
;;;208      {
;;;209        /* Force reset of SPI clock */
;;;210        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI6);
000074  f44f1000          MOV      r0,#0x200000
000078  f7fffffe          BL       LL_APB2_GRP1_ForceReset
;;;211    
;;;212        /* Release reset of SPI clock */
;;;213        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI6);
00007c  f44f1000          MOV      r0,#0x200000
000080  f7fffffe          BL       LL_APB2_GRP1_ReleaseReset
;;;214    
;;;215        status = SUCCESS;
000084  2501              MOVS     r5,#1
                  |L11.134|
;;;216      }
;;;217    #endif /* SPI6 */
;;;218    
;;;219      return status;
000086  4628              MOV      r0,r5
;;;220    }
000088  bd70              POP      {r4-r6,pc}
;;;221    
                          ENDP

00008a  0000              DCW      0x0000
                  |L11.140|
                          DCD      0x40013000
                  |L11.144|
                          DCD      0x40003800
                  |L11.148|
                          DCD      0x40003c00
                  |L11.152|
                          DCD      0x40013400
                  |L11.156|
                          DCD      0x40015000
                  |L11.160|
                          DCD      0x40015400

                          AREA ||i.LL_SPI_Init||, CODE, READONLY, ALIGN=1

                  LL_SPI_Init PROC
;;;229      */
;;;230    ErrorStatus LL_SPI_Init(SPI_TypeDef *SPIx, LL_SPI_InitTypeDef *SPI_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;231    {
000002  4602              MOV      r2,r0
;;;232      ErrorStatus status = ERROR;
000004  2300              MOVS     r3,#0
;;;233    
;;;234      /* Check the SPI Instance SPIx*/
;;;235      assert_param(IS_SPI_ALL_INSTANCE(SPIx));
;;;236    
;;;237      /* Check the SPI parameters from SPI_InitStruct*/
;;;238      assert_param(IS_LL_SPI_TRANSFER_DIRECTION(SPI_InitStruct->TransferDirection));
;;;239      assert_param(IS_LL_SPI_MODE(SPI_InitStruct->Mode));
;;;240      assert_param(IS_LL_SPI_DATAWIDTH(SPI_InitStruct->DataWidth));
;;;241      assert_param(IS_LL_SPI_POLARITY(SPI_InitStruct->ClockPolarity));
;;;242      assert_param(IS_LL_SPI_PHASE(SPI_InitStruct->ClockPhase));
;;;243      assert_param(IS_LL_SPI_NSS(SPI_InitStruct->NSS));
;;;244      assert_param(IS_LL_SPI_BAUDRATE(SPI_InitStruct->BaudRate));
;;;245      assert_param(IS_LL_SPI_BITORDER(SPI_InitStruct->BitOrder));
;;;246      assert_param(IS_LL_SPI_CRCCALCULATION(SPI_InitStruct->CRCCalculation));
;;;247    
;;;248      if (LL_SPI_IsEnabled(SPIx) == 0x00000000U)
000006  bf00              NOP      
000008  6810              LDR      r0,[r2,#0]
00000a  f3c01080          UBFX     r0,r0,#6,#1
00000e  bb38              CBNZ     r0,|L12.96|
;;;249      {
;;;250        /*---------------------------- SPIx CR1 Configuration ------------------------
;;;251         * Configure SPIx CR1 with parameters:
;;;252         * - TransferDirection:  SPI_CR1_BIDIMODE, SPI_CR1_BIDIOE and SPI_CR1_RXONLY bits
;;;253         * - Master/Slave Mode:  SPI_CR1_MSTR bit
;;;254         * - DataWidth:          SPI_CR1_DFF bit
;;;255         * - ClockPolarity:      SPI_CR1_CPOL bit
;;;256         * - ClockPhase:         SPI_CR1_CPHA bit
;;;257         * - NSS management:     SPI_CR1_SSM bit
;;;258         * - BaudRate prescaler: SPI_CR1_BR[2:0] bits
;;;259         * - BitOrder:           SPI_CR1_LSBFIRST bit
;;;260         * - CRCCalculation:     SPI_CR1_CRCEN bit
;;;261         */
;;;262        MODIFY_REG(SPIx->CR1,
000010  e9d10400          LDRD     r0,r4,[r1,#0]
000014  4320              ORRS     r0,r0,r4
000016  688c              LDR      r4,[r1,#8]
000018  4320              ORRS     r0,r0,r4
00001a  68cc              LDR      r4,[r1,#0xc]
00001c  4320              ORRS     r0,r0,r4
00001e  690c              LDR      r4,[r1,#0x10]
000020  4320              ORRS     r0,r0,r4
000022  694c              LDR      r4,[r1,#0x14]
000024  4320              ORRS     r0,r0,r4
000026  698c              LDR      r4,[r1,#0x18]
000028  4320              ORRS     r0,r0,r4
00002a  69cc              LDR      r4,[r1,#0x1c]
00002c  4320              ORRS     r0,r0,r4
00002e  6a0c              LDR      r4,[r1,#0x20]
000030  4320              ORRS     r0,r0,r4
000032  6814              LDR      r4,[r2,#0]
000034  f64f75bf          MOV      r5,#0xffbf
000038  43ac              BICS     r4,r4,r5
00003a  4320              ORRS     r0,r0,r4
00003c  6010              STR      r0,[r2,#0]
;;;263                   SPI_CR1_CLEAR_MASK,
;;;264                   SPI_InitStruct->TransferDirection | SPI_InitStruct->Mode | SPI_InitStruct->DataWidth |
;;;265                   SPI_InitStruct->ClockPolarity | SPI_InitStruct->ClockPhase |
;;;266                   SPI_InitStruct->NSS | SPI_InitStruct->BaudRate |
;;;267                   SPI_InitStruct->BitOrder | SPI_InitStruct->CRCCalculation);
;;;268    
;;;269        /*---------------------------- SPIx CR2 Configuration ------------------------
;;;270         * Configure SPIx CR2 with parameters:
;;;271         * - NSS management:     SSOE bit
;;;272         */
;;;273        MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, (SPI_InitStruct->NSS >> 16U));
00003e  6850              LDR      r0,[r2,#4]
000040  f0200004          BIC      r0,r0,#4
000044  694c              LDR      r4,[r1,#0x14]
000046  ea404014          ORR      r0,r0,r4,LSR #16
00004a  6050              STR      r0,[r2,#4]
;;;274    
;;;275        /*---------------------------- SPIx CRCPR Configuration ----------------------
;;;276         * Configure SPIx CRCPR with parameters:
;;;277         * - CRCPoly:            CRCPOLY[15:0] bits
;;;278         */
;;;279        if (SPI_InitStruct->CRCCalculation == LL_SPI_CRCCALCULATION_ENABLE)
00004c  6a08              LDR      r0,[r1,#0x20]
00004e  f5b05f00          CMP      r0,#0x2000
000052  d104              BNE      |L12.94|
;;;280        {
;;;281          assert_param(IS_LL_SPI_CRC_POLYNOMIAL(SPI_InitStruct->CRCPoly));
;;;282          LL_SPI_SetCRCPolynomial(SPIx, SPI_InitStruct->CRCPoly);
000054  6a48              LDR      r0,[r1,#0x24]
000056  b284              UXTH     r4,r0
000058  6114              STR      r4,[r2,#0x10]
00005a  bf00              NOP      
00005c  bf00              NOP      
                  |L12.94|
;;;283        }
;;;284        status = SUCCESS;
00005e  2301              MOVS     r3,#1
                  |L12.96|
;;;285      }
;;;286    
;;;287      /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;288      CLEAR_BIT(SPIx->I2SCFGR, SPI_I2SCFGR_I2SMOD);
000060  69d0              LDR      r0,[r2,#0x1c]
000062  f4206000          BIC      r0,r0,#0x800
000066  61d0              STR      r0,[r2,#0x1c]
;;;289      return status;
000068  4618              MOV      r0,r3
;;;290    }
00006a  bd30              POP      {r4,r5,pc}
;;;291    
                          ENDP


                          AREA ||i.LL_SPI_StructInit||, CODE, READONLY, ALIGN=1

                  LL_SPI_StructInit PROC
;;;297      */
;;;298    void LL_SPI_StructInit(LL_SPI_InitTypeDef *SPI_InitStruct)
000000  2100              MOVS     r1,#0
;;;299    {
;;;300      /* Set SPI_InitStruct fields to default values */
;;;301      SPI_InitStruct->TransferDirection = LL_SPI_FULL_DUPLEX;
000002  6001              STR      r1,[r0,#0]
;;;302      SPI_InitStruct->Mode              = LL_SPI_MODE_SLAVE;
000004  6041              STR      r1,[r0,#4]
;;;303      SPI_InitStruct->DataWidth         = LL_SPI_DATAWIDTH_8BIT;
000006  6081              STR      r1,[r0,#8]
;;;304      SPI_InitStruct->ClockPolarity     = LL_SPI_POLARITY_LOW;
000008  60c1              STR      r1,[r0,#0xc]
;;;305      SPI_InitStruct->ClockPhase        = LL_SPI_PHASE_1EDGE;
00000a  6101              STR      r1,[r0,#0x10]
;;;306      SPI_InitStruct->NSS               = LL_SPI_NSS_HARD_INPUT;
00000c  6141              STR      r1,[r0,#0x14]
;;;307      SPI_InitStruct->BaudRate          = LL_SPI_BAUDRATEPRESCALER_DIV2;
00000e  6181              STR      r1,[r0,#0x18]
;;;308      SPI_InitStruct->BitOrder          = LL_SPI_MSB_FIRST;
000010  61c1              STR      r1,[r0,#0x1c]
;;;309      SPI_InitStruct->CRCCalculation    = LL_SPI_CRCCALCULATION_DISABLE;
000012  6201              STR      r1,[r0,#0x20]
;;;310      SPI_InitStruct->CRCPoly           = 7U;
000014  2107              MOVS     r1,#7
000016  6241              STR      r1,[r0,#0x24]
;;;311    }
000018  4770              BX       lr
;;;312    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  aRCC_PLLSAIDIVRPrescTable
000000  02040810          DCB      0x02,0x04,0x08,0x10

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____REVSH|
#line 402
|__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____RRX|
#line 587
|__asm___18_stm32f4xx_ll_spi_c_b74ba5f5____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
