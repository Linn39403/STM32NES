; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_hal_dma.o --depend=stm32nes\stm32f4xx_hal_dma.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_hal_dma.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dma.c]
                          THUMB

                          AREA ||i.DMA_CalcBaseAndBitshift||, CODE, READONLY, ALIGN=2

                  DMA_CalcBaseAndBitshift PROC
;;;1192     */
;;;1193   static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1194   {
;;;1195     uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
000002  7808              LDRB     r0,[r1,#0]
000004  3810              SUBS     r0,r0,#0x10
000006  2318              MOVS     r3,#0x18
000008  fbb0f2f3          UDIV     r2,r0,r3
;;;1196     
;;;1197     /* lookup table for necessary bitshift of flags within status registers */
;;;1198     static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
;;;1199     hdma->StreamIndex = flagBitshiftOffset[stream_number];
00000c  4808              LDR      r0,|L1.48|
00000e  5c80              LDRB     r0,[r0,r2]
000010  65c8              STR      r0,[r1,#0x5c]
;;;1200     
;;;1201     if (stream_number > 3U)
000012  2a03              CMP      r2,#3
000014  d905              BLS      |L1.34|
;;;1202     {
;;;1203       /* return pointer to HISR and HIFCR */
;;;1204       hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
000016  6808              LDR      r0,[r1,#0]
000018  f36f0009          BFC      r0,#0,#10
00001c  1d00              ADDS     r0,r0,#4
00001e  6588              STR      r0,[r1,#0x58]
000020  e003              B        |L1.42|
                  |L1.34|
;;;1205     }
;;;1206     else
;;;1207     {
;;;1208       /* return pointer to LISR and LIFCR */
;;;1209       hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
000022  6808              LDR      r0,[r1,#0]
000024  f36f0009          BFC      r0,#0,#10
000028  6588              STR      r0,[r1,#0x58]
                  |L1.42|
;;;1210     }
;;;1211     
;;;1212     return hdma->StreamBaseAddress;
00002a  6d88              LDR      r0,[r1,#0x58]
;;;1213   }
00002c  4770              BX       lr
;;;1214   
                          ENDP

00002e  0000              DCW      0x0000
                  |L1.48|
                          DCD      flagBitshiftOffset

                          AREA ||i.DMA_CheckFifoParam||, CODE, READONLY, ALIGN=1

                  DMA_CheckFifoParam PROC
;;;1220     */
;;;1221   static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1222   {
;;;1223     HAL_StatusTypeDef status = HAL_OK;
000002  2000              MOVS     r0,#0
;;;1224     uint32_t tmp = hdma->Init.FIFOThreshold;
000004  6a8a              LDR      r2,[r1,#0x28]
;;;1225     
;;;1226     /* Memory Data size equal to Byte */
;;;1227     if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
000006  698b              LDR      r3,[r1,#0x18]
000008  b9cb              CBNZ     r3,|L2.62|
;;;1228     {
;;;1229       switch (tmp)
00000a  b132              CBZ      r2,|L2.26|
00000c  2a01              CMP      r2,#1
00000e  d00d              BEQ      |L2.44|
000010  2a02              CMP      r2,#2
000012  d003              BEQ      |L2.28|
000014  2a03              CMP      r2,#3
000016  d110              BNE      |L2.58|
000018  e00e              B        |L2.56|
                  |L2.26|
;;;1230       {
;;;1231       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1232       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
00001a  bf00              NOP      
                  |L2.28|
;;;1233         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
00001c  6acb              LDR      r3,[r1,#0x2c]
00001e  f0037380          AND      r3,r3,#0x1000000
000022  f1b37f80          CMP      r3,#0x1000000
000026  d100              BNE      |L2.42|
;;;1234         {
;;;1235           status = HAL_ERROR;
000028  2001              MOVS     r0,#1
                  |L2.42|
;;;1236         }
;;;1237         break;
00002a  e007              B        |L2.60|
                  |L2.44|
;;;1238       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1239         if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00002c  6acb              LDR      r3,[r1,#0x2c]
00002e  f1b37fc0          CMP      r3,#0x1800000
000032  d100              BNE      |L2.54|
;;;1240         {
;;;1241           status = HAL_ERROR;
000034  2001              MOVS     r0,#1
                  |L2.54|
;;;1242         }
;;;1243         break;
000036  e001              B        |L2.60|
                  |L2.56|
;;;1244       case DMA_FIFO_THRESHOLD_FULL:
;;;1245         break;
000038  e000              B        |L2.60|
                  |L2.58|
;;;1246       default:
;;;1247         break;
00003a  bf00              NOP      
                  |L2.60|
00003c  e034              B        |L2.168|
                  |L2.62|
;;;1248       }
;;;1249     }
;;;1250     
;;;1251     /* Memory Data size equal to Half-Word */
;;;1252     else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
00003e  698b              LDR      r3,[r1,#0x18]
000040  f5b35f00          CMP      r3,#0x2000
000044  d11a              BNE      |L2.124|
;;;1253     {
;;;1254       switch (tmp)
000046  b132              CBZ      r2,|L2.86|
000048  2a01              CMP      r2,#1
00004a  d007              BEQ      |L2.92|
00004c  2a02              CMP      r2,#2
00004e  d003              BEQ      |L2.88|
000050  2a03              CMP      r2,#3
000052  d111              BNE      |L2.120|
000054  e00a              B        |L2.108|
                  |L2.86|
;;;1255       {
;;;1256       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1257       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
000056  bf00              NOP      
                  |L2.88|
;;;1258         status = HAL_ERROR;
000058  2001              MOVS     r0,#1
;;;1259         break;
00005a  e00e              B        |L2.122|
                  |L2.92|
;;;1260       case DMA_FIFO_THRESHOLD_HALFFULL:
;;;1261         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
00005c  6acb              LDR      r3,[r1,#0x2c]
00005e  f0037380          AND      r3,r3,#0x1000000
000062  f1b37f80          CMP      r3,#0x1000000
000066  d100              BNE      |L2.106|
;;;1262         {
;;;1263           status = HAL_ERROR;
000068  2001              MOVS     r0,#1
                  |L2.106|
;;;1264         }
;;;1265         break;
00006a  e006              B        |L2.122|
                  |L2.108|
;;;1266       case DMA_FIFO_THRESHOLD_FULL:
;;;1267         if (hdma->Init.MemBurst == DMA_MBURST_INC16)
00006c  6acb              LDR      r3,[r1,#0x2c]
00006e  f1b37fc0          CMP      r3,#0x1800000
000072  d100              BNE      |L2.118|
;;;1268         {
;;;1269           status = HAL_ERROR;
000074  2001              MOVS     r0,#1
                  |L2.118|
;;;1270         }
;;;1271         break;   
000076  e000              B        |L2.122|
                  |L2.120|
;;;1272       default:
;;;1273         break;
000078  bf00              NOP      
                  |L2.122|
00007a  e015              B        |L2.168|
                  |L2.124|
;;;1274       }
;;;1275     }
;;;1276     
;;;1277     /* Memory Data size equal to Word */
;;;1278     else
;;;1279     {
;;;1280       switch (tmp)
00007c  b132              CBZ      r2,|L2.140|
00007e  2a01              CMP      r2,#1
000080  d005              BEQ      |L2.142|
000082  2a02              CMP      r2,#2
000084  d004              BEQ      |L2.144|
000086  2a03              CMP      r2,#3
000088  d10c              BNE      |L2.164|
00008a  e003              B        |L2.148|
                  |L2.140|
;;;1281       {
;;;1282       case DMA_FIFO_THRESHOLD_1QUARTERFULL:
;;;1283       case DMA_FIFO_THRESHOLD_HALFFULL:
00008c  bf00              NOP      
                  |L2.142|
;;;1284       case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
00008e  bf00              NOP      
                  |L2.144|
;;;1285         status = HAL_ERROR;
000090  2001              MOVS     r0,#1
;;;1286         break;
000092  e008              B        |L2.166|
                  |L2.148|
;;;1287       case DMA_FIFO_THRESHOLD_FULL:
;;;1288         if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
000094  6acb              LDR      r3,[r1,#0x2c]
000096  f0037380          AND      r3,r3,#0x1000000
00009a  f1b37f80          CMP      r3,#0x1000000
00009e  d100              BNE      |L2.162|
;;;1289         {
;;;1290           status = HAL_ERROR;
0000a0  2001              MOVS     r0,#1
                  |L2.162|
;;;1291         }
;;;1292         break;
0000a2  e000              B        |L2.166|
                  |L2.164|
;;;1293       default:
;;;1294         break;
0000a4  bf00              NOP      
                  |L2.166|
0000a6  bf00              NOP                            ;1286
                  |L2.168|
;;;1295       }
;;;1296     } 
;;;1297     
;;;1298     return status; 
;;;1299   }
0000a8  4770              BX       lr
;;;1300   
                          ENDP


                          AREA ||i.DMA_SetConfig||, CODE, READONLY, ALIGN=1

                  DMA_SetConfig PROC
;;;1158     */
;;;1159   static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  b530              PUSH     {r4,r5,lr}
;;;1160   {
;;;1161     /* Clear DBM bit */
;;;1162     hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
000002  6804              LDR      r4,[r0,#0]
000004  6824              LDR      r4,[r4,#0]
000006  f4242480          BIC      r4,r4,#0x40000
00000a  6805              LDR      r5,[r0,#0]
00000c  602c              STR      r4,[r5,#0]
;;;1163   
;;;1164     /* Configure DMA Stream data length */
;;;1165     hdma->Instance->NDTR = DataLength;
00000e  6804              LDR      r4,[r0,#0]
000010  6063              STR      r3,[r4,#4]
;;;1166   
;;;1167     /* Memory to Peripheral */
;;;1168     if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
000012  6884              LDR      r4,[r0,#8]
000014  2c40              CMP      r4,#0x40
000016  d104              BNE      |L3.34|
;;;1169     {
;;;1170       /* Configure DMA Stream destination address */
;;;1171       hdma->Instance->PAR = DstAddress;
000018  6804              LDR      r4,[r0,#0]
00001a  60a2              STR      r2,[r4,#8]
;;;1172   
;;;1173       /* Configure DMA Stream source address */
;;;1174       hdma->Instance->M0AR = SrcAddress;
00001c  6804              LDR      r4,[r0,#0]
00001e  60e1              STR      r1,[r4,#0xc]
000020  e003              B        |L3.42|
                  |L3.34|
;;;1175     }
;;;1176     /* Peripheral to Memory */
;;;1177     else
;;;1178     {
;;;1179       /* Configure DMA Stream source address */
;;;1180       hdma->Instance->PAR = SrcAddress;
000022  6804              LDR      r4,[r0,#0]
000024  60a1              STR      r1,[r4,#8]
;;;1181   
;;;1182       /* Configure DMA Stream destination address */
;;;1183       hdma->Instance->M0AR = DstAddress;
000026  6804              LDR      r4,[r0,#0]
000028  60e2              STR      r2,[r4,#0xc]
                  |L3.42|
;;;1184     }
;;;1185   }
00002a  bd30              POP      {r4,r5,pc}
;;;1186   
                          ENDP


                          AREA ||i.HAL_DMA_Abort||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort PROC
;;;522      */
;;;523    HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;524    {
000002  4604              MOV      r4,r0
;;;525      /* calculate DMA base and stream number */
;;;526      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000004  6da5              LDR      r5,[r4,#0x58]
;;;527      
;;;528      uint32_t tickstart = HAL_GetTick();
000006  f7fffffe          BL       HAL_GetTick
00000a  4606              MOV      r6,r0
;;;529      
;;;530      if(hdma->State != HAL_DMA_STATE_BUSY)
00000c  f8940035          LDRB     r0,[r4,#0x35]
000010  2802              CMP      r0,#2
000012  d008              BEQ      |L4.38|
;;;531      {
;;;532        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
000014  2080              MOVS     r0,#0x80
000016  6560              STR      r0,[r4,#0x54]
;;;533        
;;;534        /* Process Unlocked */
;;;535        __HAL_UNLOCK(hdma);
000018  bf00              NOP      
00001a  2000              MOVS     r0,#0
00001c  f8840034          STRB     r0,[r4,#0x34]
000020  bf00              NOP      
;;;536        
;;;537        return HAL_ERROR;
000022  2001              MOVS     r0,#1
                  |L4.36|
;;;538      }
;;;539      else
;;;540      {
;;;541        /* Disable all the transfer interrupts */
;;;542        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
;;;543        hdma->Instance->FCR &= ~(DMA_IT_FE);
;;;544        
;;;545        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
;;;546        {
;;;547          hdma->Instance->CR  &= ~(DMA_IT_HT);
;;;548        }
;;;549        
;;;550        /* Disable the stream */
;;;551        __HAL_DMA_DISABLE(hdma);
;;;552        
;;;553        /* Check if the DMA Stream is effectively disabled */
;;;554        while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;555        {
;;;556          /* Check for the Timeout */
;;;557          if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;558          {
;;;559            /* Update error code */
;;;560            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;561            
;;;562            /* Process Unlocked */
;;;563            __HAL_UNLOCK(hdma);
;;;564            
;;;565            /* Change the DMA state */
;;;566            hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;567            
;;;568            return HAL_TIMEOUT;
;;;569          }
;;;570        }
;;;571        
;;;572        /* Clear all interrupt flags at correct offset within the register */
;;;573        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;574        
;;;575        /* Process Unlocked */
;;;576        __HAL_UNLOCK(hdma);
;;;577        
;;;578        /* Change the DMA state*/
;;;579        hdma->State = HAL_DMA_STATE_READY;
;;;580      }
;;;581      return HAL_OK;
;;;582    }
000024  bd70              POP      {r4-r6,pc}
                  |L4.38|
000026  6820              LDR      r0,[r4,#0]            ;542
000028  6800              LDR      r0,[r0,#0]            ;542
00002a  f0200016          BIC      r0,r0,#0x16           ;542
00002e  6821              LDR      r1,[r4,#0]            ;542
000030  6008              STR      r0,[r1,#0]            ;542
000032  6820              LDR      r0,[r4,#0]            ;543
000034  6940              LDR      r0,[r0,#0x14]         ;543
000036  f0200080          BIC      r0,r0,#0x80           ;543
00003a  6821              LDR      r1,[r4,#0]            ;543
00003c  6148              STR      r0,[r1,#0x14]         ;543
00003e  6c20              LDR      r0,[r4,#0x40]         ;545
000040  b908              CBNZ     r0,|L4.70|
000042  6ca0              LDR      r0,[r4,#0x48]         ;545
000044  b128              CBZ      r0,|L4.82|
                  |L4.70|
000046  6820              LDR      r0,[r4,#0]            ;547
000048  6800              LDR      r0,[r0,#0]            ;547
00004a  f0200008          BIC      r0,r0,#8              ;547
00004e  6821              LDR      r1,[r4,#0]            ;547
000050  6008              STR      r0,[r1,#0]            ;547
                  |L4.82|
000052  6820              LDR      r0,[r4,#0]            ;551
000054  6800              LDR      r0,[r0,#0]            ;551
000056  f0200001          BIC      r0,r0,#1              ;551
00005a  6821              LDR      r1,[r4,#0]            ;551
00005c  6008              STR      r0,[r1,#0]            ;551
00005e  e00f              B        |L4.128|
                  |L4.96|
000060  f7fffffe          BL       HAL_GetTick
000064  1b80              SUBS     r0,r0,r6              ;557
000066  2805              CMP      r0,#5                 ;557
000068  d90a              BLS      |L4.128|
00006a  2020              MOVS     r0,#0x20              ;560
00006c  6560              STR      r0,[r4,#0x54]         ;560
00006e  bf00              NOP                            ;563
000070  2000              MOVS     r0,#0                 ;563
000072  f8840034          STRB     r0,[r4,#0x34]         ;563
000076  bf00              NOP                            ;563
000078  2003              MOVS     r0,#3                 ;566
00007a  f8840035          STRB     r0,[r4,#0x35]         ;566
00007e  e7d1              B        |L4.36|
                  |L4.128|
000080  6820              LDR      r0,[r4,#0]            ;554
000082  6800              LDR      r0,[r0,#0]            ;554
000084  f0000001          AND      r0,r0,#1              ;554
000088  2800              CMP      r0,#0                 ;554
00008a  d1e9              BNE      |L4.96|
00008c  f894105c          LDRB     r1,[r4,#0x5c]         ;573
000090  203f              MOVS     r0,#0x3f              ;573
000092  4088              LSLS     r0,r0,r1              ;573
000094  60a8              STR      r0,[r5,#8]            ;573
000096  bf00              NOP                            ;576
000098  2000              MOVS     r0,#0                 ;576
00009a  f8840034          STRB     r0,[r4,#0x34]         ;576
00009e  bf00              NOP                            ;576
0000a0  2001              MOVS     r0,#1                 ;579
0000a2  f8840035          STRB     r0,[r4,#0x35]         ;579
0000a6  2000              MOVS     r0,#0                 ;581
0000a8  e7bc              B        |L4.36|
;;;583    
                          ENDP


                          AREA ||i.HAL_DMA_Abort_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Abort_IT PROC
;;;589      */
;;;590    HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;591    {
;;;592      if(hdma->State != HAL_DMA_STATE_BUSY)
000002  f8910035          LDRB     r0,[r1,#0x35]
000006  2802              CMP      r0,#2
000008  d003              BEQ      |L5.18|
;;;593      {
;;;594        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00000a  2080              MOVS     r0,#0x80
00000c  6548              STR      r0,[r1,#0x54]
;;;595        return HAL_ERROR;
00000e  2001              MOVS     r0,#1
                  |L5.16|
;;;596      }
;;;597      else
;;;598      {
;;;599        /* Set Abort State  */
;;;600        hdma->State = HAL_DMA_STATE_ABORT;
;;;601        
;;;602        /* Disable the stream */
;;;603        __HAL_DMA_DISABLE(hdma);
;;;604      }
;;;605    
;;;606      return HAL_OK;
;;;607    }
000010  4770              BX       lr
                  |L5.18|
000012  2005              MOVS     r0,#5                 ;600
000014  f8810035          STRB     r0,[r1,#0x35]         ;600
000018  6808              LDR      r0,[r1,#0]            ;603
00001a  6800              LDR      r0,[r0,#0]            ;603
00001c  f0200001          BIC      r0,r0,#1              ;603
000020  680a              LDR      r2,[r1,#0]            ;603
000022  6010              STR      r0,[r2,#0]            ;603
000024  2000              MOVS     r0,#0                 ;606
000026  e7f3              B        |L5.16|
;;;608    
                          ENDP


                          AREA ||i.HAL_DMA_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_DMA_DeInit PROC
;;;325      */
;;;326    HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;327    {
000002  4604              MOV      r4,r0
;;;328      DMA_Base_Registers *regs;
;;;329    
;;;330      /* Check the DMA peripheral state */
;;;331      if(hdma == NULL)
000004  b90c              CBNZ     r4,|L6.10|
;;;332      {
;;;333        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L6.8|
;;;334      }
;;;335      
;;;336      /* Check the DMA peripheral state */
;;;337      if(hdma->State == HAL_DMA_STATE_BUSY)
;;;338      {
;;;339        /* Return error status */
;;;340        return HAL_BUSY;
;;;341      }
;;;342    
;;;343      /* Check the parameters */
;;;344      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;345    
;;;346      /* Disable the selected DMA Streamx */
;;;347      __HAL_DMA_DISABLE(hdma);
;;;348    
;;;349      /* Reset DMA Streamx control register */
;;;350      hdma->Instance->CR   = 0U;
;;;351    
;;;352      /* Reset DMA Streamx number of data to transfer register */
;;;353      hdma->Instance->NDTR = 0U;
;;;354    
;;;355      /* Reset DMA Streamx peripheral address register */
;;;356      hdma->Instance->PAR  = 0U;
;;;357    
;;;358      /* Reset DMA Streamx memory 0 address register */
;;;359      hdma->Instance->M0AR = 0U;
;;;360      
;;;361      /* Reset DMA Streamx memory 1 address register */
;;;362      hdma->Instance->M1AR = 0U;
;;;363      
;;;364      /* Reset DMA Streamx FIFO control register */
;;;365      hdma->Instance->FCR  = 0x00000021U;
;;;366      
;;;367      /* Get DMA steam Base Address */  
;;;368      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;369      
;;;370      /* Clear all interrupt flags at correct offset within the register */
;;;371      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;372    
;;;373      /* Initialize the error code */
;;;374      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;375    
;;;376      /* Initialize the DMA state */
;;;377      hdma->State = HAL_DMA_STATE_RESET;
;;;378    
;;;379      /* Release Lock */
;;;380      __HAL_UNLOCK(hdma);
;;;381    
;;;382      return HAL_OK;
;;;383    }
000008  bd70              POP      {r4-r6,pc}
                  |L6.10|
00000a  f8940035          LDRB     r0,[r4,#0x35]         ;337
00000e  2802              CMP      r0,#2                 ;337
000010  d100              BNE      |L6.20|
000012  e7f9              B        |L6.8|
                  |L6.20|
000014  6820              LDR      r0,[r4,#0]            ;347
000016  6800              LDR      r0,[r0,#0]            ;347
000018  f0200001          BIC      r0,r0,#1              ;347
00001c  6821              LDR      r1,[r4,#0]            ;347
00001e  6008              STR      r0,[r1,#0]            ;347
000020  2000              MOVS     r0,#0                 ;350
000022  6821              LDR      r1,[r4,#0]            ;350
000024  6008              STR      r0,[r1,#0]            ;350
000026  6821              LDR      r1,[r4,#0]            ;353
000028  6048              STR      r0,[r1,#4]            ;353
00002a  6821              LDR      r1,[r4,#0]            ;356
00002c  6088              STR      r0,[r1,#8]            ;356
00002e  6821              LDR      r1,[r4,#0]            ;359
000030  60c8              STR      r0,[r1,#0xc]          ;359
000032  6821              LDR      r1,[r4,#0]            ;362
000034  6108              STR      r0,[r1,#0x10]         ;362
000036  2021              MOVS     r0,#0x21              ;365
000038  6821              LDR      r1,[r4,#0]            ;365
00003a  6148              STR      r0,[r1,#0x14]         ;365
00003c  4620              MOV      r0,r4                 ;368
00003e  f7fffffe          BL       DMA_CalcBaseAndBitshift
000042  4605              MOV      r5,r0                 ;368
000044  f894105c          LDRB     r1,[r4,#0x5c]         ;371
000048  203f              MOVS     r0,#0x3f              ;371
00004a  4088              LSLS     r0,r0,r1              ;371
00004c  60a8              STR      r0,[r5,#8]            ;371
00004e  2000              MOVS     r0,#0                 ;374
000050  6560              STR      r0,[r4,#0x54]         ;374
000052  f8840035          STRB     r0,[r4,#0x35]         ;377
000056  bf00              NOP                            ;380
000058  f8840034          STRB     r0,[r4,#0x34]         ;380
00005c  bf00              NOP                            ;380
00005e  bf00              NOP                            ;382
000060  e7d2              B        |L6.8|
;;;384    
                          ENDP


                          AREA ||i.HAL_DMA_GetError||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetError PROC
;;;1132     */
;;;1133   uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1134   {
;;;1135     return hdma->ErrorCode;
000002  6d48              LDR      r0,[r1,#0x54]
;;;1136   }
000004  4770              BX       lr
;;;1137   
                          ENDP


                          AREA ||i.HAL_DMA_GetState||, CODE, READONLY, ALIGN=1

                  HAL_DMA_GetState PROC
;;;1121     */
;;;1122   HAL_DMA_StateTypeDef HAL_DMA_GetState(DMA_HandleTypeDef *hdma)
000000  4601              MOV      r1,r0
;;;1123   {
;;;1124     return hdma->State;
000002  f8910035          LDRB     r0,[r1,#0x35]
;;;1125   }
000006  4770              BX       lr
;;;1126   
                          ENDP


                          AREA ||i.HAL_DMA_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_DMA_IRQHandler PROC
;;;755      */
;;;756    void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
000000  b5f8              PUSH     {r3-r7,lr}
;;;757    {
000002  4604              MOV      r4,r0
;;;758      uint32_t tmpisr;
;;;759      __IO uint32_t count = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;760      uint32_t timeout = SystemCoreClock / 9600U;
000008  488c              LDR      r0,|L9.572|
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f44f5116          MOV      r1,#0x2580
000010  fbb0f7f1          UDIV     r7,r0,r1
;;;761    
;;;762      /* calculate DMA base and stream number */
;;;763      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000014  6da5              LDR      r5,[r4,#0x58]
;;;764    
;;;765      tmpisr = regs->ISR;
000016  682e              LDR      r6,[r5,#0]
;;;766    
;;;767      /* Transfer Error Interrupt management ***************************************/
;;;768      if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
000018  f894105c          LDRB     r1,[r4,#0x5c]
00001c  2008              MOVS     r0,#8
00001e  4088              LSLS     r0,r0,r1
000020  4030              ANDS     r0,r0,r6
000022  b198              CBZ      r0,|L9.76|
;;;769      {
;;;770        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
000024  6820              LDR      r0,[r4,#0]
000026  6800              LDR      r0,[r0,#0]
000028  f0000004          AND      r0,r0,#4
00002c  b170              CBZ      r0,|L9.76|
;;;771        {
;;;772          /* Disable the transfer error interrupt */
;;;773          hdma->Instance->CR  &= ~(DMA_IT_TE);
00002e  6820              LDR      r0,[r4,#0]
000030  6800              LDR      r0,[r0,#0]
000032  f0200004          BIC      r0,r0,#4
000036  6821              LDR      r1,[r4,#0]
000038  6008              STR      r0,[r1,#0]
;;;774          
;;;775          /* Clear the transfer error flag */
;;;776          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
00003a  f894105c          LDRB     r1,[r4,#0x5c]
00003e  2008              MOVS     r0,#8
000040  4088              LSLS     r0,r0,r1
000042  60a8              STR      r0,[r5,#8]
;;;777          
;;;778          /* Update error code */
;;;779          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
000044  6d60              LDR      r0,[r4,#0x54]
000046  f0400001          ORR      r0,r0,#1
00004a  6560              STR      r0,[r4,#0x54]
                  |L9.76|
;;;780        }
;;;781      }
;;;782      /* FIFO Error Interrupt management ******************************************/
;;;783      if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
00004c  f894105c          LDRB     r1,[r4,#0x5c]
000050  2001              MOVS     r0,#1
000052  4088              LSLS     r0,r0,r1
000054  4030              ANDS     r0,r0,r6
000056  b168              CBZ      r0,|L9.116|
;;;784      {
;;;785        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
000058  6820              LDR      r0,[r4,#0]
00005a  6940              LDR      r0,[r0,#0x14]
00005c  f0000080          AND      r0,r0,#0x80
000060  b140              CBZ      r0,|L9.116|
;;;786        {
;;;787          /* Clear the FIFO error flag */
;;;788          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
000062  f894105c          LDRB     r1,[r4,#0x5c]
000066  2001              MOVS     r0,#1
000068  4088              LSLS     r0,r0,r1
00006a  60a8              STR      r0,[r5,#8]
;;;789    
;;;790          /* Update error code */
;;;791          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
00006c  6d60              LDR      r0,[r4,#0x54]
00006e  f0400002          ORR      r0,r0,#2
000072  6560              STR      r0,[r4,#0x54]
                  |L9.116|
;;;792        }
;;;793      }
;;;794      /* Direct Mode Error Interrupt management ***********************************/
;;;795      if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
000074  f894105c          LDRB     r1,[r4,#0x5c]
000078  2004              MOVS     r0,#4
00007a  4088              LSLS     r0,r0,r1
00007c  4030              ANDS     r0,r0,r6
00007e  b168              CBZ      r0,|L9.156|
;;;796      {
;;;797        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
000080  6820              LDR      r0,[r4,#0]
000082  6800              LDR      r0,[r0,#0]
000084  f0000002          AND      r0,r0,#2
000088  b140              CBZ      r0,|L9.156|
;;;798        {
;;;799          /* Clear the direct mode error flag */
;;;800          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
00008a  f894105c          LDRB     r1,[r4,#0x5c]
00008e  2004              MOVS     r0,#4
000090  4088              LSLS     r0,r0,r1
000092  60a8              STR      r0,[r5,#8]
;;;801    
;;;802          /* Update error code */
;;;803          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
000094  6d60              LDR      r0,[r4,#0x54]
000096  f0400004          ORR      r0,r0,#4
00009a  6560              STR      r0,[r4,#0x54]
                  |L9.156|
;;;804        }
;;;805      }
;;;806      /* Half Transfer Complete Interrupt management ******************************/
;;;807      if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
00009c  f894105c          LDRB     r1,[r4,#0x5c]
0000a0  2010              MOVS     r0,#0x10
0000a2  4088              LSLS     r0,r0,r1
0000a4  4030              ANDS     r0,r0,r6
0000a6  b378              CBZ      r0,|L9.264|
;;;808      {
;;;809        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
0000a8  6820              LDR      r0,[r4,#0]
0000aa  6800              LDR      r0,[r0,#0]
0000ac  f0000008          AND      r0,r0,#8
0000b0  b350              CBZ      r0,|L9.264|
;;;810        {
;;;811          /* Clear the half transfer complete flag */
;;;812          regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
0000b2  f894105c          LDRB     r1,[r4,#0x5c]
0000b6  2010              MOVS     r0,#0x10
0000b8  4088              LSLS     r0,r0,r1
0000ba  60a8              STR      r0,[r5,#8]
;;;813          
;;;814          /* Multi_Buffering mode enabled */
;;;815          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
0000bc  6820              LDR      r0,[r4,#0]
0000be  6800              LDR      r0,[r0,#0]
0000c0  f4002080          AND      r0,r0,#0x40000
0000c4  b180              CBZ      r0,|L9.232|
;;;816          {
;;;817            /* Current memory buffer used is Memory 0 */
;;;818            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
0000c6  6820              LDR      r0,[r4,#0]
0000c8  6800              LDR      r0,[r0,#0]
0000ca  f4002000          AND      r0,r0,#0x80000
0000ce  b928              CBNZ     r0,|L9.220|
;;;819            {
;;;820              if(hdma->XferHalfCpltCallback != NULL)
0000d0  6c20              LDR      r0,[r4,#0x40]
0000d2  b1c8              CBZ      r0,|L9.264|
;;;821              {
;;;822                /* Half transfer callback */
;;;823                hdma->XferHalfCpltCallback(hdma);
0000d4  4620              MOV      r0,r4
0000d6  6c21              LDR      r1,[r4,#0x40]
0000d8  4788              BLX      r1
0000da  e015              B        |L9.264|
                  |L9.220|
;;;824              }
;;;825            }
;;;826            /* Current memory buffer used is Memory 1 */
;;;827            else
;;;828            {
;;;829              if(hdma->XferM1HalfCpltCallback != NULL)
0000dc  6ca0              LDR      r0,[r4,#0x48]
0000de  b198              CBZ      r0,|L9.264|
;;;830              {
;;;831                /* Half transfer callback */
;;;832                hdma->XferM1HalfCpltCallback(hdma);
0000e0  4620              MOV      r0,r4
0000e2  6ca1              LDR      r1,[r4,#0x48]
0000e4  4788              BLX      r1
0000e6  e00f              B        |L9.264|
                  |L9.232|
;;;833              }
;;;834            }
;;;835          }
;;;836          else
;;;837          {
;;;838            /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
;;;839            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
0000e8  6820              LDR      r0,[r4,#0]
0000ea  6800              LDR      r0,[r0,#0]
0000ec  f4007080          AND      r0,r0,#0x100
0000f0  b928              CBNZ     r0,|L9.254|
;;;840            {
;;;841              /* Disable the half transfer interrupt */
;;;842              hdma->Instance->CR  &= ~(DMA_IT_HT);
0000f2  6820              LDR      r0,[r4,#0]
0000f4  6800              LDR      r0,[r0,#0]
0000f6  f0200008          BIC      r0,r0,#8
0000fa  6821              LDR      r1,[r4,#0]
0000fc  6008              STR      r0,[r1,#0]
                  |L9.254|
;;;843            }
;;;844            
;;;845            if(hdma->XferHalfCpltCallback != NULL)
0000fe  6c20              LDR      r0,[r4,#0x40]
000100  b110              CBZ      r0,|L9.264|
;;;846            {
;;;847              /* Half transfer callback */
;;;848              hdma->XferHalfCpltCallback(hdma);
000102  4620              MOV      r0,r4
000104  6c21              LDR      r1,[r4,#0x40]
000106  4788              BLX      r1
                  |L9.264|
;;;849            }
;;;850          }
;;;851        }
;;;852      }
;;;853      /* Transfer Complete Interrupt management ***********************************/
;;;854      if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
000108  f894105c          LDRB     r1,[r4,#0x5c]
00010c  2020              MOVS     r0,#0x20
00010e  4088              LSLS     r0,r0,r1
000110  4030              ANDS     r0,r0,r6
000112  2800              CMP      r0,#0
000114  d065              BEQ      |L9.482|
;;;855      {
;;;856        if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
000116  6820              LDR      r0,[r4,#0]
000118  6800              LDR      r0,[r0,#0]
00011a  f0000010          AND      r0,r0,#0x10
00011e  2800              CMP      r0,#0
000120  d05f              BEQ      |L9.482|
;;;857        {
;;;858          /* Clear the transfer complete flag */
;;;859          regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
000122  f894105c          LDRB     r1,[r4,#0x5c]
000126  2020              MOVS     r0,#0x20
000128  4088              LSLS     r0,r0,r1
00012a  60a8              STR      r0,[r5,#8]
;;;860          
;;;861          if(HAL_DMA_STATE_ABORT == hdma->State)
00012c  f8940035          LDRB     r0,[r4,#0x35]
000130  2805              CMP      r0,#5
000132  d128              BNE      |L9.390|
;;;862          {
;;;863            /* Disable all the transfer interrupts */
;;;864            hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
000134  6820              LDR      r0,[r4,#0]
000136  6800              LDR      r0,[r0,#0]
000138  f0200016          BIC      r0,r0,#0x16
00013c  6821              LDR      r1,[r4,#0]
00013e  6008              STR      r0,[r1,#0]
;;;865            hdma->Instance->FCR &= ~(DMA_IT_FE);
000140  6820              LDR      r0,[r4,#0]
000142  6940              LDR      r0,[r0,#0x14]
000144  f0200080          BIC      r0,r0,#0x80
000148  6821              LDR      r1,[r4,#0]
00014a  6148              STR      r0,[r1,#0x14]
;;;866            
;;;867            if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
00014c  6c20              LDR      r0,[r4,#0x40]
00014e  b908              CBNZ     r0,|L9.340|
000150  6ca0              LDR      r0,[r4,#0x48]
000152  b128              CBZ      r0,|L9.352|
                  |L9.340|
;;;868            {
;;;869              hdma->Instance->CR  &= ~(DMA_IT_HT);
000154  6820              LDR      r0,[r4,#0]
000156  6800              LDR      r0,[r0,#0]
000158  f0200008          BIC      r0,r0,#8
00015c  6821              LDR      r1,[r4,#0]
00015e  6008              STR      r0,[r1,#0]
                  |L9.352|
;;;870            }
;;;871    
;;;872            /* Clear all interrupt flags at correct offset within the register */
;;;873            regs->IFCR = 0x3FU << hdma->StreamIndex;
000160  f894105c          LDRB     r1,[r4,#0x5c]
000164  203f              MOVS     r0,#0x3f
000166  4088              LSLS     r0,r0,r1
000168  60a8              STR      r0,[r5,#8]
;;;874    
;;;875            /* Process Unlocked */
;;;876            __HAL_UNLOCK(hdma);
00016a  bf00              NOP      
00016c  2000              MOVS     r0,#0
00016e  f8840034          STRB     r0,[r4,#0x34]
000172  bf00              NOP      
;;;877    
;;;878            /* Change the DMA state */
;;;879            hdma->State = HAL_DMA_STATE_READY;
000174  2001              MOVS     r0,#1
000176  f8840035          STRB     r0,[r4,#0x35]
;;;880    
;;;881            if(hdma->XferAbortCallback != NULL)
00017a  6d20              LDR      r0,[r4,#0x50]
00017c  b110              CBZ      r0,|L9.388|
;;;882            {
;;;883              hdma->XferAbortCallback(hdma);
00017e  4620              MOV      r0,r4
000180  6d21              LDR      r1,[r4,#0x50]
000182  4788              BLX      r1
                  |L9.388|
;;;884            }
;;;885            return;
;;;886          }
;;;887    
;;;888          if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
;;;889          {
;;;890            /* Current memory buffer used is Memory 0 */
;;;891            if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
;;;892            {
;;;893              if(hdma->XferM1CpltCallback != NULL)
;;;894              {
;;;895                /* Transfer complete Callback for memory1 */
;;;896                hdma->XferM1CpltCallback(hdma);
;;;897              }
;;;898            }
;;;899            /* Current memory buffer used is Memory 1 */
;;;900            else
;;;901            {
;;;902              if(hdma->XferCpltCallback != NULL)
;;;903              {
;;;904                /* Transfer complete Callback for memory0 */
;;;905                hdma->XferCpltCallback(hdma);
;;;906              }
;;;907            }
;;;908          }
;;;909          /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
;;;910          else
;;;911          {
;;;912            if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
;;;913            {
;;;914              /* Disable the transfer complete interrupt */
;;;915              hdma->Instance->CR  &= ~(DMA_IT_TC);
;;;916    
;;;917              /* Process Unlocked */
;;;918              __HAL_UNLOCK(hdma);
;;;919    
;;;920              /* Change the DMA state */
;;;921              hdma->State = HAL_DMA_STATE_READY;
;;;922            }
;;;923    
;;;924            if(hdma->XferCpltCallback != NULL)
;;;925            {
;;;926              /* Transfer complete callback */
;;;927              hdma->XferCpltCallback(hdma);
;;;928            }
;;;929          }
;;;930        }
;;;931      }
;;;932      
;;;933      /* manage error case */
;;;934      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;935      {
;;;936        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;937        {
;;;938          hdma->State = HAL_DMA_STATE_ABORT;
;;;939    
;;;940          /* Disable the stream */
;;;941          __HAL_DMA_DISABLE(hdma);
;;;942    
;;;943          do
;;;944          {
;;;945            if (++count > timeout)
;;;946            {
;;;947              break;
;;;948            }
;;;949          }
;;;950          while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
;;;951    
;;;952          /* Process Unlocked */
;;;953          __HAL_UNLOCK(hdma);
;;;954    
;;;955          /* Change the DMA state */
;;;956          hdma->State = HAL_DMA_STATE_READY;
;;;957        }
;;;958    
;;;959        if(hdma->XferErrorCallback != NULL)
;;;960        {
;;;961          /* Transfer error callback */
;;;962          hdma->XferErrorCallback(hdma);
;;;963        }
;;;964      }
;;;965    }
000184  bdf8              POP      {r3-r7,pc}
                  |L9.390|
000186  6820              LDR      r0,[r4,#0]            ;888
000188  6800              LDR      r0,[r0,#0]            ;888
00018a  f4002080          AND      r0,r0,#0x40000        ;888
00018e  b180              CBZ      r0,|L9.434|
000190  6820              LDR      r0,[r4,#0]            ;891
000192  6800              LDR      r0,[r0,#0]            ;891
000194  f4002000          AND      r0,r0,#0x80000        ;891
000198  b928              CBNZ     r0,|L9.422|
00019a  6c60              LDR      r0,[r4,#0x44]         ;893
00019c  b110              CBZ      r0,|L9.420|
00019e  4620              MOV      r0,r4                 ;896
0001a0  6c61              LDR      r1,[r4,#0x44]         ;896
0001a2  4788              BLX      r1                    ;896
                  |L9.420|
0001a4  e01d              B        |L9.482|
                  |L9.422|
0001a6  6be0              LDR      r0,[r4,#0x3c]         ;902
0001a8  b1d8              CBZ      r0,|L9.482|
0001aa  4620              MOV      r0,r4                 ;905
0001ac  6be1              LDR      r1,[r4,#0x3c]         ;905
0001ae  4788              BLX      r1                    ;905
0001b0  e017              B        |L9.482|
                  |L9.434|
0001b2  6820              LDR      r0,[r4,#0]            ;912
0001b4  6800              LDR      r0,[r0,#0]            ;912
0001b6  f4007080          AND      r0,r0,#0x100          ;912
0001ba  b968              CBNZ     r0,|L9.472|
0001bc  6820              LDR      r0,[r4,#0]            ;915
0001be  6800              LDR      r0,[r0,#0]            ;915
0001c0  f0200010          BIC      r0,r0,#0x10           ;915
0001c4  6821              LDR      r1,[r4,#0]            ;915
0001c6  6008              STR      r0,[r1,#0]            ;915
0001c8  bf00              NOP                            ;918
0001ca  2000              MOVS     r0,#0                 ;918
0001cc  f8840034          STRB     r0,[r4,#0x34]         ;918
0001d0  bf00              NOP                            ;918
0001d2  2001              MOVS     r0,#1                 ;921
0001d4  f8840035          STRB     r0,[r4,#0x35]         ;921
                  |L9.472|
0001d8  6be0              LDR      r0,[r4,#0x3c]         ;924
0001da  b110              CBZ      r0,|L9.482|
0001dc  4620              MOV      r0,r4                 ;927
0001de  6be1              LDR      r1,[r4,#0x3c]         ;927
0001e0  4788              BLX      r1                    ;927
                  |L9.482|
0001e2  6d60              LDR      r0,[r4,#0x54]         ;934
0001e4  b338              CBZ      r0,|L9.566|
0001e6  6d60              LDR      r0,[r4,#0x54]         ;936
0001e8  f0000001          AND      r0,r0,#1              ;936
0001ec  b1f0              CBZ      r0,|L9.556|
0001ee  2005              MOVS     r0,#5                 ;938
0001f0  f8840035          STRB     r0,[r4,#0x35]         ;938
0001f4  6820              LDR      r0,[r4,#0]            ;941
0001f6  6800              LDR      r0,[r0,#0]            ;941
0001f8  f0200001          BIC      r0,r0,#1              ;941
0001fc  6821              LDR      r1,[r4,#0]            ;941
0001fe  6008              STR      r0,[r1,#0]            ;941
000200  bf00              NOP                            ;943
                  |L9.514|
000202  9800              LDR      r0,[sp,#0]            ;945
000204  1c40              ADDS     r0,r0,#1              ;945
000206  9000              STR      r0,[sp,#0]            ;945
000208  42b8              CMP      r0,r7                 ;945
00020a  d900              BLS      |L9.526|
00020c  e005              B        |L9.538|
                  |L9.526|
00020e  6820              LDR      r0,[r4,#0]            ;950
000210  6800              LDR      r0,[r0,#0]            ;950
000212  f0000001          AND      r0,r0,#1              ;950
000216  2800              CMP      r0,#0                 ;950
000218  d1f3              BNE      |L9.514|
                  |L9.538|
00021a  bf00              NOP                            ;947
00021c  bf00              NOP                            ;953
00021e  2000              MOVS     r0,#0                 ;953
000220  f8840034          STRB     r0,[r4,#0x34]         ;953
000224  bf00              NOP                            ;953
000226  2001              MOVS     r0,#1                 ;956
000228  f8840035          STRB     r0,[r4,#0x35]         ;956
                  |L9.556|
00022c  6ce0              LDR      r0,[r4,#0x4c]         ;959
00022e  b110              CBZ      r0,|L9.566|
000230  4620              MOV      r0,r4                 ;962
000232  6ce1              LDR      r1,[r4,#0x4c]         ;962
000234  4788              BLX      r1                    ;962
                  |L9.566|
000236  bf00              NOP      
000238  e7a4              B        |L9.388|
;;;966    
                          ENDP

00023a  0000              DCW      0x0000
                  |L9.572|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_DMA_Init||, CODE, READONLY, ALIGN=2

                  HAL_DMA_Init PROC
;;;186      */
;;;187    HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;188    {
000004  4604              MOV      r4,r0
;;;189      uint32_t tmp = 0U;
000006  2500              MOVS     r5,#0
;;;190      uint32_t tickstart = HAL_GetTick();
000008  f7fffffe          BL       HAL_GetTick
00000c  4607              MOV      r7,r0
;;;191      DMA_Base_Registers *regs;
;;;192    
;;;193      /* Check the DMA peripheral state */
;;;194      if(hdma == NULL)
00000e  b914              CBNZ     r4,|L10.22|
;;;195      {
;;;196        return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L10.18|
;;;197      }
;;;198    
;;;199      /* Check the parameters */
;;;200      assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));
;;;201      assert_param(IS_DMA_CHANNEL(hdma->Init.Channel));
;;;202      assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
;;;203      assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
;;;204      assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
;;;205      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
;;;206      assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
;;;207      assert_param(IS_DMA_MODE(hdma->Init.Mode));
;;;208      assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
;;;209      assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
;;;210      /* Check the memory burst, peripheral burst and FIFO threshold parameters only
;;;211         when FIFO mode is enabled */
;;;212      if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
;;;213      {
;;;214        assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
;;;215        assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
;;;216        assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
;;;217      }
;;;218      
;;;219      /* Allocate lock resource */
;;;220      __HAL_UNLOCK(hdma);
;;;221    
;;;222      /* Change DMA peripheral state */
;;;223      hdma->State = HAL_DMA_STATE_BUSY;
;;;224      
;;;225      /* Disable the peripheral */
;;;226      __HAL_DMA_DISABLE(hdma);
;;;227      
;;;228      /* Check if the DMA Stream is effectively disabled */
;;;229      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
;;;230      {
;;;231        /* Check for the Timeout */
;;;232        if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
;;;233        {
;;;234          /* Update error code */
;;;235          hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;236          
;;;237          /* Change the DMA state */
;;;238          hdma->State = HAL_DMA_STATE_TIMEOUT;
;;;239          
;;;240          return HAL_TIMEOUT;
;;;241        }
;;;242      }
;;;243      
;;;244      /* Get the CR register value */
;;;245      tmp = hdma->Instance->CR;
;;;246    
;;;247      /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
;;;248      tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
;;;249                          DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
;;;250                          DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
;;;251                          DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));
;;;252    
;;;253      /* Prepare the DMA Stream configuration */
;;;254      tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
;;;255              hdma->Init.PeriphInc           | hdma->Init.MemInc           |
;;;256              hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
;;;257              hdma->Init.Mode                | hdma->Init.Priority;
;;;258    
;;;259      /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
;;;260      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;261      {
;;;262        /* Get memory burst and peripheral burst */
;;;263        tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
;;;264      }
;;;265      
;;;266      /* Write to DMA Stream CR register */
;;;267      hdma->Instance->CR = tmp;  
;;;268    
;;;269      /* Get the FCR register value */
;;;270      tmp = hdma->Instance->FCR;
;;;271    
;;;272      /* Clear Direct mode and FIFO threshold bits */
;;;273      tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
;;;274    
;;;275      /* Prepare the DMA Stream FIFO configuration */
;;;276      tmp |= hdma->Init.FIFOMode;
;;;277    
;;;278      /* The FIFO threshold is not used when the FIFO mode is disabled */
;;;279      if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
;;;280      {
;;;281        /* Get the FIFO threshold */
;;;282        tmp |= hdma->Init.FIFOThreshold;
;;;283        
;;;284        /* Check compatibility between FIFO threshold level and size of the memory burst */
;;;285        /* for INCR4, INCR8, INCR16 bursts */
;;;286        if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
;;;287        {
;;;288          if (DMA_CheckFifoParam(hdma) != HAL_OK)
;;;289          {
;;;290            /* Update error code */
;;;291            hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
;;;292            
;;;293            /* Change the DMA state */
;;;294            hdma->State = HAL_DMA_STATE_READY;
;;;295            
;;;296            return HAL_ERROR; 
;;;297          }
;;;298        }
;;;299      }
;;;300      
;;;301      /* Write to DMA Stream FCR */
;;;302      hdma->Instance->FCR = tmp;
;;;303    
;;;304      /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
;;;305         DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
;;;306      regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
;;;307      
;;;308      /* Clear all interrupt flags */
;;;309      regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;310    
;;;311      /* Initialize the error code */
;;;312      hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;313                                                                                         
;;;314      /* Initialize the DMA state */
;;;315      hdma->State = HAL_DMA_STATE_READY;
;;;316    
;;;317      return HAL_OK;
;;;318    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L10.22|
000016  6a60              LDR      r0,[r4,#0x24]         ;212
000018  b100              CBZ      r0,|L10.28|
00001a  bf00              NOP                            ;216
                  |L10.28|
00001c  bf00              NOP                            ;220
00001e  2000              MOVS     r0,#0                 ;220
000020  f8840034          STRB     r0,[r4,#0x34]         ;220
000024  bf00              NOP                            ;220
000026  2002              MOVS     r0,#2                 ;223
000028  f8840035          STRB     r0,[r4,#0x35]         ;223
00002c  6820              LDR      r0,[r4,#0]            ;226
00002e  6800              LDR      r0,[r0,#0]            ;226
000030  f0200001          BIC      r0,r0,#1              ;226
000034  6821              LDR      r1,[r4,#0]            ;226
000036  6008              STR      r0,[r1,#0]            ;226
000038  e00a              B        |L10.80|
                  |L10.58|
00003a  f7fffffe          BL       HAL_GetTick
00003e  1bc0              SUBS     r0,r0,r7              ;232
000040  2805              CMP      r0,#5                 ;232
000042  d905              BLS      |L10.80|
000044  2020              MOVS     r0,#0x20              ;235
000046  6560              STR      r0,[r4,#0x54]         ;235
000048  2003              MOVS     r0,#3                 ;238
00004a  f8840035          STRB     r0,[r4,#0x35]         ;238
00004e  e7e0              B        |L10.18|
                  |L10.80|
000050  6820              LDR      r0,[r4,#0]            ;229
000052  6800              LDR      r0,[r0,#0]            ;229
000054  f0000001          AND      r0,r0,#1              ;229
000058  2800              CMP      r0,#0                 ;229
00005a  d1ee              BNE      |L10.58|
00005c  6820              LDR      r0,[r4,#0]            ;245
00005e  6805              LDR      r5,[r0,#0]            ;245
000060  4821              LDR      r0,|L10.232|
000062  4005              ANDS     r5,r5,r0              ;248
000064  e9d40101          LDRD     r0,r1,[r4,#4]         ;254
000068  4308              ORRS     r0,r0,r1              ;254
00006a  68e1              LDR      r1,[r4,#0xc]          ;254
00006c  4308              ORRS     r0,r0,r1              ;254
00006e  6921              LDR      r1,[r4,#0x10]         ;254
000070  4308              ORRS     r0,r0,r1              ;254
000072  6961              LDR      r1,[r4,#0x14]         ;254
000074  4308              ORRS     r0,r0,r1              ;254
000076  69a1              LDR      r1,[r4,#0x18]         ;254
000078  4308              ORRS     r0,r0,r1              ;254
00007a  69e1              LDR      r1,[r4,#0x1c]         ;254
00007c  4308              ORRS     r0,r0,r1              ;254
00007e  6a21              LDR      r1,[r4,#0x20]         ;254
000080  4308              ORRS     r0,r0,r1              ;254
000082  4305              ORRS     r5,r5,r0              ;254
000084  6a60              LDR      r0,[r4,#0x24]         ;260
000086  2804              CMP      r0,#4                 ;260
000088  d103              BNE      |L10.146|
00008a  e9d4010b          LDRD     r0,r1,[r4,#0x2c]      ;263
00008e  4308              ORRS     r0,r0,r1              ;263
000090  4305              ORRS     r5,r5,r0              ;263
                  |L10.146|
000092  6820              LDR      r0,[r4,#0]            ;267
000094  6005              STR      r5,[r0,#0]            ;267
000096  6820              LDR      r0,[r4,#0]            ;270
000098  6945              LDR      r5,[r0,#0x14]         ;270
00009a  f0250507          BIC      r5,r5,#7              ;273
00009e  6a60              LDR      r0,[r4,#0x24]         ;276
0000a0  4305              ORRS     r5,r5,r0              ;276
0000a2  6a60              LDR      r0,[r4,#0x24]         ;279
0000a4  2804              CMP      r0,#4                 ;279
0000a6  d10d              BNE      |L10.196|
0000a8  6aa0              LDR      r0,[r4,#0x28]         ;282
0000aa  4305              ORRS     r5,r5,r0              ;282
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;286
0000ae  b148              CBZ      r0,|L10.196|
0000b0  4620              MOV      r0,r4                 ;288
0000b2  f7fffffe          BL       DMA_CheckFifoParam
0000b6  b128              CBZ      r0,|L10.196|
0000b8  2040              MOVS     r0,#0x40              ;291
0000ba  6560              STR      r0,[r4,#0x54]         ;291
0000bc  2001              MOVS     r0,#1                 ;294
0000be  f8840035          STRB     r0,[r4,#0x35]         ;294
0000c2  e7a6              B        |L10.18|
                  |L10.196|
0000c4  6820              LDR      r0,[r4,#0]            ;302
0000c6  6145              STR      r5,[r0,#0x14]         ;302
0000c8  4620              MOV      r0,r4                 ;306
0000ca  f7fffffe          BL       DMA_CalcBaseAndBitshift
0000ce  4606              MOV      r6,r0                 ;306
0000d0  f894105c          LDRB     r1,[r4,#0x5c]         ;309
0000d4  203f              MOVS     r0,#0x3f              ;309
0000d6  4088              LSLS     r0,r0,r1              ;309
0000d8  60b0              STR      r0,[r6,#8]            ;309
0000da  2000              MOVS     r0,#0                 ;312
0000dc  6560              STR      r0,[r4,#0x54]         ;312
0000de  2001              MOVS     r0,#1                 ;315
0000e0  f8840035          STRB     r0,[r4,#0x35]         ;315
0000e4  2000              MOVS     r0,#0                 ;317
0000e6  e794              B        |L10.18|
;;;319    
                          ENDP

                  |L10.232|
                          DCD      0xf010803f

                          AREA ||i.HAL_DMA_PollForTransfer||, CODE, READONLY, ALIGN=1

                  HAL_DMA_PollForTransfer PROC
;;;619      */
;;;620    HAL_StatusTypeDef HAL_DMA_PollForTransfer(DMA_HandleTypeDef *hdma, HAL_DMA_LevelCompleteTypeDef CompleteLevel, uint32_t Timeout)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;621    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
;;;622      HAL_StatusTypeDef status = HAL_OK; 
00000a  f04f0a00          MOV      r10,#0
;;;623      uint32_t mask_cpltlevel;
;;;624      uint32_t tickstart = HAL_GetTick(); 
00000e  f7fffffe          BL       HAL_GetTick
000012  4683              MOV      r11,r0
;;;625      uint32_t tmpisr;
;;;626      
;;;627      /* calculate DMA base and stream number */
;;;628      DMA_Base_Registers *regs;
;;;629    
;;;630      if(HAL_DMA_STATE_BUSY != hdma->State)
000014  f8940035          LDRB     r0,[r4,#0x35]
000018  2802              CMP      r0,#2
00001a  d009              BEQ      |L11.48|
;;;631      {
;;;632        /* No transfer ongoing */
;;;633        hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
00001c  2080              MOVS     r0,#0x80
00001e  6560              STR      r0,[r4,#0x54]
;;;634        __HAL_UNLOCK(hdma);
000020  bf00              NOP      
000022  2000              MOVS     r0,#0
000024  f8840034          STRB     r0,[r4,#0x34]
000028  bf00              NOP      
;;;635        return HAL_ERROR;
00002a  2001              MOVS     r0,#1
                  |L11.44|
;;;636      }
;;;637    
;;;638      /* Polling mode not supported in circular mode and double buffering mode */
;;;639      if ((hdma->Instance->CR & DMA_SxCR_CIRC) != RESET)
;;;640      {
;;;641        hdma->ErrorCode = HAL_DMA_ERROR_NOT_SUPPORTED;
;;;642        return HAL_ERROR;
;;;643      }
;;;644      
;;;645      /* Get the level transfer complete flag */
;;;646      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;647      {
;;;648        /* Transfer Complete flag */
;;;649        mask_cpltlevel = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
;;;650      }
;;;651      else
;;;652      {
;;;653        /* Half Transfer Complete flag */
;;;654        mask_cpltlevel = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
;;;655      }
;;;656      
;;;657      regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
;;;658      tmpisr = regs->ISR;
;;;659      
;;;660      while(((tmpisr & mask_cpltlevel) == RESET) && ((hdma->ErrorCode & HAL_DMA_ERROR_TE) == RESET))
;;;661      {
;;;662        /* Check for the Timeout (Not applicable in circular mode)*/
;;;663        if(Timeout != HAL_MAX_DELAY)
;;;664        {
;;;665          if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
;;;666          {
;;;667            /* Update error code */
;;;668            hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
;;;669    
;;;670            /* Process Unlocked */
;;;671            __HAL_UNLOCK(hdma);
;;;672            
;;;673            /* Change the DMA state */
;;;674            hdma->State = HAL_DMA_STATE_READY;
;;;675            
;;;676            return HAL_TIMEOUT;
;;;677          }
;;;678        }
;;;679    
;;;680        /* Get the ISR register value */
;;;681        tmpisr = regs->ISR;
;;;682    
;;;683        if((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
;;;684        {
;;;685          /* Update error code */
;;;686          hdma->ErrorCode |= HAL_DMA_ERROR_TE;
;;;687          
;;;688          /* Clear the transfer error flag */
;;;689          regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
;;;690        }
;;;691        
;;;692        if((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
;;;693        {
;;;694          /* Update error code */
;;;695          hdma->ErrorCode |= HAL_DMA_ERROR_FE;
;;;696          
;;;697          /* Clear the FIFO error flag */
;;;698          regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
;;;699        }
;;;700        
;;;701        if((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
;;;702        {
;;;703          /* Update error code */
;;;704          hdma->ErrorCode |= HAL_DMA_ERROR_DME;
;;;705          
;;;706          /* Clear the Direct Mode error flag */
;;;707          regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
;;;708        }
;;;709      }
;;;710      
;;;711      if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
;;;712      {
;;;713        if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
;;;714        {
;;;715          HAL_DMA_Abort(hdma);
;;;716        
;;;717          /* Clear the half transfer and transfer complete flags */
;;;718          regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;719        
;;;720          /* Process Unlocked */
;;;721          __HAL_UNLOCK(hdma);
;;;722    
;;;723          /* Change the DMA state */
;;;724          hdma->State= HAL_DMA_STATE_READY;
;;;725    
;;;726          return HAL_ERROR;
;;;727       }
;;;728      }
;;;729      
;;;730      /* Get the level transfer complete flag */
;;;731      if(CompleteLevel == HAL_DMA_FULL_TRANSFER)
;;;732      {
;;;733        /* Clear the half transfer and transfer complete flags */
;;;734        regs->IFCR = (DMA_FLAG_HTIF0_4 | DMA_FLAG_TCIF0_4) << hdma->StreamIndex;
;;;735        
;;;736        /* Process Unlocked */
;;;737        __HAL_UNLOCK(hdma);
;;;738    
;;;739        hdma->State = HAL_DMA_STATE_READY;
;;;740      }
;;;741      else
;;;742      {
;;;743        /* Clear the half transfer and transfer complete flags */
;;;744        regs->IFCR = (DMA_FLAG_HTIF0_4) << hdma->StreamIndex;
;;;745      }
;;;746      
;;;747      return status;
;;;748    }
00002c  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.48|
000030  6820              LDR      r0,[r4,#0]            ;639
000032  6800              LDR      r0,[r0,#0]            ;639
000034  f4007080          AND      r0,r0,#0x100          ;639
000038  b120              CBZ      r0,|L11.68|
00003a  f44f7080          MOV      r0,#0x100             ;641
00003e  6560              STR      r0,[r4,#0x54]         ;641
000040  2001              MOVS     r0,#1                 ;642
000042  e7f3              B        |L11.44|
                  |L11.68|
000044  f1b80f00          CMP      r8,#0                 ;646
000048  d105              BNE      |L11.86|
00004a  f894105c          LDRB     r1,[r4,#0x5c]         ;649
00004e  2020              MOVS     r0,#0x20              ;649
000050  fa00f901          LSL      r9,r0,r1              ;649
000054  e004              B        |L11.96|
                  |L11.86|
000056  f894105c          LDRB     r1,[r4,#0x5c]         ;654
00005a  2010              MOVS     r0,#0x10              ;654
00005c  fa00f901          LSL      r9,r0,r1              ;654
                  |L11.96|
000060  6da5              LDR      r5,[r4,#0x58]         ;657
000062  682e              LDR      r6,[r5,#0]            ;658
000064  e042              B        |L11.236|
                  |L11.102|
000066  1c78              ADDS     r0,r7,#1              ;663
000068  b190              CBZ      r0,|L11.144|
00006a  b12f              CBZ      r7,|L11.120|
00006c  f7fffffe          BL       HAL_GetTick
000070  eba0000b          SUB      r0,r0,r11             ;665
000074  42b8              CMP      r0,r7                 ;665
000076  d90b              BLS      |L11.144|
                  |L11.120|
000078  2020              MOVS     r0,#0x20              ;668
00007a  6560              STR      r0,[r4,#0x54]         ;668
00007c  bf00              NOP                            ;671
00007e  2000              MOVS     r0,#0                 ;671
000080  f8840034          STRB     r0,[r4,#0x34]         ;671
000084  bf00              NOP                            ;671
000086  2001              MOVS     r0,#1                 ;674
000088  f8840035          STRB     r0,[r4,#0x35]         ;674
00008c  2003              MOVS     r0,#3                 ;676
00008e  e7cd              B        |L11.44|
                  |L11.144|
000090  682e              LDR      r6,[r5,#0]            ;681
000092  f894105c          LDRB     r1,[r4,#0x5c]         ;683
000096  2008              MOVS     r0,#8                 ;683
000098  4088              LSLS     r0,r0,r1              ;683
00009a  4030              ANDS     r0,r0,r6              ;683
00009c  b140              CBZ      r0,|L11.176|
00009e  6d60              LDR      r0,[r4,#0x54]         ;686
0000a0  f0400001          ORR      r0,r0,#1              ;686
0000a4  6560              STR      r0,[r4,#0x54]         ;686
0000a6  f894105c          LDRB     r1,[r4,#0x5c]         ;689
0000aa  2008              MOVS     r0,#8                 ;689
0000ac  4088              LSLS     r0,r0,r1              ;689
0000ae  60a8              STR      r0,[r5,#8]            ;689
                  |L11.176|
0000b0  f894105c          LDRB     r1,[r4,#0x5c]         ;692
0000b4  2001              MOVS     r0,#1                 ;692
0000b6  4088              LSLS     r0,r0,r1              ;692
0000b8  4030              ANDS     r0,r0,r6              ;692
0000ba  b140              CBZ      r0,|L11.206|
0000bc  6d60              LDR      r0,[r4,#0x54]         ;695
0000be  f0400002          ORR      r0,r0,#2              ;695
0000c2  6560              STR      r0,[r4,#0x54]         ;695
0000c4  f894105c          LDRB     r1,[r4,#0x5c]         ;698
0000c8  2001              MOVS     r0,#1                 ;698
0000ca  4088              LSLS     r0,r0,r1              ;698
0000cc  60a8              STR      r0,[r5,#8]            ;698
                  |L11.206|
0000ce  f894105c          LDRB     r1,[r4,#0x5c]         ;701
0000d2  2004              MOVS     r0,#4                 ;701
0000d4  4088              LSLS     r0,r0,r1              ;701
0000d6  4030              ANDS     r0,r0,r6              ;701
0000d8  b140              CBZ      r0,|L11.236|
0000da  6d60              LDR      r0,[r4,#0x54]         ;704
0000dc  f0400004          ORR      r0,r0,#4              ;704
0000e0  6560              STR      r0,[r4,#0x54]         ;704
0000e2  f894105c          LDRB     r1,[r4,#0x5c]         ;707
0000e6  2004              MOVS     r0,#4                 ;707
0000e8  4088              LSLS     r0,r0,r1              ;707
0000ea  60a8              STR      r0,[r5,#8]            ;707
                  |L11.236|
0000ec  ea060009          AND      r0,r6,r9              ;660
0000f0  b920              CBNZ     r0,|L11.252|
0000f2  6d60              LDR      r0,[r4,#0x54]         ;660
0000f4  f0000001          AND      r0,r0,#1              ;660
0000f8  2800              CMP      r0,#0                 ;660
0000fa  d0b4              BEQ      |L11.102|
                  |L11.252|
0000fc  6d60              LDR      r0,[r4,#0x54]         ;711
0000fe  b1a0              CBZ      r0,|L11.298|
000100  6d60              LDR      r0,[r4,#0x54]         ;713
000102  f0000001          AND      r0,r0,#1              ;713
000106  b180              CBZ      r0,|L11.298|
000108  4620              MOV      r0,r4                 ;715
00010a  f7fffffe          BL       HAL_DMA_Abort
00010e  f894105c          LDRB     r1,[r4,#0x5c]         ;718
000112  2030              MOVS     r0,#0x30              ;718
000114  4088              LSLS     r0,r0,r1              ;718
000116  60a8              STR      r0,[r5,#8]            ;718
000118  bf00              NOP                            ;721
00011a  2000              MOVS     r0,#0                 ;721
00011c  f8840034          STRB     r0,[r4,#0x34]         ;721
000120  bf00              NOP                            ;721
000122  2001              MOVS     r0,#1                 ;724
000124  f8840035          STRB     r0,[r4,#0x35]         ;724
000128  e780              B        |L11.44|
                  |L11.298|
00012a  f1b80f00          CMP      r8,#0                 ;731
00012e  d10d              BNE      |L11.332|
000130  f894105c          LDRB     r1,[r4,#0x5c]         ;734
000134  2030              MOVS     r0,#0x30              ;734
000136  4088              LSLS     r0,r0,r1              ;734
000138  60a8              STR      r0,[r5,#8]            ;734
00013a  bf00              NOP                            ;737
00013c  2000              MOVS     r0,#0                 ;737
00013e  f8840034          STRB     r0,[r4,#0x34]         ;737
000142  bf00              NOP                            ;737
000144  2001              MOVS     r0,#1                 ;739
000146  f8840035          STRB     r0,[r4,#0x35]         ;739
00014a  e004              B        |L11.342|
                  |L11.332|
00014c  f894105c          LDRB     r1,[r4,#0x5c]         ;744
000150  2010              MOVS     r0,#0x10              ;744
000152  4088              LSLS     r0,r0,r1              ;744
000154  60a8              STR      r0,[r5,#8]            ;744
                  |L11.342|
000156  4650              MOV      r0,r10                ;747
000158  e768              B        |L11.44|
;;;749    
                          ENDP


                          AREA ||i.HAL_DMA_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_RegisterCallback PROC
;;;976      */                      
;;;977    HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
000000  b510              PUSH     {r4,lr}
;;;978    {
000002  4603              MOV      r3,r0
;;;979    
;;;980      HAL_StatusTypeDef status = HAL_OK;
000004  2400              MOVS     r4,#0
;;;981    
;;;982      /* Process locked */
;;;983      __HAL_LOCK(hdma);
000006  bf00              NOP      
000008  f8930034          LDRB     r0,[r3,#0x34]
00000c  2801              CMP      r0,#1
00000e  d101              BNE      |L12.20|
000010  2002              MOVS     r0,#2
                  |L12.18|
;;;984    
;;;985      if(HAL_DMA_STATE_READY == hdma->State)
;;;986      {
;;;987        switch (CallbackID)
;;;988        {
;;;989        case  HAL_DMA_XFER_CPLT_CB_ID:
;;;990          hdma->XferCpltCallback = pCallback;
;;;991          break;
;;;992    
;;;993        case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;994          hdma->XferHalfCpltCallback = pCallback;
;;;995          break;
;;;996    
;;;997        case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;998          hdma->XferM1CpltCallback = pCallback;
;;;999          break;
;;;1000   
;;;1001       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1002         hdma->XferM1HalfCpltCallback = pCallback;
;;;1003         break;
;;;1004   
;;;1005       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1006         hdma->XferErrorCallback = pCallback;
;;;1007         break;
;;;1008   
;;;1009       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1010         hdma->XferAbortCallback = pCallback;
;;;1011         break;
;;;1012   
;;;1013       default:
;;;1014         break;
;;;1015       }
;;;1016     }
;;;1017     else
;;;1018     {
;;;1019       /* Return error status */
;;;1020       status =  HAL_ERROR;
;;;1021     }
;;;1022   
;;;1023     /* Release Lock */
;;;1024     __HAL_UNLOCK(hdma);
;;;1025     
;;;1026     return status;
;;;1027   }
000012  bd10              POP      {r4,pc}
                  |L12.20|
000014  2001              MOVS     r0,#1                 ;983
000016  f8830034          STRB     r0,[r3,#0x34]         ;983
00001a  bf00              NOP                            ;983
00001c  f8930035          LDRB     r0,[r3,#0x35]         ;985
000020  2801              CMP      r0,#1                 ;985
000022  d114              BNE      |L12.78|
000024  2906              CMP      r1,#6                 ;987
000026  d210              BCS      |L12.74|
000028  e8dff001          TBB      [pc,r1]               ;987
00002c  03050709          DCB      0x03,0x05,0x07,0x09
000030  0b0d              DCB      0x0b,0x0d
000032  63da              STR      r2,[r3,#0x3c]         ;990
000034  e00a              B        |L12.76|
000036  641a              STR      r2,[r3,#0x40]         ;994
000038  e008              B        |L12.76|
00003a  645a              STR      r2,[r3,#0x44]         ;998
00003c  e006              B        |L12.76|
00003e  649a              STR      r2,[r3,#0x48]         ;1002
000040  e004              B        |L12.76|
000042  64da              STR      r2,[r3,#0x4c]         ;1006
000044  e002              B        |L12.76|
000046  651a              STR      r2,[r3,#0x50]         ;1010
000048  e000              B        |L12.76|
                  |L12.74|
00004a  bf00              NOP                            ;1014
                  |L12.76|
00004c  e000              B        |L12.80|
                  |L12.78|
00004e  2401              MOVS     r4,#1                 ;1020
                  |L12.80|
000050  bf00              NOP                            ;1024
000052  2000              MOVS     r0,#0                 ;1024
000054  f8830034          STRB     r0,[r3,#0x34]         ;1024
000058  bf00              NOP                            ;1024
00005a  4620              MOV      r0,r4                 ;1026
00005c  e7d9              B        |L12.18|
;;;1028   
                          ENDP


                          AREA ||i.HAL_DMA_Start||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start PROC
;;;415      */
;;;416    HAL_StatusTypeDef HAL_DMA_Start(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;417    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;418      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;419      
;;;420      /* Check the parameters */
;;;421      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;422    
;;;423      /* Process locked */
;;;424      __HAL_LOCK(hdma);
000010  bf00              NOP      
000012  f8940034          LDRB     r0,[r4,#0x34]
000016  2801              CMP      r0,#1
000018  d102              BNE      |L13.32|
00001a  2002              MOVS     r0,#2
                  |L13.28|
;;;425    
;;;426      if(HAL_DMA_STATE_READY == hdma->State)
;;;427      {
;;;428        /* Change DMA peripheral state */
;;;429        hdma->State = HAL_DMA_STATE_BUSY;
;;;430        
;;;431        /* Initialize the error code */
;;;432        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;433        
;;;434        /* Configure the source, destination address and the data length */
;;;435        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;436    
;;;437        /* Enable the Peripheral */
;;;438        __HAL_DMA_ENABLE(hdma);
;;;439      }
;;;440      else
;;;441      {
;;;442        /* Process unlocked */
;;;443        __HAL_UNLOCK(hdma);
;;;444        
;;;445        /* Return error status */
;;;446        status = HAL_BUSY;
;;;447      } 
;;;448      return status; 
;;;449    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L13.32|
000020  2001              MOVS     r0,#1                 ;424
000022  f8840034          STRB     r0,[r4,#0x34]         ;424
000026  bf00              NOP                            ;424
000028  f8940035          LDRB     r0,[r4,#0x35]         ;426
00002c  2801              CMP      r0,#1                 ;426
00002e  d111              BNE      |L13.84|
000030  2002              MOVS     r0,#2                 ;429
000032  f8840035          STRB     r0,[r4,#0x35]         ;429
000036  2000              MOVS     r0,#0                 ;432
000038  6560              STR      r0,[r4,#0x54]         ;432
00003a  463b              MOV      r3,r7                 ;435
00003c  4632              MOV      r2,r6                 ;435
00003e  4629              MOV      r1,r5                 ;435
000040  4620              MOV      r0,r4                 ;435
000042  f7fffffe          BL       DMA_SetConfig
000046  6820              LDR      r0,[r4,#0]            ;438
000048  6800              LDR      r0,[r0,#0]            ;438
00004a  f0400001          ORR      r0,r0,#1              ;438
00004e  6821              LDR      r1,[r4,#0]            ;438
000050  6008              STR      r0,[r1,#0]            ;438
000052  e006              B        |L13.98|
                  |L13.84|
000054  bf00              NOP                            ;443
000056  2000              MOVS     r0,#0                 ;443
000058  f8840034          STRB     r0,[r4,#0x34]         ;443
00005c  bf00              NOP                            ;443
00005e  f04f0802          MOV      r8,#2                 ;446
                  |L13.98|
000062  4640              MOV      r0,r8                 ;448
000064  e7da              B        |L13.28|
;;;450    
                          ENDP


                          AREA ||i.HAL_DMA_Start_IT||, CODE, READONLY, ALIGN=1

                  HAL_DMA_Start_IT PROC
;;;459      */
;;;460    HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;461    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;462      HAL_StatusTypeDef status = HAL_OK;
00000c  f04f0800          MOV      r8,#0
;;;463    
;;;464      /* calculate DMA base and stream number */
;;;465      DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
000010  f8d49058          LDR      r9,[r4,#0x58]
;;;466      
;;;467      /* Check the parameters */
;;;468      assert_param(IS_DMA_BUFFER_SIZE(DataLength));
;;;469     
;;;470      /* Process locked */
;;;471      __HAL_LOCK(hdma);
000014  bf00              NOP      
000016  f8940034          LDRB     r0,[r4,#0x34]
00001a  2801              CMP      r0,#1
00001c  d102              BNE      |L14.36|
00001e  2002              MOVS     r0,#2
                  |L14.32|
;;;472      
;;;473      if(HAL_DMA_STATE_READY == hdma->State)
;;;474      {
;;;475        /* Change DMA peripheral state */
;;;476        hdma->State = HAL_DMA_STATE_BUSY;
;;;477        
;;;478        /* Initialize the error code */
;;;479        hdma->ErrorCode = HAL_DMA_ERROR_NONE;
;;;480        
;;;481        /* Configure the source, destination address and the data length */
;;;482        DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
;;;483        
;;;484        /* Clear all interrupt flags at correct offset within the register */
;;;485        regs->IFCR = 0x3FU << hdma->StreamIndex;
;;;486        
;;;487        /* Enable Common interrupts*/
;;;488        hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
;;;489        hdma->Instance->FCR |= DMA_IT_FE;
;;;490        
;;;491        if(hdma->XferHalfCpltCallback != NULL)
;;;492        {
;;;493          hdma->Instance->CR  |= DMA_IT_HT;
;;;494        }
;;;495        
;;;496        /* Enable the Peripheral */
;;;497        __HAL_DMA_ENABLE(hdma);
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Process unlocked */
;;;502        __HAL_UNLOCK(hdma);	  
;;;503        
;;;504        /* Return error status */
;;;505        status = HAL_BUSY;
;;;506      }
;;;507      
;;;508      return status;
;;;509    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L14.36|
000024  2001              MOVS     r0,#1                 ;471
000026  f8840034          STRB     r0,[r4,#0x34]         ;471
00002a  bf00              NOP                            ;471
00002c  f8940035          LDRB     r0,[r4,#0x35]         ;473
000030  2801              CMP      r0,#1                 ;473
000032  d12b              BNE      |L14.140|
000034  2002              MOVS     r0,#2                 ;476
000036  f8840035          STRB     r0,[r4,#0x35]         ;476
00003a  2000              MOVS     r0,#0                 ;479
00003c  6560              STR      r0,[r4,#0x54]         ;479
00003e  463b              MOV      r3,r7                 ;482
000040  4632              MOV      r2,r6                 ;482
000042  4629              MOV      r1,r5                 ;482
000044  4620              MOV      r0,r4                 ;482
000046  f7fffffe          BL       DMA_SetConfig
00004a  f894105c          LDRB     r1,[r4,#0x5c]         ;485
00004e  203f              MOVS     r0,#0x3f              ;485
000050  4088              LSLS     r0,r0,r1              ;485
000052  f8c90008          STR      r0,[r9,#8]            ;485
000056  6820              LDR      r0,[r4,#0]            ;488
000058  6800              LDR      r0,[r0,#0]            ;488
00005a  f0400016          ORR      r0,r0,#0x16           ;488
00005e  6821              LDR      r1,[r4,#0]            ;488
000060  6008              STR      r0,[r1,#0]            ;488
000062  6820              LDR      r0,[r4,#0]            ;489
000064  6940              LDR      r0,[r0,#0x14]         ;489
000066  f0400080          ORR      r0,r0,#0x80           ;489
00006a  6821              LDR      r1,[r4,#0]            ;489
00006c  6148              STR      r0,[r1,#0x14]         ;489
00006e  6c20              LDR      r0,[r4,#0x40]         ;491
000070  b128              CBZ      r0,|L14.126|
000072  6820              LDR      r0,[r4,#0]            ;493
000074  6800              LDR      r0,[r0,#0]            ;493
000076  f0400008          ORR      r0,r0,#8              ;493
00007a  6821              LDR      r1,[r4,#0]            ;493
00007c  6008              STR      r0,[r1,#0]            ;493
                  |L14.126|
00007e  6820              LDR      r0,[r4,#0]            ;497
000080  6800              LDR      r0,[r0,#0]            ;497
000082  f0400001          ORR      r0,r0,#1              ;497
000086  6821              LDR      r1,[r4,#0]            ;497
000088  6008              STR      r0,[r1,#0]            ;497
00008a  e006              B        |L14.154|
                  |L14.140|
00008c  bf00              NOP                            ;502
00008e  2000              MOVS     r0,#0                 ;502
000090  f8840034          STRB     r0,[r4,#0x34]         ;502
000094  bf00              NOP                            ;502
000096  f04f0802          MOV      r8,#2                 ;505
                  |L14.154|
00009a  4640              MOV      r0,r8                 ;508
00009c  e7c0              B        |L14.32|
;;;510    
                          ENDP


                          AREA ||i.HAL_DMA_UnRegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_DMA_UnRegisterCallback PROC
;;;1036     */              
;;;1037   HAL_StatusTypeDef HAL_DMA_UnRegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID)
000000  4602              MOV      r2,r0
;;;1038   {
;;;1039     HAL_StatusTypeDef status = HAL_OK;
000002  2300              MOVS     r3,#0
;;;1040     
;;;1041     /* Process locked */
;;;1042     __HAL_LOCK(hdma);
000004  bf00              NOP      
000006  f8920034          LDRB     r0,[r2,#0x34]
00000a  2801              CMP      r0,#1
00000c  d101              BNE      |L15.18|
00000e  2002              MOVS     r0,#2
                  |L15.16|
;;;1043     
;;;1044     if(HAL_DMA_STATE_READY == hdma->State)
;;;1045     {
;;;1046       switch (CallbackID)
;;;1047       {
;;;1048       case  HAL_DMA_XFER_CPLT_CB_ID:
;;;1049         hdma->XferCpltCallback = NULL;
;;;1050         break;
;;;1051         
;;;1052       case  HAL_DMA_XFER_HALFCPLT_CB_ID:
;;;1053         hdma->XferHalfCpltCallback = NULL;
;;;1054         break;
;;;1055         
;;;1056       case  HAL_DMA_XFER_M1CPLT_CB_ID:
;;;1057         hdma->XferM1CpltCallback = NULL;
;;;1058         break;
;;;1059         
;;;1060       case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
;;;1061         hdma->XferM1HalfCpltCallback = NULL;
;;;1062         break;
;;;1063         
;;;1064       case  HAL_DMA_XFER_ERROR_CB_ID:
;;;1065         hdma->XferErrorCallback = NULL;
;;;1066         break;
;;;1067         
;;;1068       case  HAL_DMA_XFER_ABORT_CB_ID:
;;;1069         hdma->XferAbortCallback = NULL;
;;;1070         break; 
;;;1071         
;;;1072       case   HAL_DMA_XFER_ALL_CB_ID:
;;;1073         hdma->XferCpltCallback = NULL;
;;;1074         hdma->XferHalfCpltCallback = NULL;
;;;1075         hdma->XferM1CpltCallback = NULL;
;;;1076         hdma->XferM1HalfCpltCallback = NULL;
;;;1077         hdma->XferErrorCallback = NULL;
;;;1078         hdma->XferAbortCallback = NULL;
;;;1079         break; 
;;;1080         
;;;1081       default:
;;;1082         status = HAL_ERROR;
;;;1083         break;
;;;1084       }
;;;1085     }
;;;1086     else
;;;1087     {
;;;1088       status = HAL_ERROR;
;;;1089     }
;;;1090     
;;;1091     /* Release Lock */
;;;1092     __HAL_UNLOCK(hdma);
;;;1093     
;;;1094     return status;
;;;1095   }
000010  4770              BX       lr
                  |L15.18|
000012  2001              MOVS     r0,#1                 ;1042
000014  f8820034          STRB     r0,[r2,#0x34]         ;1042
000018  bf00              NOP                            ;1042
00001a  f8920035          LDRB     r0,[r2,#0x35]         ;1044
00001e  2801              CMP      r0,#1                 ;1044
000020  d124              BNE      |L15.108|
000022  2907              CMP      r1,#7                 ;1046
000024  d21f              BCS      |L15.102|
000026  e8dff001          TBB      [pc,r1]               ;1046
00002a  0407              DCB      0x04,0x07
00002c  0a0d1013          DCB      0x0a,0x0d,0x10,0x13
000030  1600              DCB      0x16,0x00
000032  2000              MOVS     r0,#0                 ;1049
000034  63d0              STR      r0,[r2,#0x3c]         ;1049
000036  e018              B        |L15.106|
000038  2000              MOVS     r0,#0                 ;1053
00003a  6410              STR      r0,[r2,#0x40]         ;1053
00003c  e015              B        |L15.106|
00003e  2000              MOVS     r0,#0                 ;1057
000040  6450              STR      r0,[r2,#0x44]         ;1057
000042  e012              B        |L15.106|
000044  2000              MOVS     r0,#0                 ;1061
000046  6490              STR      r0,[r2,#0x48]         ;1061
000048  e00f              B        |L15.106|
00004a  2000              MOVS     r0,#0                 ;1065
00004c  64d0              STR      r0,[r2,#0x4c]         ;1065
00004e  e00c              B        |L15.106|
000050  2000              MOVS     r0,#0                 ;1069
000052  6510              STR      r0,[r2,#0x50]         ;1069
000054  e009              B        |L15.106|
000056  2000              MOVS     r0,#0                 ;1073
000058  63d0              STR      r0,[r2,#0x3c]         ;1073
00005a  6410              STR      r0,[r2,#0x40]         ;1074
00005c  6450              STR      r0,[r2,#0x44]         ;1075
00005e  6490              STR      r0,[r2,#0x48]         ;1076
000060  64d0              STR      r0,[r2,#0x4c]         ;1077
000062  6510              STR      r0,[r2,#0x50]         ;1078
000064  e001              B        |L15.106|
                  |L15.102|
000066  2301              MOVS     r3,#1                 ;1082
000068  bf00              NOP                            ;1083
                  |L15.106|
00006a  e000              B        |L15.110|
                  |L15.108|
00006c  2301              MOVS     r3,#1                 ;1088
                  |L15.110|
00006e  bf00              NOP                            ;1092
000070  2000              MOVS     r0,#0                 ;1092
000072  f8820034          STRB     r0,[r2,#0x34]         ;1092
000076  bf00              NOP                            ;1092
000078  4618              MOV      r0,r3                 ;1094
00007a  e7c9              B        |L15.16|
;;;1096   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  flagBitshiftOffset
000000  00061016          DCB      0x00,0x06,0x10,0x16
000004  00061016          DCB      0x00,0x06,0x10,0x16

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REVSH|
#line 402
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_dma_c_c25f65ec____RRX|
#line 587
|__asm___19_stm32f4xx_hal_dma_c_c25f65ec____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
