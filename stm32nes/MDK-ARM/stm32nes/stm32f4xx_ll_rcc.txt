; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_ll_rcc.o --depend=stm32nes\stm32f4xx_ll_rcc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_ll_rcc.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_rcc.c]
                          THUMB

                          AREA ||i.LL_RCC_DeInit||, CODE, READONLY, ALIGN=2

                  LL_RCC_DeInit PROC
;;;201      */
;;;202    ErrorStatus LL_RCC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;203    {
;;;204      uint32_t vl_mask = 0U;
000002  2400              MOVS     r4,#0
;;;205    
;;;206      /* Set HSION bit */
;;;207      LL_RCC_HSI_Enable();
000004  bf00              NOP      
000006  4833              LDR      r0,|L1.212|
000008  6800              LDR      r0,[r0,#0]
00000a  f0400001          ORR      r0,r0,#1
00000e  4931              LDR      r1,|L1.212|
000010  6008              STR      r0,[r1,#0]
000012  bf00              NOP      
;;;208    
;;;209      /* Wait for HSI READY bit */
;;;210      while(LL_RCC_HSI_IsReady() != 1U)
000014  bf00              NOP      
                  |L1.22|
000016  bf00              NOP      
000018  482e              LDR      r0,|L1.212|
00001a  6800              LDR      r0,[r0,#0]
00001c  f3c00040          UBFX     r0,r0,#1,#1
000020  2800              CMP      r0,#0
000022  d0f8              BEQ      |L1.22|
;;;211      {}
;;;212    
;;;213      /* Reset CFGR register */
;;;214      LL_RCC_WriteReg(CFGR, 0x00000000U);
000024  2000              MOVS     r0,#0
000026  492b              LDR      r1,|L1.212|
000028  3108              ADDS     r1,r1,#8
00002a  6008              STR      r0,[r1,#0]
;;;215    
;;;216      vl_mask = 0xFFFFFFFFU;
00002c  1e44              SUBS     r4,r0,#1
;;;217    
;;;218      /* Reset HSEON, PLLSYSON bits */
;;;219      CLEAR_BIT(vl_mask, (RCC_CR_HSEON | RCC_CR_HSEBYP | RCC_CR_PLLON | RCC_CR_CSSON));
00002e  482a              LDR      r0,|L1.216|
000030  4004              ANDS     r4,r4,r0
;;;220    
;;;221    #if defined(RCC_PLLSAI_SUPPORT)
;;;222      /* Reset PLLSAION bit */
;;;223      CLEAR_BIT(vl_mask, RCC_CR_PLLSAION);
000032  f0245480          BIC      r4,r4,#0x10000000
;;;224    #endif /* RCC_PLLSAI_SUPPORT */
;;;225    
;;;226    #if defined(RCC_PLLI2S_SUPPORT)
;;;227      /* Reset PLLI2SON bit */
;;;228      CLEAR_BIT(vl_mask, RCC_CR_PLLI2SON);
000036  f0246480          BIC      r4,r4,#0x4000000
;;;229    #endif /* RCC_PLLI2S_SUPPORT */
;;;230    
;;;231      /* Write new mask in CR register */
;;;232      LL_RCC_WriteReg(CR, vl_mask);
00003a  4826              LDR      r0,|L1.212|
00003c  6004              STR      r4,[r0,#0]
;;;233    
;;;234      /* Set HSITRIM bits to the reset value*/
;;;235      LL_RCC_HSI_SetCalibTrimming(0x10U);
00003e  2010              MOVS     r0,#0x10
000040  4924              LDR      r1,|L1.212|
000042  6809              LDR      r1,[r1,#0]
000044  f02101f8          BIC      r1,r1,#0xf8
000048  ea4101c0          ORR      r1,r1,r0,LSL #3
00004c  4a21              LDR      r2,|L1.212|
00004e  6011              STR      r1,[r2,#0]
000050  bf00              NOP      
;;;236    
;;;237      /* Wait for PLL READY bit to be reset */
;;;238      while(LL_RCC_PLL_IsReady() != 0U)
000052  bf00              NOP      
                  |L1.84|
000054  f7fffffe          BL       LL_RCC_PLL_IsReady
000058  2800              CMP      r0,#0
00005a  d1fb              BNE      |L1.84|
;;;239      {}
;;;240    
;;;241      /* Reset PLLCFGR register */
;;;242      LL_RCC_WriteReg(PLLCFGR, RCC_PLLCFGR_RST_VALUE);
00005c  481f              LDR      r0,|L1.220|
00005e  491d              LDR      r1,|L1.212|
000060  1d09              ADDS     r1,r1,#4
000062  6008              STR      r0,[r1,#0]
;;;243    
;;;244    #if defined(RCC_PLLI2S_SUPPORT)
;;;245      /* Reset PLLI2SCFGR register */
;;;246      LL_RCC_WriteReg(PLLI2SCFGR, RCC_PLLI2SCFGR_RST_VALUE);
000064  481d              LDR      r0,|L1.220|
000066  3810              SUBS     r0,r0,#0x10
000068  491a              LDR      r1,|L1.212|
00006a  3184              ADDS     r1,r1,#0x84
00006c  6008              STR      r0,[r1,#0]
;;;247    #endif /* RCC_PLLI2S_SUPPORT */
;;;248    
;;;249    #if defined(RCC_PLLSAI_SUPPORT)
;;;250      /* Reset PLLSAICFGR register */
;;;251      LL_RCC_WriteReg(PLLSAICFGR, RCC_PLLSAICFGR_RST_VALUE);
00006e  1d09              ADDS     r1,r1,#4
000070  6008              STR      r0,[r1,#0]
;;;252    #endif /* RCC_PLLSAI_SUPPORT */
;;;253    
;;;254      /* Disable all interrupts */
;;;255      CLEAR_BIT(RCC->CIR, RCC_CIR_LSIRDYIE | RCC_CIR_LSERDYIE | RCC_CIR_HSIRDYIE | RCC_CIR_HSERDYIE | RCC_CIR_PLLRDYIE);
000072  4818              LDR      r0,|L1.212|
000074  300c              ADDS     r0,r0,#0xc
000076  6800              LDR      r0,[r0,#0]
000078  f42050f8          BIC      r0,r0,#0x1f00
00007c  4915              LDR      r1,|L1.212|
00007e  310c              ADDS     r1,r1,#0xc
000080  6008              STR      r0,[r1,#0]
;;;256    
;;;257    #if defined(RCC_CIR_PLLI2SRDYIE)
;;;258      CLEAR_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYIE);
000082  4608              MOV      r0,r1
000084  6800              LDR      r0,[r0,#0]
000086  f4205000          BIC      r0,r0,#0x2000
00008a  6008              STR      r0,[r1,#0]
;;;259    #endif /* RCC_CIR_PLLI2SRDYIE */
;;;260    
;;;261    #if defined(RCC_CIR_PLLSAIRDYIE)
;;;262      CLEAR_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYIE);
00008c  4608              MOV      r0,r1
00008e  6800              LDR      r0,[r0,#0]
000090  f4204080          BIC      r0,r0,#0x4000
000094  6008              STR      r0,[r1,#0]
;;;263    #endif /* RCC_CIR_PLLSAIRDYIE */
;;;264    
;;;265      /* Clear all interrupt flags */
;;;266      SET_BIT(RCC->CIR, RCC_CIR_LSIRDYC | RCC_CIR_LSERDYC | RCC_CIR_HSIRDYC | RCC_CIR_HSERDYC | RCC_CIR_PLLRDYC | RCC_CIR_CSSC);
000096  4608              MOV      r0,r1
000098  6800              LDR      r0,[r0,#0]
00009a  f440001f          ORR      r0,r0,#0x9f0000
00009e  6008              STR      r0,[r1,#0]
;;;267    
;;;268    #if defined(RCC_CIR_PLLI2SRDYC)
;;;269      SET_BIT(RCC->CIR, RCC_CIR_PLLI2SRDYC);
0000a0  4608              MOV      r0,r1
0000a2  6800              LDR      r0,[r0,#0]
0000a4  f4401000          ORR      r0,r0,#0x200000
0000a8  6008              STR      r0,[r1,#0]
;;;270    #endif /* RCC_CIR_PLLI2SRDYC */
;;;271    
;;;272    #if defined(RCC_CIR_PLLSAIRDYC)
;;;273      SET_BIT(RCC->CIR, RCC_CIR_PLLSAIRDYC);
0000aa  4608              MOV      r0,r1
0000ac  6800              LDR      r0,[r0,#0]
0000ae  f4400080          ORR      r0,r0,#0x400000
0000b2  6008              STR      r0,[r1,#0]
;;;274    #endif /* RCC_CIR_PLLSAIRDYC */
;;;275    
;;;276      /* Clear LSION bit */
;;;277      CLEAR_BIT(RCC->CSR, RCC_CSR_LSION);
0000b4  4807              LDR      r0,|L1.212|
0000b6  3074              ADDS     r0,r0,#0x74
0000b8  6800              LDR      r0,[r0,#0]
0000ba  f0200001          BIC      r0,r0,#1
0000be  4905              LDR      r1,|L1.212|
0000c0  3174              ADDS     r1,r1,#0x74
0000c2  6008              STR      r0,[r1,#0]
;;;278    
;;;279      /* Reset all CSR flags */
;;;280      SET_BIT(RCC->CSR, RCC_CSR_RMVF);
0000c4  4608              MOV      r0,r1
0000c6  6800              LDR      r0,[r0,#0]
0000c8  f0407080          ORR      r0,r0,#0x1000000
0000cc  6008              STR      r0,[r1,#0]
;;;281    
;;;282      return SUCCESS;
0000ce  2001              MOVS     r0,#1
;;;283    }
0000d0  bd10              POP      {r4,pc}
;;;284    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L1.212|
                          DCD      0x40023800
                  |L1.216|
                          DCD      0xfef2ffff
                  |L1.220|
                          DCD      0x24003010

                          AREA ||i.LL_RCC_GetI2SClockFreq||, CODE, READONLY, ALIGN=2

                  LL_RCC_GetI2SClockFreq PROC
;;;384      */
;;;385    uint32_t LL_RCC_GetI2SClockFreq(uint32_t I2SxSource)
000000  b570              PUSH     {r4-r6,lr}
;;;386    {
000002  4604              MOV      r4,r0
;;;387      uint32_t i2s_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000004  2500              MOVS     r5,#0
;;;388    
;;;389      /* Check parameter */
;;;390      assert_param(IS_LL_RCC_I2S_CLKSOURCE(I2SxSource));
;;;391    
;;;392      if (I2SxSource == LL_RCC_I2S1_CLKSOURCE)
000006  f5b40f00          CMP      r4,#0x800000
00000a  d113              BNE      |L2.52|
;;;393      {
;;;394        /* I2S1 CLK clock frequency */
;;;395        switch (LL_RCC_GetI2SClockSource(I2SxSource))
00000c  bf00              NOP      
00000e  480a              LDR      r0,|L2.56|
000010  6800              LDR      r0,[r0,#0]
000012  4020              ANDS     r0,r0,r4
000014  b118              CBZ      r0,|L2.30|
000016  f5b00f00          CMP      r0,#0x800000
00001a  d107              BNE      |L2.44|
00001c  e007              B        |L2.46|
                  |L2.30|
;;;396        {
;;;397    #if defined(RCC_PLLI2S_SUPPORT)
;;;398          case LL_RCC_I2S1_CLKSOURCE_PLLI2S:       /* I2S1 Clock is PLLI2S */
;;;399            if (LL_RCC_PLLI2S_IsReady())
00001e  f7fffffe          BL       LL_RCC_PLLI2S_IsReady
000022  b110              CBZ      r0,|L2.42|
;;;400            {
;;;401              i2s_frequency = RCC_PLLI2S_GetFreqDomain_I2S();
000024  f7fffffe          BL       RCC_PLLI2S_GetFreqDomain_I2S
000028  4605              MOV      r5,r0
                  |L2.42|
;;;402            }
;;;403            break;
00002a  e002              B        |L2.50|
                  |L2.44|
;;;404    #endif /* RCC_PLLI2S_SUPPORT */
;;;405    
;;;406    #if defined(RCC_DCKCFGR_I2SSRC) || defined(RCC_DCKCFGR_I2S1SRC)
;;;407          case LL_RCC_I2S1_CLKSOURCE_PLL:          /* I2S1 Clock is PLL */
;;;408            if (LL_RCC_PLL_IsReady())
;;;409            {
;;;410              i2s_frequency = RCC_PLL_GetFreqDomain_I2S();
;;;411            }
;;;412            break;
;;;413    
;;;414          case LL_RCC_I2S1_CLKSOURCE_PLLSRC:       /* I2S1 Clock is PLL Main source */
;;;415            switch (LL_RCC_PLL_GetMainSource())
;;;416            {
;;;417               case LL_RCC_PLLSOURCE_HSE:          /* I2S1 Clock is HSE Osc. */
;;;418                 if (LL_RCC_HSE_IsReady())
;;;419                 {
;;;420                   i2s_frequency = HSE_VALUE;
;;;421                 }
;;;422                 break;
;;;423    
;;;424               case LL_RCC_PLLSOURCE_HSI:          /* I2S1 Clock is HSI Osc. */
;;;425               default:
;;;426                 if (LL_RCC_HSI_IsReady())
;;;427                 {
;;;428                   i2s_frequency = HSI_VALUE;
;;;429                 }
;;;430                 break;
;;;431            }
;;;432            break;
;;;433    #endif /* RCC_DCKCFGR_I2SSRC || RCC_DCKCFGR_I2S1SRC */
;;;434    
;;;435          case LL_RCC_I2S1_CLKSOURCE_PIN:          /* I2S1 Clock is External clock */
00002c  bf00              NOP      
                  |L2.46|
;;;436          default:
;;;437            i2s_frequency = EXTERNAL_CLOCK_VALUE;
00002e  4d03              LDR      r5,|L2.60|
;;;438            break;
000030  bf00              NOP      
                  |L2.50|
000032  bf00              NOP                            ;403
                  |L2.52|
;;;439        }
;;;440      }
;;;441    #if defined(RCC_DCKCFGR_I2S2SRC)
;;;442      else
;;;443      {
;;;444        /* I2S2 CLK clock frequency */
;;;445        switch (LL_RCC_GetI2SClockSource(I2SxSource))
;;;446        {
;;;447          case LL_RCC_I2S2_CLKSOURCE_PLLI2S:       /* I2S2 Clock is PLLI2S */
;;;448            if (LL_RCC_PLLI2S_IsReady())
;;;449            {
;;;450              i2s_frequency = RCC_PLLI2S_GetFreqDomain_I2S();
;;;451            }
;;;452            break;
;;;453    
;;;454          case LL_RCC_I2S2_CLKSOURCE_PLL:          /* I2S2 Clock is PLL */
;;;455            if (LL_RCC_PLL_IsReady())
;;;456            {
;;;457              i2s_frequency = RCC_PLL_GetFreqDomain_I2S();
;;;458            }
;;;459            break;
;;;460    
;;;461          case LL_RCC_I2S2_CLKSOURCE_PLLSRC:       /* I2S2 Clock is PLL Main source */
;;;462            switch (LL_RCC_PLL_GetMainSource())
;;;463            {
;;;464               case LL_RCC_PLLSOURCE_HSE:          /* I2S2 Clock is HSE Osc. */
;;;465                 if (LL_RCC_HSE_IsReady())
;;;466                 {
;;;467                   i2s_frequency = HSE_VALUE;
;;;468                 }
;;;469                 break;
;;;470    
;;;471               case LL_RCC_PLLSOURCE_HSI:          /* I2S2 Clock is HSI Osc. */
;;;472               default:
;;;473                 if (LL_RCC_HSI_IsReady())
;;;474                 {
;;;475                   i2s_frequency = HSI_VALUE;
;;;476                 }
;;;477                 break;
;;;478            }
;;;479            break;
;;;480    
;;;481          case LL_RCC_I2S2_CLKSOURCE_PIN:          /* I2S2 Clock is External clock */
;;;482          default:
;;;483            i2s_frequency = EXTERNAL_CLOCK_VALUE;
;;;484            break;
;;;485        } 
;;;486      }
;;;487    #endif /* RCC_DCKCFGR_I2S2SRC */
;;;488    
;;;489      return i2s_frequency;
000034  4628              MOV      r0,r5
;;;490    }
000036  bd70              POP      {r4-r6,pc}
;;;491    
                          ENDP

                  |L2.56|
                          DCD      0x40023808
                  |L2.60|
                          DCD      0x00bb8000

                          AREA ||i.LL_RCC_GetLTDCClockFreq||, CODE, READONLY, ALIGN=1

                  LL_RCC_GetLTDCClockFreq PROC
;;;1063     */
;;;1064   uint32_t LL_RCC_GetLTDCClockFreq(uint32_t LTDCxSource)
000000  b570              PUSH     {r4-r6,lr}
;;;1065   {
000002  4605              MOV      r5,r0
;;;1066     uint32_t ltdc_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000004  2400              MOVS     r4,#0
;;;1067   
;;;1068     /* Check parameter */
;;;1069     assert_param(IS_LL_RCC_LTDC_CLKSOURCE(LTDCxSource));
;;;1070   
;;;1071     if (LL_RCC_PLLSAI_IsReady())
000006  f7fffffe          BL       LL_RCC_PLLSAI_IsReady
00000a  b110              CBZ      r0,|L3.18|
;;;1072     {
;;;1073        ltdc_frequency = RCC_PLLSAI_GetFreqDomain_LTDC();
00000c  f7fffffe          BL       RCC_PLLSAI_GetFreqDomain_LTDC
000010  4604              MOV      r4,r0
                  |L3.18|
;;;1074     }
;;;1075   
;;;1076     return ltdc_frequency;
000012  4620              MOV      r0,r4
;;;1077   }
000014  bd70              POP      {r4-r6,pc}
;;;1078   #endif /* LTDC */
                          ENDP


                          AREA ||i.LL_RCC_GetRNGClockFreq||, CODE, READONLY, ALIGN=1

                  LL_RCC_GetRNGClockFreq PROC
;;;767      */
;;;768    uint32_t LL_RCC_GetRNGClockFreq(uint32_t RNGxSource)
000000  b570              PUSH     {r4-r6,lr}
;;;769    {
000002  4605              MOV      r5,r0
;;;770      uint32_t rng_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000004  2400              MOVS     r4,#0
;;;771    
;;;772      /* Check parameter */
;;;773      assert_param(IS_LL_RCC_RNG_CLKSOURCE(RNGxSource));
;;;774    
;;;775    #if defined(RCC_DCKCFGR_CK48MSEL) || defined(RCC_DCKCFGR2_CK48MSEL)
;;;776      /* RNGCLK clock frequency */
;;;777      switch (LL_RCC_GetRNGClockSource(RNGxSource))
;;;778      {
;;;779    #if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)
;;;780        case LL_RCC_RNG_CLKSOURCE_PLLI2S:        /* PLLI2S clock used as RNG clock source */
;;;781          if (LL_RCC_PLLI2S_IsReady())
;;;782          {
;;;783            rng_frequency = RCC_PLLI2S_GetFreqDomain_48M();
;;;784          }
;;;785          break;
;;;786    #endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */
;;;787    
;;;788    #if defined(RCC_PLLSAI_SUPPORT)
;;;789        case LL_RCC_RNG_CLKSOURCE_PLLSAI:        /* PLLSAI clock used as RNG clock source */
;;;790          if (LL_RCC_PLLSAI_IsReady())
;;;791          {
;;;792            rng_frequency = RCC_PLLSAI_GetFreqDomain_48M();
;;;793          }
;;;794          break;
;;;795    #endif /* RCC_PLLSAI_SUPPORT */
;;;796    
;;;797        case LL_RCC_RNG_CLKSOURCE_PLL:           /* PLL clock used as RNG clock source */
;;;798        default:
;;;799          if (LL_RCC_PLL_IsReady())
;;;800          {
;;;801            rng_frequency = RCC_PLL_GetFreqDomain_48M();
;;;802          }
;;;803          break;
;;;804      }
;;;805    #else
;;;806      /* PLL clock used as RNG clock source */
;;;807      if (LL_RCC_PLL_IsReady())
000006  f7fffffe          BL       LL_RCC_PLL_IsReady
00000a  b110              CBZ      r0,|L4.18|
;;;808      {
;;;809        rng_frequency = RCC_PLL_GetFreqDomain_48M();
00000c  f7fffffe          BL       RCC_PLL_GetFreqDomain_48M
000010  4604              MOV      r4,r0
                  |L4.18|
;;;810      }
;;;811    #endif /* RCC_DCKCFGR_CK48MSEL || RCC_DCKCFGR2_CK48MSEL */
;;;812    
;;;813      return rng_frequency;
000012  4620              MOV      r0,r4
;;;814    }
000014  bd70              POP      {r4-r6,pc}
;;;815    #endif /* RNG */
                          ENDP


                          AREA ||i.LL_RCC_GetSAIClockFreq||, CODE, READONLY, ALIGN=2

                  LL_RCC_GetSAIClockFreq PROC
;;;556      */
;;;557    uint32_t LL_RCC_GetSAIClockFreq(uint32_t SAIxSource)
000000  b570              PUSH     {r4-r6,lr}
;;;558    {
000002  4604              MOV      r4,r0
;;;559      uint32_t sai_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000004  2500              MOVS     r5,#0
;;;560    
;;;561      /* Check parameter */
;;;562      assert_param(IS_LL_RCC_SAI_CLKSOURCE(SAIxSource));
;;;563    
;;;564    #if defined(RCC_DCKCFGR_SAI1SRC)
;;;565      if ((SAIxSource == LL_RCC_SAI1_CLKSOURCE) || (SAIxSource == LL_RCC_SAI2_CLKSOURCE))
;;;566      {
;;;567        /* SAI1CLK clock frequency */
;;;568        switch (LL_RCC_GetSAIClockSource(SAIxSource))
;;;569        {
;;;570          case LL_RCC_SAI1_CLKSOURCE_PLLSAI:     /* PLLSAI clock used as SAI1 clock source */
;;;571          case LL_RCC_SAI2_CLKSOURCE_PLLSAI:     /* PLLSAI clock used as SAI2 clock source */
;;;572            if (LL_RCC_PLLSAI_IsReady())
;;;573            {
;;;574              sai_frequency = RCC_PLLSAI_GetFreqDomain_SAI();
;;;575            }
;;;576            break;
;;;577    
;;;578          case LL_RCC_SAI1_CLKSOURCE_PLLI2S:     /* PLLI2S clock used as SAI1 clock source */
;;;579          case LL_RCC_SAI2_CLKSOURCE_PLLI2S:     /* PLLI2S clock used as SAI2 clock source */
;;;580            if (LL_RCC_PLLI2S_IsReady())
;;;581            {
;;;582              sai_frequency = RCC_PLLI2S_GetFreqDomain_SAI();
;;;583            }
;;;584            break;
;;;585    
;;;586          case LL_RCC_SAI1_CLKSOURCE_PLL:        /* PLL clock used as SAI1 clock source */
;;;587          case LL_RCC_SAI2_CLKSOURCE_PLL:        /* PLL clock used as SAI2 clock source */
;;;588            if (LL_RCC_PLL_IsReady())
;;;589            {
;;;590              sai_frequency = RCC_PLL_GetFreqDomain_SAI();
;;;591            }
;;;592            break;
;;;593    
;;;594          case LL_RCC_SAI2_CLKSOURCE_PLLSRC:
;;;595            switch (LL_RCC_PLL_GetMainSource())
;;;596            {
;;;597               case LL_RCC_PLLSOURCE_HSE:        /* HSE clock used as SAI2 clock source */
;;;598                 if (LL_RCC_HSE_IsReady())
;;;599                 {
;;;600                   sai_frequency = HSE_VALUE;
;;;601                 }
;;;602                 break;
;;;603    
;;;604               case LL_RCC_PLLSOURCE_HSI:        /* HSI clock used as SAI2 clock source */
;;;605               default:
;;;606                 if (LL_RCC_HSI_IsReady())
;;;607                 {
;;;608                   sai_frequency = HSI_VALUE;
;;;609                 }
;;;610                 break;
;;;611            }
;;;612            break;
;;;613    
;;;614          case LL_RCC_SAI1_CLKSOURCE_PIN:        /* External input clock used as SAI1 clock source */
;;;615          default:
;;;616            sai_frequency = EXTERNAL_CLOCK_VALUE;
;;;617            break;
;;;618        }
;;;619      }
;;;620    #endif /* RCC_DCKCFGR_SAI1SRC */
;;;621    #if defined(RCC_DCKCFGR_SAI1ASRC)
;;;622      if ((SAIxSource == LL_RCC_SAI1_A_CLKSOURCE) || (SAIxSource == LL_RCC_SAI1_B_CLKSOURCE))
000006  f5b41f40          CMP      r4,#0x300000
00000a  d002              BEQ      |L5.18|
00000c  f5b40f40          CMP      r4,#0xc00000
000010  d12f              BNE      |L5.114|
                  |L5.18|
;;;623      {
;;;624        /* SAI1CLK clock frequency */
;;;625        switch (LL_RCC_GetSAIClockSource(SAIxSource))
000012  bf00              NOP      
000014  4818              LDR      r0,|L5.120|
000016  6800              LDR      r0,[r0,#0]
000018  4020              ANDS     r0,r0,r4
00001a  ea444010          ORR      r0,r4,r0,LSR #16
00001e  f5b00f40          CMP      r0,#0xc00000
000022  d012              BEQ      |L5.74|
000024  dc09              BGT      |L5.58|
000026  f5b01f40          CMP      r0,#0x300000
00002a  d00d              BEQ      |L5.72|
00002c  f5a01040          SUB      r0,r0,#0x300000
000030  3810              SUBS     r0,r0,#0x10
000032  b188              CBZ      r0,|L5.88|
000034  2810              CMP      r0,#0x10
000036  d117              BNE      |L5.104|
000038  e017              B        |L5.106|
                  |L5.58|
00003a  f5a00040          SUB      r0,r0,#0xc00000
00003e  3840              SUBS     r0,r0,#0x40
000040  b158              CBZ      r0,|L5.90|
000042  2840              CMP      r0,#0x40
000044  d110              BNE      |L5.104|
000046  e011              B        |L5.108|
                  |L5.72|
;;;626        {
;;;627    #if defined(RCC_PLLSAI_SUPPORT)
;;;628          case LL_RCC_SAI1_A_CLKSOURCE_PLLSAI:     /* PLLSAI clock used as SAI1 Block A clock source */
;;;629          case LL_RCC_SAI1_B_CLKSOURCE_PLLSAI:     /* PLLSAI clock used as SAI1 Block B clock source */
000048  bf00              NOP      
                  |L5.74|
;;;630            if (LL_RCC_PLLSAI_IsReady())
00004a  f7fffffe          BL       LL_RCC_PLLSAI_IsReady
00004e  b110              CBZ      r0,|L5.86|
;;;631            {
;;;632              sai_frequency = RCC_PLLSAI_GetFreqDomain_SAI();
000050  f7fffffe          BL       RCC_PLLSAI_GetFreqDomain_SAI
000054  4605              MOV      r5,r0
                  |L5.86|
;;;633            }
;;;634            break;
000056  e00b              B        |L5.112|
                  |L5.88|
;;;635    #endif /* RCC_PLLSAI_SUPPORT */
;;;636    
;;;637          case LL_RCC_SAI1_A_CLKSOURCE_PLLI2S:     /* PLLI2S clock used as SAI1 Block A clock source */
;;;638          case LL_RCC_SAI1_B_CLKSOURCE_PLLI2S:     /* PLLI2S clock used as SAI1 Block B clock source */
000058  bf00              NOP      
                  |L5.90|
;;;639            if (LL_RCC_PLLI2S_IsReady())
00005a  f7fffffe          BL       LL_RCC_PLLI2S_IsReady
00005e  b110              CBZ      r0,|L5.102|
;;;640            {
;;;641              sai_frequency = RCC_PLLI2S_GetFreqDomain_SAI();
000060  f7fffffe          BL       RCC_PLLI2S_GetFreqDomain_SAI
000064  4605              MOV      r5,r0
                  |L5.102|
;;;642            }
;;;643            break;
000066  e003              B        |L5.112|
                  |L5.104|
;;;644    
;;;645    #if defined(RCC_SAI1A_PLLSOURCE_SUPPORT)
;;;646          case LL_RCC_SAI1_A_CLKSOURCE_PLL:        /* PLL clock used as SAI1 Block A clock source */
;;;647          case LL_RCC_SAI1_B_CLKSOURCE_PLL:        /* PLL clock used as SAI1 Block B clock source */
;;;648            if (LL_RCC_PLL_IsReady())
;;;649            {
;;;650              sai_frequency = RCC_PLL_GetFreqDomain_SAI();
;;;651            }
;;;652            break;
;;;653    
;;;654          case LL_RCC_SAI1_A_CLKSOURCE_PLLSRC:
;;;655          case LL_RCC_SAI1_B_CLKSOURCE_PLLSRC:
;;;656            switch (LL_RCC_PLL_GetMainSource())
;;;657            {
;;;658               case LL_RCC_PLLSOURCE_HSE:          /* HSE clock used as SAI1 Block A or B clock source */
;;;659                 if (LL_RCC_HSE_IsReady())
;;;660                 {
;;;661                   sai_frequency = HSE_VALUE;
;;;662                 }
;;;663                 break;
;;;664    
;;;665               case LL_RCC_PLLSOURCE_HSI:          /* HSI clock used as SAI1 Block A or B clock source */
;;;666               default:
;;;667                 if (LL_RCC_HSI_IsReady())
;;;668                 {
;;;669                   sai_frequency = HSI_VALUE;
;;;670                 }
;;;671                 break;
;;;672            }
;;;673            break;
;;;674    #endif /* RCC_SAI1A_PLLSOURCE_SUPPORT */
;;;675    
;;;676          case LL_RCC_SAI1_A_CLKSOURCE_PIN:        /* External input clock used as SAI1 Block A clock source */
000068  bf00              NOP      
                  |L5.106|
;;;677          case LL_RCC_SAI1_B_CLKSOURCE_PIN:        /* External input clock used as SAI1 Block B clock source */
00006a  bf00              NOP      
                  |L5.108|
;;;678          default:
;;;679            sai_frequency = EXTERNAL_CLOCK_VALUE;
00006c  4d03              LDR      r5,|L5.124|
;;;680            break;
00006e  bf00              NOP      
                  |L5.112|
000070  bf00              NOP                            ;634
                  |L5.114|
;;;681        }
;;;682      }
;;;683    #endif /* RCC_DCKCFGR_SAI1ASRC */
;;;684    
;;;685      return sai_frequency;
000072  4628              MOV      r0,r5
;;;686    }
000074  bd70              POP      {r4-r6,pc}
;;;687    #endif /* SAI1 */
                          ENDP

000076  0000              DCW      0x0000
                  |L5.120|
                          DCD      0x4002388c
                  |L5.124|
                          DCD      0x00bb8000

                          AREA ||i.LL_RCC_GetSDIOClockFreq||, CODE, READONLY, ALIGN=1

                  LL_RCC_GetSDIOClockFreq PROC
;;;696      */
;;;697    uint32_t LL_RCC_GetSDIOClockFreq(uint32_t SDIOxSource)
000000  b570              PUSH     {r4-r6,lr}
;;;698    {
000002  4604              MOV      r4,r0
;;;699      uint32_t SDIO_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000004  2500              MOVS     r5,#0
;;;700    
;;;701      /* Check parameter */
;;;702      assert_param(IS_LL_RCC_SDIO_CLKSOURCE(SDIOxSource));
;;;703    
;;;704      if (SDIOxSource == LL_RCC_SDIO_CLKSOURCE)
000006  f1b46f70          CMP      r4,#0xf000000
00000a  d105              BNE      |L6.24|
;;;705      {
;;;706    #if defined(RCC_DCKCFGR_SDIOSEL) || defined(RCC_DCKCFGR2_SDIOSEL)
;;;707        /* SDIOCLK clock frequency */
;;;708        switch (LL_RCC_GetSDIOClockSource(SDIOxSource))
;;;709        {
;;;710          case LL_RCC_SDIO_CLKSOURCE_PLL48CLK:         /* PLL48M clock used as SDIO clock source */
;;;711            switch (LL_RCC_GetCK48MClockSource(LL_RCC_CK48M_CLKSOURCE))
;;;712            {
;;;713              case LL_RCC_CK48M_CLKSOURCE_PLL:         /* PLL clock used as 48Mhz domain clock */
;;;714                if (LL_RCC_PLL_IsReady())
;;;715                {
;;;716                  SDIO_frequency = RCC_PLL_GetFreqDomain_48M();
;;;717                }
;;;718              break;
;;;719    
;;;720    #if defined(RCC_PLLSAI_SUPPORT)
;;;721              case LL_RCC_CK48M_CLKSOURCE_PLLSAI:      /* PLLSAI clock used as 48Mhz domain clock */
;;;722              default:
;;;723                if (LL_RCC_PLLSAI_IsReady())
;;;724                {
;;;725                  SDIO_frequency = RCC_PLLSAI_GetFreqDomain_48M();
;;;726                }
;;;727                break;
;;;728    #endif /* RCC_PLLSAI_SUPPORT */
;;;729    
;;;730    #if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)
;;;731              case LL_RCC_CK48M_CLKSOURCE_PLLI2S:      /* PLLI2S clock used as 48Mhz domain clock */
;;;732              default:
;;;733                if (LL_RCC_PLLI2S_IsReady())
;;;734                {
;;;735                  SDIO_frequency = RCC_PLLI2S_GetFreqDomain_48M();
;;;736                }
;;;737                break;
;;;738    #endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */
;;;739            }
;;;740            break;
;;;741    
;;;742          case LL_RCC_SDIO_CLKSOURCE_SYSCLK:           /* PLL clock used as SDIO clock source */
;;;743          default:
;;;744          SDIO_frequency = RCC_GetSystemClockFreq();
;;;745          break;
;;;746        }
;;;747    #else
;;;748        /* PLL clock used as 48Mhz domain clock */
;;;749        if (LL_RCC_PLL_IsReady())
00000c  f7fffffe          BL       LL_RCC_PLL_IsReady
000010  b110              CBZ      r0,|L6.24|
;;;750        {
;;;751          SDIO_frequency = RCC_PLL_GetFreqDomain_48M();
000012  f7fffffe          BL       RCC_PLL_GetFreqDomain_48M
000016  4605              MOV      r5,r0
                  |L6.24|
;;;752        }
;;;753    #endif /* RCC_DCKCFGR_SDIOSEL || RCC_DCKCFGR2_SDIOSEL */
;;;754      }
;;;755    
;;;756      return SDIO_frequency;
000018  4628              MOV      r0,r5
;;;757    }
00001a  bd70              POP      {r4-r6,pc}
;;;758    #endif /* SDIO */
                          ENDP


                          AREA ||i.LL_RCC_GetSystemClocksFreq||, CODE, READONLY, ALIGN=1

                  LL_RCC_GetSystemClocksFreq PROC
;;;317      */
;;;318    void LL_RCC_GetSystemClocksFreq(LL_RCC_ClocksTypeDef *RCC_Clocks)
000000  b510              PUSH     {r4,lr}
;;;319    {
000002  4604              MOV      r4,r0
;;;320      /* Get SYSCLK frequency */
;;;321      RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
000004  f7fffffe          BL       RCC_GetSystemClockFreq
000008  6020              STR      r0,[r4,#0]
;;;322    
;;;323      /* HCLK clock frequency */
;;;324      RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
00000a  6820              LDR      r0,[r4,#0]
00000c  f7fffffe          BL       RCC_GetHCLKClockFreq
000010  6060              STR      r0,[r4,#4]
;;;325    
;;;326      /* PCLK1 clock frequency */
;;;327      RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
000012  6860              LDR      r0,[r4,#4]
000014  f7fffffe          BL       RCC_GetPCLK1ClockFreq
000018  60a0              STR      r0,[r4,#8]
;;;328    
;;;329      /* PCLK2 clock frequency */
;;;330      RCC_Clocks->PCLK2_Frequency  = RCC_GetPCLK2ClockFreq(RCC_Clocks->HCLK_Frequency);
00001a  6860              LDR      r0,[r4,#4]
00001c  f7fffffe          BL       RCC_GetPCLK2ClockFreq
000020  60e0              STR      r0,[r4,#0xc]
;;;331    }
000022  bd10              POP      {r4,pc}
;;;332    
                          ENDP


                          AREA ||i.LL_RCC_GetUSBClockFreq||, CODE, READONLY, ALIGN=1

                  LL_RCC_GetUSBClockFreq PROC
;;;862      */
;;;863    uint32_t LL_RCC_GetUSBClockFreq(uint32_t USBxSource)
000000  b570              PUSH     {r4-r6,lr}
;;;864    {
000002  4605              MOV      r5,r0
;;;865      uint32_t usb_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
000004  2400              MOVS     r4,#0
;;;866    
;;;867      /* Check parameter */
;;;868      assert_param(IS_LL_RCC_USB_CLKSOURCE(USBxSource));
;;;869    
;;;870    #if defined(RCC_DCKCFGR_CK48MSEL) || defined(RCC_DCKCFGR2_CK48MSEL)
;;;871      /* USBCLK clock frequency */
;;;872      switch (LL_RCC_GetUSBClockSource(USBxSource))
;;;873      {
;;;874    #if defined(RCC_PLLI2SCFGR_PLLI2SQ) && !defined(RCC_DCKCFGR_PLLI2SDIVQ)
;;;875        case LL_RCC_USB_CLKSOURCE_PLLI2S:       /* PLLI2S clock used as USB clock source */
;;;876          if (LL_RCC_PLLI2S_IsReady())
;;;877          {
;;;878            usb_frequency = RCC_PLLI2S_GetFreqDomain_48M();
;;;879          }
;;;880          break;
;;;881    
;;;882    #endif /* RCC_PLLI2SCFGR_PLLI2SQ && !RCC_DCKCFGR_PLLI2SDIVQ */
;;;883    
;;;884    #if defined(RCC_PLLSAI_SUPPORT)
;;;885        case LL_RCC_USB_CLKSOURCE_PLLSAI:       /* PLLSAI clock used as USB clock source */
;;;886          if (LL_RCC_PLLSAI_IsReady())
;;;887          {
;;;888            usb_frequency = RCC_PLLSAI_GetFreqDomain_48M();
;;;889          }
;;;890          break;
;;;891    #endif /* RCC_PLLSAI_SUPPORT */
;;;892    
;;;893        case LL_RCC_USB_CLKSOURCE_PLL:          /* PLL clock used as USB clock source */
;;;894        default:
;;;895          if (LL_RCC_PLL_IsReady())
;;;896          {
;;;897            usb_frequency = RCC_PLL_GetFreqDomain_48M();
;;;898          }
;;;899          break;
;;;900      }
;;;901    #else
;;;902      /* PLL clock used as USB clock source */
;;;903      if (LL_RCC_PLL_IsReady())
000006  f7fffffe          BL       LL_RCC_PLL_IsReady
00000a  b110              CBZ      r0,|L8.18|
;;;904      {
;;;905        usb_frequency = RCC_PLL_GetFreqDomain_48M();
00000c  f7fffffe          BL       RCC_PLL_GetFreqDomain_48M
000010  4604              MOV      r4,r0
                  |L8.18|
;;;906      }
;;;907    #endif /* RCC_DCKCFGR_CK48MSEL || RCC_DCKCFGR2_CK48MSEL */
;;;908    
;;;909      return usb_frequency;
000012  4620              MOV      r0,r4
;;;910    }
000014  bd70              POP      {r4-r6,pc}
;;;911    #endif /* USB_OTG_FS || USB_OTG_HS */
                          ENDP


                          AREA ||i.LL_RCC_PLLI2S_GetN||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLLI2S_GetN PROC
;;;5697     */
;;;5698   __STATIC_INLINE uint32_t LL_RCC_PLLI2S_GetN(void)
000000  4802              LDR      r0,|L9.12|
;;;5699   {
;;;5700     return (uint32_t)(READ_BIT(RCC->PLLI2SCFGR, RCC_PLLI2SCFGR_PLLI2SN) >> RCC_PLLI2SCFGR_PLLI2SN_Pos);
000002  6800              LDR      r0,[r0,#0]
000004  f3c01088          UBFX     r0,r0,#6,#9
;;;5701   }
000008  4770              BX       lr
;;;5702   
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0x40023884

                          AREA ||i.LL_RCC_PLLI2S_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLLI2S_IsReady PROC
;;;5170     */
;;;5171   __STATIC_INLINE uint32_t LL_RCC_PLLI2S_IsReady(void)
000000  4802              LDR      r0,|L10.12|
;;;5172   {
;;;5173     return (READ_BIT(RCC->CR, RCC_CR_PLLI2SRDY) == (RCC_CR_PLLI2SRDY));
000002  6800              LDR      r0,[r0,#0]
000004  f3c060c0          UBFX     r0,r0,#27,#1
;;;5174   }
000008  4770              BX       lr
;;;5175   
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x40023800

                          AREA ||i.LL_RCC_PLLSAI_GetN||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLLSAI_GetN PROC
;;;6419     */
;;;6420   __STATIC_INLINE uint32_t LL_RCC_PLLSAI_GetN(void)
000000  4802              LDR      r0,|L11.12|
;;;6421   {
;;;6422     return (uint32_t)(READ_BIT(RCC->PLLSAICFGR, RCC_PLLSAICFGR_PLLSAIN) >> RCC_PLLSAICFGR_PLLSAIN_Pos);
000002  6800              LDR      r0,[r0,#0]
000004  f3c01088          UBFX     r0,r0,#6,#9
;;;6423   }
000008  4770              BX       lr
;;;6424   
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x40023888

                          AREA ||i.LL_RCC_PLLSAI_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLLSAI_IsReady PROC
;;;5986     */
;;;5987   __STATIC_INLINE uint32_t LL_RCC_PLLSAI_IsReady(void)
000000  4802              LDR      r0,|L12.12|
;;;5988   {
;;;5989     return (READ_BIT(RCC->CR, RCC_CR_PLLSAIRDY) == (RCC_CR_PLLSAIRDY));
000002  6800              LDR      r0,[r0,#0]
000004  f3c07040          UBFX     r0,r0,#29,#1
;;;5990   }
000008  4770              BX       lr
;;;5991   
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      0x40023800

                          AREA ||i.LL_RCC_PLL_GetMainSource||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_GetMainSource PROC
;;;4873     */
;;;4874   __STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
000000  4802              LDR      r0,|L13.12|
;;;4875   {
;;;4876     return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
000002  6800              LDR      r0,[r0,#0]
000004  f4000080          AND      r0,r0,#0x400000
;;;4877   }
000008  4770              BX       lr
;;;4878   
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      0x40023804

                          AREA ||i.LL_RCC_PLL_GetN||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_GetN PROC
;;;4885     */
;;;4886   __STATIC_INLINE uint32_t LL_RCC_PLL_GetN(void)
000000  4802              LDR      r0,|L14.12|
;;;4887   {
;;;4888     return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
000002  6800              LDR      r0,[r0,#0]
000004  f3c01088          UBFX     r0,r0,#6,#9
;;;4889   }
000008  4770              BX       lr
;;;4890   
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      0x40023804

                          AREA ||i.LL_RCC_PLL_IsReady||, CODE, READONLY, ALIGN=2

                  LL_RCC_PLL_IsReady PROC
;;;4222     */
;;;4223   __STATIC_INLINE uint32_t LL_RCC_PLL_IsReady(void)
000000  4802              LDR      r0,|L15.12|
;;;4224   {
;;;4225     return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
000002  6800              LDR      r0,[r0,#0]
000004  f3c06040          UBFX     r0,r0,#25,#1
;;;4226   }
000008  4770              BX       lr
;;;4227   
                          ENDP

00000a  0000              DCW      0x0000
                  |L15.12|
                          DCD      0x40023800

                          AREA ||i.RCC_GetHCLKClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetHCLKClockFreq PROC
;;;1171     */
;;;1172   uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
000000  4601              MOV      r1,r0
;;;1173   {
;;;1174     /* HCLK clock frequency */
;;;1175     return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
000002  bf00              NOP      
000004  4804              LDR      r0,|L16.24|
000006  6800              LDR      r0,[r0,#0]
000008  f00000f0          AND      r0,r0,#0xf0
00000c  0900              LSRS     r0,r0,#4
00000e  4a03              LDR      r2,|L16.28|
000010  5c12              LDRB     r2,[r2,r0]
000012  fa21f002          LSR      r0,r1,r2
;;;1176   }
000016  4770              BX       lr
;;;1177   
                          ENDP

                  |L16.24|
                          DCD      0x40023808
                  |L16.28|
                          DCD      AHBPrescTable

                          AREA ||i.RCC_GetPCLK1ClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetPCLK1ClockFreq PROC
;;;1182     */
;;;1183   uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
000000  4601              MOV      r1,r0
;;;1184   {
;;;1185     /* PCLK1 clock frequency */
;;;1186     return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
000002  bf00              NOP      
000004  4805              LDR      r0,|L17.28|
000006  6800              LDR      r0,[r0,#0]
000008  f40050e0          AND      r0,r0,#0x1c00
00000c  4a04              LDR      r2,|L17.32|
00000e  eb022090          ADD      r0,r2,r0,LSR #10
000012  7802              LDRB     r2,[r0,#0]
000014  fa21f002          LSR      r0,r1,r2
;;;1187   }
000018  4770              BX       lr
;;;1188   
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      0x40023808
                  |L17.32|
                          DCD      APBPrescTable

                          AREA ||i.RCC_GetPCLK2ClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetPCLK2ClockFreq PROC
;;;1193     */
;;;1194   uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
000000  4601              MOV      r1,r0
;;;1195   {
;;;1196     /* PCLK2 clock frequency */
;;;1197     return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
000002  bf00              NOP      
000004  4805              LDR      r0,|L18.28|
000006  6800              LDR      r0,[r0,#0]
000008  f4004060          AND      r0,r0,#0xe000
00000c  4a04              LDR      r2,|L18.32|
00000e  eb023050          ADD      r0,r2,r0,LSR #13
000012  7802              LDRB     r2,[r0,#0]
000014  fa21f002          LSR      r0,r1,r2
;;;1198   }
000018  4770              BX       lr
;;;1199   
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      0x40023808
                  |L18.32|
                          DCD      APBPrescTable

                          AREA ||i.RCC_GetSystemClockFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetSystemClockFreq PROC
;;;1133     */
;;;1134   uint32_t RCC_GetSystemClockFreq(void)
000000  b510              PUSH     {r4,lr}
;;;1135   {
;;;1136     uint32_t frequency = 0U;
000002  2400              MOVS     r4,#0
;;;1137   
;;;1138     /* Get SYSCLK source -------------------------------------------------------*/
;;;1139     switch (LL_RCC_GetSysClkSource())
000004  bf00              NOP      
000006  480c              LDR      r0,|L19.56|
000008  6800              LDR      r0,[r0,#0]
00000a  f000000c          AND      r0,r0,#0xc
00000e  b120              CBZ      r0,|L19.26|
000010  2804              CMP      r0,#4
000012  d004              BEQ      |L19.30|
000014  2808              CMP      r0,#8
000016  d109              BNE      |L19.44|
000018  e003              B        |L19.34|
                  |L19.26|
;;;1140     {
;;;1141       case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */
;;;1142         frequency = HSI_VALUE;
00001a  4c08              LDR      r4,|L19.60|
;;;1143         break;
00001c  e008              B        |L19.48|
                  |L19.30|
;;;1144   
;;;1145       case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
;;;1146         frequency = HSE_VALUE;
00001e  4c08              LDR      r4,|L19.64|
;;;1147         break;
000020  e006              B        |L19.48|
                  |L19.34|
;;;1148   
;;;1149       case LL_RCC_SYS_CLKSOURCE_STATUS_PLL:  /* PLL used as system clock  source */
;;;1150         frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLL);
000022  2008              MOVS     r0,#8
000024  f7fffffe          BL       RCC_PLL_GetFreqDomain_SYS
000028  4604              MOV      r4,r0
;;;1151         break;
00002a  e001              B        |L19.48|
                  |L19.44|
;;;1152   
;;;1153   #if defined(RCC_PLLR_SYSCLK_SUPPORT)
;;;1154       case LL_RCC_SYS_CLKSOURCE_STATUS_PLLR: /* PLLR used as system clock  source */
;;;1155         frequency = RCC_PLL_GetFreqDomain_SYS(LL_RCC_SYS_CLKSOURCE_STATUS_PLLR);
;;;1156         break;
;;;1157   #endif /* RCC_PLLR_SYSCLK_SUPPORT */
;;;1158   
;;;1159       default:
;;;1160         frequency = HSI_VALUE;
00002c  4c03              LDR      r4,|L19.60|
;;;1161         break;
00002e  bf00              NOP      
                  |L19.48|
000030  bf00              NOP                            ;1143
;;;1162     }
;;;1163   
;;;1164     return frequency;
000032  4620              MOV      r0,r4
;;;1165   }
000034  bd10              POP      {r4,pc}
;;;1166   
                          ENDP

000036  0000              DCW      0x0000
                  |L19.56|
                          DCD      0x40023808
                  |L19.60|
                          DCD      0x00f42400
                  |L19.64|
                          DCD      0x007a1200

                          AREA ||i.RCC_PLLI2S_GetFreqDomain_I2S||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2S_GetFreqDomain_I2S PROC
;;;1588     */
;;;1589   uint32_t RCC_PLLI2S_GetFreqDomain_I2S(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1590   {
;;;1591     uint32_t plli2sinputfreq = 0U, plli2ssource = 0U, plli2soutputfreq = 0U;
000004  2400              MOVS     r4,#0
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
;;;1592   
;;;1593     /* PLLI2S_VCO = (HSE_VALUE or HSI_VALUE / PLLI2SM) * PLLI2SN
;;;1594        I2S Domain clock  = PLLI2S_VCO / PLLI2SR
;;;1595     */
;;;1596     plli2ssource = LL_RCC_PLLI2S_GetMainSource();
00000a  bf00              NOP      
00000c  4811              LDR      r0,|L20.84|
00000e  6800              LDR      r0,[r0,#0]
000010  f4000080          AND      r0,r0,#0x400000
000014  4605              MOV      r5,r0
;;;1597   
;;;1598     switch (plli2ssource)
000016  b12d              CBZ      r5,|L20.36|
000018  f5b50f80          CMP      r5,#0x400000
00001c  d101              BNE      |L20.34|
;;;1599     {
;;;1600       case LL_RCC_PLLSOURCE_HSE:     /* HSE used as PLLI2S clock source */
;;;1601         plli2sinputfreq = HSE_VALUE;
00001e  4c0e              LDR      r4,|L20.88|
;;;1602         break;
000020  e002              B        |L20.40|
                  |L20.34|
;;;1603   
;;;1604   #if defined(RCC_PLLI2SCFGR_PLLI2SSRC)
;;;1605       case LL_RCC_PLLI2SSOURCE_PIN:  /* External pin input clock used as PLLI2S clock source */
;;;1606         plli2sinputfreq = EXTERNAL_CLOCK_VALUE;
;;;1607         break;
;;;1608   #endif /* RCC_PLLI2SCFGR_PLLI2SSRC */
;;;1609   
;;;1610       case LL_RCC_PLLSOURCE_HSI:     /* HSI used as PLLI2S clock source */
000022  bf00              NOP      
                  |L20.36|
;;;1611       default:
;;;1612         plli2sinputfreq = HSI_VALUE;
000024  4c0d              LDR      r4,|L20.92|
;;;1613         break;
000026  bf00              NOP      
                  |L20.40|
000028  bf00              NOP                            ;1602
;;;1614     }
;;;1615   
;;;1616     plli2soutputfreq = __LL_RCC_CALC_PLLI2S_I2S_FREQ(plli2sinputfreq, LL_RCC_PLLI2S_GetDivider(),
00002a  bf00              NOP      
00002c  4809              LDR      r0,|L20.84|
00002e  6800              LDR      r0,[r0,#0]
000030  f000003f          AND      r0,r0,#0x3f
000034  fbb4f7f0          UDIV     r7,r4,r0
000038  f7fffffe          BL       LL_RCC_PLLI2S_GetN
00003c  4347              MULS     r7,r0,r7
00003e  4805              LDR      r0,|L20.84|
000040  3080              ADDS     r0,r0,#0x80
000042  6800              LDR      r0,[r0,#0]
000044  f00040e0          AND      r0,r0,#0x70000000
000048  0f00              LSRS     r0,r0,#28
00004a  fbb7f6f0          UDIV     r6,r7,r0
;;;1617                                                      LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetR());
;;;1618   
;;;1619     return plli2soutputfreq;
00004e  4630              MOV      r0,r6
;;;1620   }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;1621   
                          ENDP

                  |L20.84|
                          DCD      0x40023804
                  |L20.88|
                          DCD      0x007a1200
                  |L20.92|
                          DCD      0x00f42400

                          AREA ||i.RCC_PLLI2S_GetFreqDomain_SAI||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2S_GetFreqDomain_SAI PROC
;;;1512     */
;;;1513   uint32_t RCC_PLLI2S_GetFreqDomain_SAI(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1514   {
;;;1515     uint32_t plli2sinputfreq = 0U, plli2ssource = 0U, plli2soutputfreq = 0U;
000004  2400              MOVS     r4,#0
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
;;;1516   
;;;1517     /* PLLI2S_VCO = (HSE_VALUE or HSI_VALUE / PLLI2SM) * PLLI2SN
;;;1518        SAI domain clock  = (PLLI2S_VCO / PLLI2SQ) / PLLI2SDIVQ
;;;1519        or
;;;1520        SAI domain clock  = (PLLI2S_VCO / PLLI2SR) / PLLI2SDIVR
;;;1521     */
;;;1522     plli2ssource = LL_RCC_PLLI2S_GetMainSource();
00000a  bf00              NOP      
00000c  4815              LDR      r0,|L21.100|
00000e  6800              LDR      r0,[r0,#0]
000010  f4000080          AND      r0,r0,#0x400000
000014  4605              MOV      r5,r0
;;;1523   
;;;1524     switch (plli2ssource)
000016  b12d              CBZ      r5,|L21.36|
000018  f5b50f80          CMP      r5,#0x400000
00001c  d101              BNE      |L21.34|
;;;1525     {
;;;1526       case LL_RCC_PLLSOURCE_HSE:     /* HSE used as PLLI2S clock source */
;;;1527         plli2sinputfreq = HSE_VALUE;
00001e  4c12              LDR      r4,|L21.104|
;;;1528         break;
000020  e002              B        |L21.40|
                  |L21.34|
;;;1529   
;;;1530   #if defined(RCC_PLLI2SCFGR_PLLI2SSRC)
;;;1531       case LL_RCC_PLLI2SSOURCE_PIN:  /* External pin input clock used as PLLI2S clock source */
;;;1532         plli2sinputfreq = EXTERNAL_CLOCK_VALUE;
;;;1533         break;
;;;1534   #endif /* RCC_PLLI2SCFGR_PLLI2SSRC */
;;;1535   
;;;1536       case LL_RCC_PLLSOURCE_HSI:     /* HSI used as PLLI2S clock source */
000022  bf00              NOP      
                  |L21.36|
;;;1537       default:
;;;1538         plli2sinputfreq = HSI_VALUE;
000024  4c11              LDR      r4,|L21.108|
;;;1539         break;
000026  bf00              NOP      
                  |L21.40|
000028  bf00              NOP                            ;1528
;;;1540     }
;;;1541   
;;;1542   #if defined(RCC_DCKCFGR_PLLI2SDIVQ)
;;;1543     plli2soutputfreq = __LL_RCC_CALC_PLLI2S_SAI_FREQ(plli2sinputfreq, LL_RCC_PLLI2S_GetDivider(),
00002a  bf00              NOP      
00002c  480d              LDR      r0,|L21.100|
00002e  6800              LDR      r0,[r0,#0]
000030  f000003f          AND      r0,r0,#0x3f
000034  fbb4f7f0          UDIV     r7,r4,r0
000038  f7fffffe          BL       LL_RCC_PLLI2S_GetN
00003c  4347              MULS     r7,r0,r7
00003e  4809              LDR      r0,|L21.100|
000040  3080              ADDS     r0,r0,#0x80
000042  6800              LDR      r0,[r0,#0]
000044  f0006070          AND      r0,r0,#0xf000000
000048  0e01              LSRS     r1,r0,#24
00004a  4806              LDR      r0,|L21.100|
00004c  3088              ADDS     r0,r0,#0x88
00004e  6800              LDR      r0,[r0,#0]
000050  f000001f          AND      r0,r0,#0x1f
000054  1c40              ADDS     r0,r0,#1
000056  fb11f000          SMULBB   r0,r1,r0
00005a  fbb7f6f0          UDIV     r6,r7,r0
;;;1544                                             LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetQ(), LL_RCC_PLLI2S_GetDIVQ());
;;;1545   #else
;;;1546     plli2soutputfreq = __LL_RCC_CALC_PLLI2S_SAI_FREQ(plli2sinputfreq, LL_RCC_PLLI2S_GetDivider(),
;;;1547                                             LL_RCC_PLLI2S_GetN(), LL_RCC_PLLI2S_GetR(), LL_RCC_PLLI2S_GetDIVR());
;;;1548   #endif /* RCC_DCKCFGR_PLLI2SDIVQ */
;;;1549   
;;;1550     return plli2soutputfreq;
00005e  4630              MOV      r0,r6
;;;1551   }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;1552   #endif /* SAI1 */
                          ENDP

                  |L21.100|
                          DCD      0x40023804
                  |L21.104|
                          DCD      0x007a1200
                  |L21.108|
                          DCD      0x00f42400

                          AREA ||i.RCC_PLLSAI_GetFreqDomain_LTDC||, CODE, READONLY, ALIGN=2

                  RCC_PLLSAI_GetFreqDomain_LTDC PROC
;;;1477     */
;;;1478   uint32_t RCC_PLLSAI_GetFreqDomain_LTDC(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1479   {
;;;1480     uint32_t pllinputfreq = 0U, pllsource = 0U;
000002  2400              MOVS     r4,#0
000004  2500              MOVS     r5,#0
;;;1481   
;;;1482     /* PLLSAI_VCO = (HSE_VALUE or HSI_VALUE / PLLSAIM) * PLLSAIN
;;;1483        LTDC Domain clock  = (PLLSAI_VCO / PLLSAIR) / PLLSAIDIVR
;;;1484     */
;;;1485     pllsource = LL_RCC_PLL_GetMainSource();
000006  f7fffffe          BL       LL_RCC_PLL_GetMainSource
00000a  4605              MOV      r5,r0
;;;1486   
;;;1487     switch (pllsource)
00000c  b11d              CBZ      r5,|L22.22|
00000e  f5b50f80          CMP      r5,#0x400000
000012  d104              BNE      |L22.30|
000014  e001              B        |L22.26|
                  |L22.22|
;;;1488     {
;;;1489       case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI clock source */
;;;1490         pllinputfreq = HSI_VALUE;
000016  4c12              LDR      r4,|L22.96|
;;;1491         break;
000018  e003              B        |L22.34|
                  |L22.26|
;;;1492   
;;;1493       case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI clock source */
;;;1494         pllinputfreq = HSE_VALUE;
00001a  4c12              LDR      r4,|L22.100|
;;;1495         break;
00001c  e001              B        |L22.34|
                  |L22.30|
;;;1496   
;;;1497       default:
;;;1498         pllinputfreq = HSI_VALUE;
00001e  4c10              LDR      r4,|L22.96|
;;;1499         break;
000020  bf00              NOP      
                  |L22.34|
000022  bf00              NOP                            ;1491
;;;1500     }
;;;1501     return __LL_RCC_CALC_PLLSAI_LTDC_FREQ(pllinputfreq, LL_RCC_PLLSAI_GetDivider(),
000024  bf00              NOP      
000026  4810              LDR      r0,|L22.104|
000028  6800              LDR      r0,[r0,#0]
00002a  f000003f          AND      r0,r0,#0x3f
00002e  fbb4f6f0          UDIV     r6,r4,r0
000032  f7fffffe          BL       LL_RCC_PLLSAI_GetN
000036  4346              MULS     r6,r0,r6
000038  480b              LDR      r0,|L22.104|
00003a  3084              ADDS     r0,r0,#0x84
00003c  6800              LDR      r0,[r0,#0]
00003e  f00040e0          AND      r0,r0,#0x70000000
000042  0f01              LSRS     r1,r0,#28
000044  4808              LDR      r0,|L22.104|
000046  3088              ADDS     r0,r0,#0x88
000048  6800              LDR      r0,[r0,#0]
00004a  f4003040          AND      r0,r0,#0x30000
00004e  4a07              LDR      r2,|L22.108|
000050  eb024010          ADD      r0,r2,r0,LSR #16
000054  7800              LDRB     r0,[r0,#0]
000056  fb11f000          SMULBB   r0,r1,r0
00005a  fbb6f0f0          UDIV     r0,r6,r0
;;;1502                                           LL_RCC_PLLSAI_GetN(), LL_RCC_PLLSAI_GetR(), LL_RCC_PLLSAI_GetDIVR());
;;;1503   }
00005e  bd70              POP      {r4-r6,pc}
;;;1504   #endif /* LTDC */
                          ENDP

                  |L22.96|
                          DCD      0x00f42400
                  |L22.100|
                          DCD      0x007a1200
                  |L22.104|
                          DCD      0x40023804
                  |L22.108|
                          DCD      aRCC_PLLSAIDIVRPrescTable

                          AREA ||i.RCC_PLLSAI_GetFreqDomain_SAI||, CODE, READONLY, ALIGN=2

                  RCC_PLLSAI_GetFreqDomain_SAI PROC
;;;1412     */
;;;1413   uint32_t RCC_PLLSAI_GetFreqDomain_SAI(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1414   {
;;;1415     uint32_t pllinputfreq = 0U, pllsource = 0U;
000002  2400              MOVS     r4,#0
000004  2500              MOVS     r5,#0
;;;1416   
;;;1417     /* PLLSAI_VCO = (HSE_VALUE or HSI_VALUE / PLLSAIM) * PLLSAIN
;;;1418        SAI domain clock  = (PLLSAI_VCO / PLLSAIQ) / PLLSAIDIVQ
;;;1419     */
;;;1420     pllsource = LL_RCC_PLL_GetMainSource();
000006  f7fffffe          BL       LL_RCC_PLL_GetMainSource
00000a  4605              MOV      r5,r0
;;;1421   
;;;1422     switch (pllsource)
00000c  b11d              CBZ      r5,|L23.22|
00000e  f5b50f80          CMP      r5,#0x400000
000012  d104              BNE      |L23.30|
000014  e001              B        |L23.26|
                  |L23.22|
;;;1423     {
;;;1424       case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLLSAI clock source */
;;;1425         pllinputfreq = HSI_VALUE;
000016  4c12              LDR      r4,|L23.96|
;;;1426         break;
000018  e003              B        |L23.34|
                  |L23.26|
;;;1427   
;;;1428       case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLLSAI clock source */
;;;1429         pllinputfreq = HSE_VALUE;
00001a  4c12              LDR      r4,|L23.100|
;;;1430         break;
00001c  e001              B        |L23.34|
                  |L23.30|
;;;1431   
;;;1432       default:
;;;1433         pllinputfreq = HSI_VALUE;
00001e  4c10              LDR      r4,|L23.96|
;;;1434         break;
000020  bf00              NOP      
                  |L23.34|
000022  bf00              NOP                            ;1426
;;;1435     }
;;;1436     return __LL_RCC_CALC_PLLSAI_SAI_FREQ(pllinputfreq, LL_RCC_PLLSAI_GetDivider(),
000024  bf00              NOP      
000026  4810              LDR      r0,|L23.104|
000028  6800              LDR      r0,[r0,#0]
00002a  f000003f          AND      r0,r0,#0x3f
00002e  fbb4f6f0          UDIV     r6,r4,r0
000032  f7fffffe          BL       LL_RCC_PLLSAI_GetN
000036  4346              MULS     r6,r0,r6
000038  480b              LDR      r0,|L23.104|
00003a  3084              ADDS     r0,r0,#0x84
00003c  6800              LDR      r0,[r0,#0]
00003e  f0006070          AND      r0,r0,#0xf000000
000042  0e01              LSRS     r1,r0,#24
000044  4808              LDR      r0,|L23.104|
000046  3088              ADDS     r0,r0,#0x88
000048  6800              LDR      r0,[r0,#0]
00004a  f40050f8          AND      r0,r0,#0x1f00
00004e  2201              MOVS     r2,#1
000050  eb022010          ADD      r0,r2,r0,LSR #8
000054  fb11f000          SMULBB   r0,r1,r0
000058  fbb6f0f0          UDIV     r0,r6,r0
;;;1437                                           LL_RCC_PLLSAI_GetN(), LL_RCC_PLLSAI_GetQ(), LL_RCC_PLLSAI_GetDIVQ());
;;;1438   }
00005c  bd70              POP      {r4-r6,pc}
;;;1439   
                          ENDP

00005e  0000              DCW      0x0000
                  |L23.96|
                          DCD      0x00f42400
                  |L23.100|
                          DCD      0x007a1200
                  |L23.104|
                          DCD      0x40023804

                          AREA ||i.RCC_PLL_GetFreqDomain_48M||, CODE, READONLY, ALIGN=2

                  RCC_PLL_GetFreqDomain_48M PROC
;;;1248     */
;;;1249   uint32_t RCC_PLL_GetFreqDomain_48M(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1250   {
;;;1251     uint32_t pllinputfreq = 0U, pllsource = 0U;
000002  2400              MOVS     r4,#0
000004  2500              MOVS     r5,#0
;;;1252   
;;;1253     /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM ) * PLLN
;;;1254        48M Domain clock = PLL_VCO / PLLQ
;;;1255     */
;;;1256     pllsource = LL_RCC_PLL_GetMainSource();
000006  f7fffffe          BL       LL_RCC_PLL_GetMainSource
00000a  4605              MOV      r5,r0
;;;1257   
;;;1258     switch (pllsource)
00000c  b11d              CBZ      r5,|L24.22|
00000e  f5b50f80          CMP      r5,#0x400000
000012  d104              BNE      |L24.30|
000014  e001              B        |L24.26|
                  |L24.22|
;;;1259     {
;;;1260       case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
;;;1261         pllinputfreq = HSI_VALUE;
000016  4c0c              LDR      r4,|L24.72|
;;;1262         break;
000018  e003              B        |L24.34|
                  |L24.26|
;;;1263   
;;;1264       case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
;;;1265         pllinputfreq = HSE_VALUE;
00001a  4c0c              LDR      r4,|L24.76|
;;;1266         break;
00001c  e001              B        |L24.34|
                  |L24.30|
;;;1267   
;;;1268       default:
;;;1269         pllinputfreq = HSI_VALUE;
00001e  4c0a              LDR      r4,|L24.72|
;;;1270         break;
000020  bf00              NOP      
                  |L24.34|
000022  bf00              NOP                            ;1262
;;;1271     }
;;;1272     return __LL_RCC_CALC_PLLCLK_48M_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
000024  bf00              NOP      
000026  480a              LDR      r0,|L24.80|
000028  6800              LDR      r0,[r0,#0]
00002a  f000003f          AND      r0,r0,#0x3f
00002e  fbb4f6f0          UDIV     r6,r4,r0
000032  f7fffffe          BL       LL_RCC_PLL_GetN
000036  4346              MULS     r6,r0,r6
000038  4805              LDR      r0,|L24.80|
00003a  6800              LDR      r0,[r0,#0]
00003c  f0006070          AND      r0,r0,#0xf000000
000040  0e00              LSRS     r0,r0,#24
000042  fbb6f0f0          UDIV     r0,r6,r0
;;;1273                                           LL_RCC_PLL_GetN(), LL_RCC_PLL_GetQ());
;;;1274   }
000046  bd70              POP      {r4-r6,pc}
;;;1275   
                          ENDP

                  |L24.72|
                          DCD      0x00f42400
                  |L24.76|
                          DCD      0x007a1200
                  |L24.80|
                          DCD      0x40023804

                          AREA ||i.RCC_PLL_GetFreqDomain_SYS||, CODE, READONLY, ALIGN=2

                  RCC_PLL_GetFreqDomain_SYS PROC
;;;1204     */
;;;1205   uint32_t RCC_PLL_GetFreqDomain_SYS(uint32_t SYSCLK_Source)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1206   {
000004  4604              MOV      r4,r0
;;;1207     uint32_t pllinputfreq = 0U, pllsource = 0U, plloutputfreq = 0U;
000006  2500              MOVS     r5,#0
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;1208   
;;;1209     /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;1210        SYSCLK = PLL_VCO / (PLLP or PLLR)
;;;1211     */
;;;1212     pllsource = LL_RCC_PLL_GetMainSource();
00000c  f7fffffe          BL       LL_RCC_PLL_GetMainSource
000010  4606              MOV      r6,r0
;;;1213   
;;;1214     switch (pllsource)
000012  b11e              CBZ      r6,|L25.28|
000014  f5b60f80          CMP      r6,#0x400000
000018  d104              BNE      |L25.36|
00001a  e001              B        |L25.32|
                  |L25.28|
;;;1215     {
;;;1216       case LL_RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
;;;1217         pllinputfreq = HSI_VALUE;
00001c  4d10              LDR      r5,|L25.96|
;;;1218         break;
00001e  e003              B        |L25.40|
                  |L25.32|
;;;1219   
;;;1220       case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
;;;1221         pllinputfreq = HSE_VALUE;
000020  4d10              LDR      r5,|L25.100|
;;;1222         break;
000022  e001              B        |L25.40|
                  |L25.36|
;;;1223   
;;;1224       default:
;;;1225         pllinputfreq = HSI_VALUE;
000024  4d0e              LDR      r5,|L25.96|
;;;1226         break;
000026  bf00              NOP      
                  |L25.40|
000028  bf00              NOP                            ;1218
;;;1227     }
;;;1228   
;;;1229     if (SYSCLK_Source == LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
00002a  2c08              CMP      r4,#8
00002c  d114              BNE      |L25.88|
;;;1230     {
;;;1231       plloutputfreq = __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
00002e  bf00              NOP      
000030  480d              LDR      r0,|L25.104|
000032  6800              LDR      r0,[r0,#0]
000034  f000003f          AND      r0,r0,#0x3f
000038  fbb5f8f0          UDIV     r8,r5,r0
00003c  f7fffffe          BL       LL_RCC_PLL_GetN
000040  fb08f800          MUL      r8,r8,r0
000044  4808              LDR      r0,|L25.104|
000046  6800              LDR      r0,[r0,#0]
000048  f4003040          AND      r0,r0,#0x30000
00004c  2101              MOVS     r1,#1
00004e  eb014010          ADD      r0,r1,r0,LSR #16
000052  0040              LSLS     r0,r0,#1
000054  fbb8f7f0          UDIV     r7,r8,r0
                  |L25.88|
;;;1232                                           LL_RCC_PLL_GetN(), LL_RCC_PLL_GetP());
;;;1233     }
;;;1234   #if defined(RCC_PLLR_SYSCLK_SUPPORT)
;;;1235     else
;;;1236     {
;;;1237       plloutputfreq = __LL_RCC_CALC_PLLRCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
;;;1238                                           LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
;;;1239     }
;;;1240   #endif /* RCC_PLLR_SYSCLK_SUPPORT */
;;;1241   
;;;1242     return plloutputfreq;
000058  4638              MOV      r0,r7
;;;1243   }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;1244   
                          ENDP

00005e  0000              DCW      0x0000
                  |L25.96|
                          DCD      0x00f42400
                  |L25.100|
                          DCD      0x007a1200
                  |L25.104|
                          DCD      0x40023804

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  aRCC_PLLSAIDIVRPrescTable
000000  02040810          DCB      0x02,0x04,0x08,0x10

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____REVSH|
#line 402
|__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____RRX|
#line 587
|__asm___18_stm32f4xx_ll_rcc_c_5c04acb7____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
