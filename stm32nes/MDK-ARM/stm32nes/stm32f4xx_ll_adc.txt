; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_ll_adc.o --depend=stm32nes\stm32f4xx_ll_adc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_ll_adc.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_adc.c]
                          THUMB

                          AREA ||i.LL_ADC_CommonDeInit||, CODE, READONLY, ALIGN=2

                  LL_ADC_CommonDeInit PROC
;;;305      */
;;;306    ErrorStatus LL_ADC_CommonDeInit(ADC_Common_TypeDef *ADCxy_COMMON)
000000  4601              MOV      r1,r0
;;;307    {
;;;308      /* Check the parameters */
;;;309      assert_param(IS_ADC_COMMON_INSTANCE(ADCxy_COMMON));
;;;310      
;;;311    
;;;312      /* Force reset of ADC clock (core clock) */
;;;313      LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_ADC);
000002  f44f7080          MOV      r0,#0x100
000006  4a07              LDR      r2,|L1.36|
000008  6812              LDR      r2,[r2,#0]
00000a  4302              ORRS     r2,r2,r0
00000c  4b05              LDR      r3,|L1.36|
00000e  601a              STR      r2,[r3,#0]
000010  bf00              NOP      
;;;314      
;;;315      /* Release reset of ADC clock (core clock) */
;;;316      LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_ADC);
000012  bf00              NOP      
000014  461a              MOV      r2,r3
000016  6812              LDR      r2,[r2,#0]
000018  4382              BICS     r2,r2,r0
00001a  601a              STR      r2,[r3,#0]
00001c  bf00              NOP      
;;;317      
;;;318      return SUCCESS;
00001e  2001              MOVS     r0,#1
;;;319    }
000020  4770              BX       lr
;;;320    
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      0x40023824

                          AREA ||i.LL_ADC_CommonInit||, CODE, READONLY, ALIGN=2

                  LL_ADC_CommonInit PROC
;;;335      */
;;;336    ErrorStatus LL_ADC_CommonInit(ADC_Common_TypeDef *ADCxy_COMMON, LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;337    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;338      ErrorStatus status = SUCCESS;
000008  2601              MOVS     r6,#1
;;;339      
;;;340      /* Check the parameters */
;;;341      assert_param(IS_ADC_COMMON_INSTANCE(ADCxy_COMMON));
;;;342      assert_param(IS_LL_ADC_COMMON_CLOCK(ADC_CommonInitStruct->CommonClock));
;;;343      
;;;344    #if defined(ADC_MULTIMODE_SUPPORT)
;;;345      assert_param(IS_LL_ADC_MULTI_MODE(ADC_CommonInitStruct->Multimode));
;;;346      if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)
00000a  6860              LDR      r0,[r4,#4]
00000c  b100              CBZ      r0,|L2.16|
;;;347      {
;;;348        assert_param(IS_LL_ADC_MULTI_DMA_TRANSFER(ADC_CommonInitStruct->MultiDMATransfer));
;;;349        assert_param(IS_LL_ADC_MULTI_TWOSMP_DELAY(ADC_CommonInitStruct->MultiTwoSamplingDelay));
00000e  bf00              NOP      
                  |L2.16|
;;;350      }
;;;351    #endif /* ADC_MULTIMODE_SUPPORT */
;;;352    
;;;353      /* Note: Hardware constraint (refer to description of functions             */
;;;354      /*       "LL_ADC_SetCommonXXX()" and "LL_ADC_SetMultiXXX()"):               */
;;;355      /*       On this STM32 serie, setting of these features is conditioned to   */
;;;356      /*       ADC state:                                                         */
;;;357      /*       All ADC instances of the ADC common group must be disabled.        */
;;;358      if(__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(ADCxy_COMMON) == 0U)
000010  4813              LDR      r0,|L2.96|
000012  f7fffffe          BL       LL_ADC_IsEnabled
000016  4607              MOV      r7,r0
000018  4812              LDR      r0,|L2.100|
00001a  f7fffffe          BL       LL_ADC_IsEnabled
00001e  4307              ORRS     r7,r7,r0
000020  4811              LDR      r0,|L2.104|
000022  f7fffffe          BL       LL_ADC_IsEnabled
000026  4307              ORRS     r7,r7,r0
000028  b9af              CBNZ     r7,|L2.86|
;;;359      {
;;;360        /* Configuration of ADC hierarchical scope:                               */
;;;361        /*  - common to several ADC                                               */
;;;362        /*    (all ADC instances belonging to the same ADC common instance)       */
;;;363        /*    - Set ADC clock (conversion clock)                                  */
;;;364        /*  - multimode (if several ADC instances available on the                */
;;;365        /*    selected device)                                                    */
;;;366        /*    - Set ADC multimode configuration                                   */
;;;367        /*    - Set ADC multimode DMA transfer                                    */
;;;368        /*    - Set ADC multimode: delay between 2 sampling phases                */
;;;369    #if defined(ADC_MULTIMODE_SUPPORT)
;;;370        if(ADC_CommonInitStruct->Multimode != LL_ADC_MULTI_INDEPENDENT)
00002a  6860              LDR      r0,[r4,#4]
00002c  b160              CBZ      r0,|L2.72|
;;;371        {
;;;372          MODIFY_REG(ADCxy_COMMON->CCR,
00002e  e9d40100          LDRD     r0,r1,[r4,#0]
000032  4308              ORRS     r0,r0,r1
000034  68a1              LDR      r1,[r4,#8]
000036  4308              ORRS     r0,r0,r1
000038  68e1              LDR      r1,[r4,#0xc]
00003a  4308              ORRS     r0,r0,r1
00003c  6869              LDR      r1,[r5,#4]
00003e  4a0b              LDR      r2,|L2.108|
000040  4011              ANDS     r1,r1,r2
000042  4308              ORRS     r0,r0,r1
000044  6068              STR      r0,[r5,#4]
000046  e007              B        |L2.88|
                  |L2.72|
;;;373                       ADC_CCR_ADCPRE
;;;374                     | ADC_CCR_MULTI
;;;375                     | ADC_CCR_DMA
;;;376                     | ADC_CCR_DDS
;;;377                     | ADC_CCR_DELAY
;;;378                    ,
;;;379                       ADC_CommonInitStruct->CommonClock
;;;380                     | ADC_CommonInitStruct->Multimode
;;;381                     | ADC_CommonInitStruct->MultiDMATransfer
;;;382                     | ADC_CommonInitStruct->MultiTwoSamplingDelay
;;;383                    );
;;;384        }
;;;385        else
;;;386        {
;;;387          MODIFY_REG(ADCxy_COMMON->CCR,
000048  6868              LDR      r0,[r5,#4]
00004a  4908              LDR      r1,|L2.108|
00004c  4008              ANDS     r0,r0,r1
00004e  6821              LDR      r1,[r4,#0]
000050  4308              ORRS     r0,r0,r1
000052  6068              STR      r0,[r5,#4]
000054  e000              B        |L2.88|
                  |L2.86|
;;;388                       ADC_CCR_ADCPRE
;;;389                     | ADC_CCR_MULTI
;;;390                     | ADC_CCR_DMA
;;;391                     | ADC_CCR_DDS
;;;392                     | ADC_CCR_DELAY
;;;393                    ,
;;;394                       ADC_CommonInitStruct->CommonClock
;;;395                     | LL_ADC_MULTI_INDEPENDENT
;;;396                    );
;;;397        }
;;;398    #else
;;;399        LL_ADC_SetCommonClock(ADCxy_COMMON, ADC_CommonInitStruct->CommonClock);
;;;400    #endif
;;;401      }
;;;402      else
;;;403      {
;;;404        /* Initialization error: One or several ADC instances belonging to        */
;;;405        /* the same ADC common instance are not disabled.                         */
;;;406        status = ERROR;
000056  2600              MOVS     r6,#0
                  |L2.88|
;;;407      }
;;;408      
;;;409      return status;
000058  4630              MOV      r0,r6
;;;410    }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;411    
                          ENDP

00005e  0000              DCW      0x0000
                  |L2.96|
                          DCD      0x40012000
                  |L2.100|
                          DCD      0x40012100
                  |L2.104|
                          DCD      0x40012200
                  |L2.108|
                          DCD      0xfffc10e0

                          AREA ||i.LL_ADC_CommonStructInit||, CODE, READONLY, ALIGN=1

                  LL_ADC_CommonStructInit PROC
;;;417      */
;;;418    void LL_ADC_CommonStructInit(LL_ADC_CommonInitTypeDef *ADC_CommonInitStruct)
000000  2100              MOVS     r1,#0
;;;419    {
;;;420      /* Set ADC_CommonInitStruct fields to default values */
;;;421      /* Set fields of ADC common */
;;;422      /* (all ADC instances belonging to the same ADC common instance) */
;;;423      ADC_CommonInitStruct->CommonClock = LL_ADC_CLOCK_SYNC_PCLK_DIV2;
000002  6001              STR      r1,[r0,#0]
;;;424      
;;;425    #if defined(ADC_MULTIMODE_SUPPORT)
;;;426      /* Set fields of ADC multimode */
;;;427      ADC_CommonInitStruct->Multimode             = LL_ADC_MULTI_INDEPENDENT;
000004  6041              STR      r1,[r0,#4]
;;;428        ADC_CommonInitStruct->MultiDMATransfer      = LL_ADC_MULTI_REG_DMA_EACH_ADC;
000006  6081              STR      r1,[r0,#8]
;;;429      ADC_CommonInitStruct->MultiTwoSamplingDelay = LL_ADC_MULTI_TWOSMP_DELAY_5CYCLES;
000008  60c1              STR      r1,[r0,#0xc]
;;;430    #endif /* ADC_MULTIMODE_SUPPORT */
;;;431    }
00000a  4770              BX       lr
;;;432    
                          ENDP


                          AREA ||i.LL_ADC_DeInit||, CODE, READONLY, ALIGN=2

                  LL_ADC_DeInit PROC
;;;442      */
;;;443    ErrorStatus LL_ADC_DeInit(ADC_TypeDef *ADCx)
000000  b570              PUSH     {r4-r6,lr}
;;;444    {
000002  4604              MOV      r4,r0
;;;445      ErrorStatus status = SUCCESS;
000004  2501              MOVS     r5,#1
;;;446      
;;;447      /* Check the parameters */
;;;448      assert_param(IS_ADC_ALL_INSTANCE(ADCx));
;;;449      
;;;450      /* Disable ADC instance if not already disabled.                            */
;;;451      if(LL_ADC_IsEnabled(ADCx) == 1U)
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       LL_ADC_IsEnabled
00000c  2801              CMP      r0,#1
00000e  d112              BNE      |L4.54|
;;;452      {
;;;453        /* Set ADC group regular trigger source to SW start to ensure to not      */
;;;454        /* have an external trigger event occurring during the conversion stop    */
;;;455        /* ADC disable process.                                                   */
;;;456        LL_ADC_REG_SetTriggerSource(ADCx, LL_ADC_REG_TRIG_SOFTWARE);
000010  2000              MOVS     r0,#0
000012  68a1              LDR      r1,[r4,#8]
000014  f0216170          BIC      r1,r1,#0xf000000
000018  60a1              STR      r1,[r4,#8]
00001a  bf00              NOP      
;;;457        
;;;458        /* Set ADC group injected trigger source to SW start to ensure to not     */
;;;459        /* have an external trigger event occurring during the conversion stop    */
;;;460        /* ADC disable process.                                                   */
;;;461        LL_ADC_INJ_SetTriggerSource(ADCx, LL_ADC_INJ_TRIG_SOFTWARE);
00001c  bf00              NOP      
00001e  68a1              LDR      r1,[r4,#8]
000020  f4212170          BIC      r1,r1,#0xf0000
000024  60a1              STR      r1,[r4,#8]
000026  bf00              NOP      
;;;462        
;;;463        /* Disable the ADC instance */
;;;464        LL_ADC_Disable(ADCx);
000028  bf00              NOP      
00002a  68a0              LDR      r0,[r4,#8]
00002c  f0200001          BIC      r0,r0,#1
000030  60a0              STR      r0,[r4,#8]
000032  bf00              NOP      
000034  bf00              NOP      
                  |L4.54|
;;;465      }
;;;466      
;;;467      /* Check whether ADC state is compliant with expected state */
;;;468      /* (hardware requirements of bits state to reset registers below) */
;;;469      if(READ_BIT(ADCx->CR2, ADC_CR2_ADON) == 0U)
000036  68a0              LDR      r0,[r4,#8]
000038  f0000001          AND      r0,r0,#1
00003c  2800              CMP      r0,#0
00003e  d13f              BNE      |L4.192|
;;;470      {
;;;471        /* ========== Reset ADC registers ========== */
;;;472        /* Reset register SR */
;;;473        CLEAR_BIT(ADCx->SR,
000040  6820              LDR      r0,[r4,#0]
000042  f020003f          BIC      r0,r0,#0x3f
000046  6020              STR      r0,[r4,#0]
;;;474                  (  LL_ADC_FLAG_STRT
;;;475                   | LL_ADC_FLAG_JSTRT
;;;476                   | LL_ADC_FLAG_EOCS
;;;477                   | LL_ADC_FLAG_OVR
;;;478                   | LL_ADC_FLAG_JEOS
;;;479                   | LL_ADC_FLAG_AWD1 )
;;;480                 );
;;;481        
;;;482        /* Reset register CR1 */
;;;483        CLEAR_BIT(ADCx->CR1,
000048  6860              LDR      r0,[r4,#4]
00004a  491e              LDR      r1,|L4.196|
00004c  4008              ANDS     r0,r0,r1
00004e  6060              STR      r0,[r4,#4]
;;;484                  (  ADC_CR1_OVRIE   | ADC_CR1_RES     | ADC_CR1_AWDEN
;;;485                   | ADC_CR1_JAWDEN
;;;486                   | ADC_CR1_DISCNUM | ADC_CR1_JDISCEN | ADC_CR1_DISCEN
;;;487                   | ADC_CR1_JAUTO   | ADC_CR1_AWDSGL  | ADC_CR1_SCAN
;;;488                   | ADC_CR1_JEOCIE  | ADC_CR1_AWDIE   | ADC_CR1_EOCIE
;;;489                   | ADC_CR1_AWDCH                                     )
;;;490                 );
;;;491        
;;;492        /* Reset register CR2 */
;;;493        CLEAR_BIT(ADCx->CR2,
000050  68a0              LDR      r0,[r4,#8]
000052  491d              LDR      r1,|L4.200|
000054  4008              ANDS     r0,r0,r1
000056  60a0              STR      r0,[r4,#8]
;;;494                  (  ADC_CR2_SWSTART  | ADC_CR2_EXTEN  | ADC_CR2_EXTSEL
;;;495                   | ADC_CR2_JSWSTART | ADC_CR2_JEXTEN | ADC_CR2_JEXTSEL
;;;496                   | ADC_CR2_ALIGN    | ADC_CR2_EOCS
;;;497                   | ADC_CR2_DDS      | ADC_CR2_DMA
;;;498                   | ADC_CR2_CONT     | ADC_CR2_ADON                    )
;;;499                 );
;;;500        
;;;501        /* Reset register SMPR1 */
;;;502        CLEAR_BIT(ADCx->SMPR1,
000058  68e0              LDR      r0,[r4,#0xc]
00005a  f0004078          AND      r0,r0,#0xf8000000
00005e  60e0              STR      r0,[r4,#0xc]
;;;503                  (  ADC_SMPR1_SMP18 | ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16
;;;504                   | ADC_SMPR1_SMP15 | ADC_SMPR1_SMP14 | ADC_SMPR1_SMP13
;;;505                   | ADC_SMPR1_SMP12 | ADC_SMPR1_SMP11 | ADC_SMPR1_SMP10)
;;;506                 );
;;;507        
;;;508        /* Reset register SMPR2 */
;;;509        CLEAR_BIT(ADCx->SMPR2,
000060  6920              LDR      r0,[r4,#0x10]
000062  f0004040          AND      r0,r0,#0xc0000000
000066  6120              STR      r0,[r4,#0x10]
;;;510                  (  ADC_SMPR2_SMP9
;;;511                   | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | ADC_SMPR2_SMP6
;;;512                   | ADC_SMPR2_SMP5 | ADC_SMPR2_SMP4 | ADC_SMPR2_SMP3
;;;513                   | ADC_SMPR2_SMP2 | ADC_SMPR2_SMP1 | ADC_SMPR2_SMP0)
;;;514                 );
;;;515        
;;;516        /* Reset register JOFR1 */
;;;517        CLEAR_BIT(ADCx->JOFR1, ADC_JOFR1_JOFFSET1);
000068  6960              LDR      r0,[r4,#0x14]
00006a  f36f000b          BFC      r0,#0,#12
00006e  6160              STR      r0,[r4,#0x14]
;;;518        /* Reset register JOFR2 */
;;;519        CLEAR_BIT(ADCx->JOFR2, ADC_JOFR2_JOFFSET2);
000070  69a0              LDR      r0,[r4,#0x18]
000072  f36f000b          BFC      r0,#0,#12
000076  61a0              STR      r0,[r4,#0x18]
;;;520        /* Reset register JOFR3 */
;;;521        CLEAR_BIT(ADCx->JOFR3, ADC_JOFR3_JOFFSET3);
000078  69e0              LDR      r0,[r4,#0x1c]
00007a  f36f000b          BFC      r0,#0,#12
00007e  61e0              STR      r0,[r4,#0x1c]
;;;522        /* Reset register JOFR4 */
;;;523        CLEAR_BIT(ADCx->JOFR4, ADC_JOFR4_JOFFSET4);
000080  6a20              LDR      r0,[r4,#0x20]
000082  f36f000b          BFC      r0,#0,#12
000086  6220              STR      r0,[r4,#0x20]
;;;524        
;;;525        /* Reset register HTR */
;;;526        SET_BIT(ADCx->HTR, ADC_HTR_HT);
000088  6a60              LDR      r0,[r4,#0x24]
00008a  f64071ff          MOV      r1,#0xfff
00008e  4308              ORRS     r0,r0,r1
000090  6260              STR      r0,[r4,#0x24]
;;;527        /* Reset register LTR */
;;;528        CLEAR_BIT(ADCx->LTR, ADC_LTR_LT);
000092  6aa0              LDR      r0,[r4,#0x28]
000094  f36f000b          BFC      r0,#0,#12
000098  62a0              STR      r0,[r4,#0x28]
;;;529        
;;;530        /* Reset register SQR1 */
;;;531        CLEAR_BIT(ADCx->SQR1,
00009a  6ae0              LDR      r0,[r4,#0x2c]
00009c  f000407f          AND      r0,r0,#0xff000000
0000a0  62e0              STR      r0,[r4,#0x2c]
;;;532                  (  ADC_SQR1_L
;;;533                   | ADC_SQR1_SQ16
;;;534                   | ADC_SQR1_SQ15 | ADC_SQR1_SQ14 | ADC_SQR1_SQ13)
;;;535                 );
;;;536                 
;;;537        /* Reset register SQR2 */
;;;538        CLEAR_BIT(ADCx->SQR2,
0000a2  6b20              LDR      r0,[r4,#0x30]
0000a4  f0004040          AND      r0,r0,#0xc0000000
0000a8  6320              STR      r0,[r4,#0x30]
;;;539                  (  ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10
;;;540                   | ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7)
;;;541                 );
;;;542        
;;;543        
;;;544        /* Reset register JSQR */
;;;545        CLEAR_BIT(ADCx->JSQR,
0000aa  6ba0              LDR      r0,[r4,#0x38]
0000ac  f36f0015          BFC      r0,#0,#22
0000b0  63a0              STR      r0,[r4,#0x38]
;;;546                  (  ADC_JSQR_JL
;;;547                   | ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3
;;;548                   | ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  )
;;;549                 );
;;;550        
;;;551        /* Reset register DR */
;;;552        /* bits in access mode read only, no direct reset applicable */
;;;553        
;;;554        /* Reset registers JDR1, JDR2, JDR3, JDR4 */
;;;555        /* bits in access mode read only, no direct reset applicable */
;;;556        
;;;557        /* Reset register CCR */
;;;558        CLEAR_BIT(ADC->CCR, ADC_CCR_TSVREFE | ADC_CCR_ADCPRE);
0000b2  4806              LDR      r0,|L4.204|
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f4200003          BIC      r0,r0,#0x830000
0000ba  4905              LDR      r1,|L4.208|
0000bc  f8c10304          STR      r0,[r1,#0x304]
                  |L4.192|
;;;559      }
;;;560      
;;;561      return status;
0000c0  4628              MOV      r0,r5
;;;562    }
0000c2  bd70              POP      {r4-r6,pc}
;;;563    
                          ENDP

                  |L4.196|
                          DCD      0xf83f0000
                  |L4.200|
                          DCD      0x8080f0fc
                  |L4.204|
                          DCD      0x40012304
                  |L4.208|
                          DCD      0x40012000

                          AREA ||i.LL_ADC_INJ_Init||, CODE, READONLY, ALIGN=1

                  LL_ADC_INJ_Init PROC
;;;823      */
;;;824    ErrorStatus LL_ADC_INJ_Init(ADC_TypeDef *ADCx, LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;825    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;826      ErrorStatus status = SUCCESS;
000006  2601              MOVS     r6,#1
;;;827      
;;;828      /* Check the parameters */
;;;829      assert_param(IS_ADC_ALL_INSTANCE(ADCx));
;;;830      assert_param(IS_LL_ADC_INJ_TRIG_SOURCE(ADC_INJ_InitStruct->TriggerSource));
;;;831      assert_param(IS_LL_ADC_INJ_SEQ_SCAN_LENGTH(ADC_INJ_InitStruct->SequencerLength));
;;;832      if(ADC_INJ_InitStruct->SequencerLength != LL_ADC_INJ_SEQ_SCAN_DISABLE)
000008  6868              LDR      r0,[r5,#4]
00000a  b100              CBZ      r0,|L5.14|
;;;833      {
;;;834        assert_param(IS_LL_ADC_INJ_SEQ_SCAN_DISCONT_MODE(ADC_INJ_InitStruct->SequencerDiscont));
00000c  bf00              NOP      
                  |L5.14|
;;;835      }
;;;836      assert_param(IS_LL_ADC_INJ_TRIG_AUTO(ADC_INJ_InitStruct->TrigAuto));
;;;837      
;;;838      /* Note: Hardware constraint (refer to description of this function):       */
;;;839      /*       ADC instance must be disabled.                                     */
;;;840      if(LL_ADC_IsEnabled(ADCx) == 0U)
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       LL_ADC_IsEnabled
000014  bb00              CBNZ     r0,|L5.88|
;;;841      {
;;;842        /* Configuration of ADC hierarchical scope:                               */
;;;843        /*  - ADC group injected                                                  */
;;;844        /*    - Set ADC group injected trigger source                             */
;;;845        /*    - Set ADC group injected sequencer length                           */
;;;846        /*    - Set ADC group injected sequencer discontinuous mode               */
;;;847        /*    - Set ADC group injected conversion trigger: independent or         */
;;;848        /*      from ADC group regular                                            */
;;;849        /* Note: On this STM32 serie, ADC trigger edge is set when starting       */
;;;850        /*       ADC conversion.                                                  */
;;;851        /*       Refer to function @ref LL_ADC_INJ_StartConversionExtTrig().      */
;;;852        if(ADC_INJ_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
000016  6868              LDR      r0,[r5,#4]
000018  b140              CBZ      r0,|L5.44|
;;;853        {
;;;854          MODIFY_REG(ADCx->CR1,
00001a  e9d50102          LDRD     r0,r1,[r5,#8]
00001e  4308              ORRS     r0,r0,r1
000020  6861              LDR      r1,[r4,#4]
000022  f42151a0          BIC      r1,r1,#0x1400
000026  4308              ORRS     r0,r0,r1
000028  6060              STR      r0,[r4,#4]
00002a  e005              B        |L5.56|
                  |L5.44|
;;;855                       ADC_CR1_JDISCEN
;;;856                     | ADC_CR1_JAUTO
;;;857                    ,
;;;858                       ADC_INJ_InitStruct->SequencerDiscont
;;;859                     | ADC_INJ_InitStruct->TrigAuto
;;;860                    );
;;;861        }
;;;862        else
;;;863        {
;;;864          MODIFY_REG(ADCx->CR1,
00002c  6860              LDR      r0,[r4,#4]
00002e  f42050a0          BIC      r0,r0,#0x1400
000032  68e9              LDR      r1,[r5,#0xc]
000034  4308              ORRS     r0,r0,r1
000036  6060              STR      r0,[r4,#4]
                  |L5.56|
;;;865                       ADC_CR1_JDISCEN
;;;866                     | ADC_CR1_JAUTO
;;;867                    ,
;;;868                       LL_ADC_REG_SEQ_DISCONT_DISABLE
;;;869                     | ADC_INJ_InitStruct->TrigAuto
;;;870                    );
;;;871        }
;;;872        
;;;873        MODIFY_REG(ADCx->CR2,
000038  68a0              LDR      r0,[r4,#8]
00003a  f420107c          BIC      r0,r0,#0x3f0000
00003e  6829              LDR      r1,[r5,#0]
000040  f4012170          AND      r1,r1,#0xf0000
000044  4308              ORRS     r0,r0,r1
000046  60a0              STR      r0,[r4,#8]
;;;874                     ADC_CR2_JEXTSEL
;;;875                   | ADC_CR2_JEXTEN
;;;876                  ,
;;;877                    (ADC_INJ_InitStruct->TriggerSource & ADC_CR2_JEXTSEL)
;;;878                  );
;;;879        
;;;880        /* Note: Hardware constraint (refer to description of this function):     */
;;;881        /* Note: If ADC instance feature scan mode is disabled                    */
;;;882        /*       (refer to  ADC instance initialization structure                 */
;;;883        /*       parameter @ref SequencersScanMode                                */
;;;884        /*       or function @ref LL_ADC_SetSequencersScanMode() ),               */
;;;885        /*       this parameter is discarded.                                     */
;;;886        LL_ADC_INJ_SetSequencerLength(ADCx, ADC_INJ_InitStruct->SequencerLength);
000048  6868              LDR      r0,[r5,#4]
00004a  6ba1              LDR      r1,[r4,#0x38]
00004c  f4211140          BIC      r1,r1,#0x300000
000050  4301              ORRS     r1,r1,r0
000052  63a1              STR      r1,[r4,#0x38]
000054  bf00              NOP      
000056  e000              B        |L5.90|
                  |L5.88|
;;;887      }
;;;888      else
;;;889      {
;;;890        /* Initialization error: ADC instance is not disabled. */
;;;891        status = ERROR;
000058  2600              MOVS     r6,#0
                  |L5.90|
;;;892      }
;;;893      return status;
00005a  4630              MOV      r0,r6
;;;894    }
00005c  bd70              POP      {r4-r6,pc}
;;;895    
                          ENDP


                          AREA ||i.LL_ADC_INJ_StructInit||, CODE, READONLY, ALIGN=1

                  LL_ADC_INJ_StructInit PROC
;;;901      */
;;;902    void LL_ADC_INJ_StructInit(LL_ADC_INJ_InitTypeDef *ADC_INJ_InitStruct)
000000  2100              MOVS     r1,#0
;;;903    {
;;;904      /* Set ADC_INJ_InitStruct fields to default values */
;;;905      /* Set fields of ADC group injected */
;;;906      ADC_INJ_InitStruct->TriggerSource    = LL_ADC_INJ_TRIG_SOFTWARE;
000002  6001              STR      r1,[r0,#0]
;;;907      ADC_INJ_InitStruct->SequencerLength  = LL_ADC_INJ_SEQ_SCAN_DISABLE;
000004  6041              STR      r1,[r0,#4]
;;;908      ADC_INJ_InitStruct->SequencerDiscont = LL_ADC_INJ_SEQ_DISCONT_DISABLE;
000006  6081              STR      r1,[r0,#8]
;;;909      ADC_INJ_InitStruct->TrigAuto         = LL_ADC_INJ_TRIG_INDEPENDENT;
000008  60c1              STR      r1,[r0,#0xc]
;;;910    }
00000a  4770              BX       lr
;;;911    
                          ENDP


                          AREA ||i.LL_ADC_Init||, CODE, READONLY, ALIGN=2

                  LL_ADC_Init PROC
;;;596      */
;;;597    ErrorStatus LL_ADC_Init(ADC_TypeDef *ADCx, LL_ADC_InitTypeDef *ADC_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;598    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;599      ErrorStatus status = SUCCESS;
000006  2601              MOVS     r6,#1
;;;600      
;;;601      /* Check the parameters */
;;;602      assert_param(IS_ADC_ALL_INSTANCE(ADCx));
;;;603      
;;;604      assert_param(IS_LL_ADC_RESOLUTION(ADC_InitStruct->Resolution));
;;;605      assert_param(IS_LL_ADC_DATA_ALIGN(ADC_InitStruct->DataAlignment));
;;;606      assert_param(IS_LL_ADC_SCAN_SELECTION(ADC_InitStruct->SequencersScanMode));
;;;607      
;;;608      /* Note: Hardware constraint (refer to description of this function):       */
;;;609      /*       ADC instance must be disabled.                                     */
;;;610      if(LL_ADC_IsEnabled(ADCx) == 0U)
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       LL_ADC_IsEnabled
00000e  b970              CBNZ     r0,|L7.46|
;;;611      {
;;;612        /* Configuration of ADC hierarchical scope:                               */
;;;613        /*  - ADC instance                                                        */
;;;614        /*    - Set ADC data resolution                                           */
;;;615        /*    - Set ADC conversion data alignment                                 */
;;;616        MODIFY_REG(ADCx->CR1,
000010  68a9              LDR      r1,[r5,#8]
000012  6828              LDR      r0,[r5,#0]
000014  4308              ORRS     r0,r0,r1
000016  6861              LDR      r1,[r4,#4]
000018  4a06              LDR      r2,|L7.52|
00001a  4011              ANDS     r1,r1,r2
00001c  4308              ORRS     r0,r0,r1
00001e  6060              STR      r0,[r4,#4]
;;;617                     ADC_CR1_RES
;;;618                   | ADC_CR1_SCAN
;;;619                  ,
;;;620                     ADC_InitStruct->Resolution
;;;621                   | ADC_InitStruct->SequencersScanMode
;;;622                  );
;;;623        
;;;624        MODIFY_REG(ADCx->CR2,
000020  68a0              LDR      r0,[r4,#8]
000022  f4206000          BIC      r0,r0,#0x800
000026  6869              LDR      r1,[r5,#4]
000028  4308              ORRS     r0,r0,r1
00002a  60a0              STR      r0,[r4,#8]
00002c  e000              B        |L7.48|
                  |L7.46|
;;;625                     ADC_CR2_ALIGN
;;;626                  ,
;;;627                     ADC_InitStruct->DataAlignment
;;;628                  );
;;;629    
;;;630      }
;;;631      else
;;;632      {
;;;633        /* Initialization error: ADC instance is not disabled. */
;;;634        status = ERROR;
00002e  2600              MOVS     r6,#0
                  |L7.48|
;;;635      }
;;;636      return status;
000030  4630              MOV      r0,r6
;;;637    }
000032  bd70              POP      {r4-r6,pc}
;;;638    
                          ENDP

                  |L7.52|
                          DCD      0xfcfffeff

                          AREA ||i.LL_ADC_IsEnabled||, CODE, READONLY, ALIGN=1

                  LL_ADC_IsEnabled PROC
;;;3798     */
;;;3799   __STATIC_INLINE uint32_t LL_ADC_IsEnabled(ADC_TypeDef *ADCx)
000000  4601              MOV      r1,r0
;;;3800   {
;;;3801     return (READ_BIT(ADCx->CR2, ADC_CR2_ADON) == (ADC_CR2_ADON));
000002  6888              LDR      r0,[r1,#8]
000004  f0000001          AND      r0,r0,#1
;;;3802   }
000008  4770              BX       lr
;;;3803   
                          ENDP


                          AREA ||i.LL_ADC_REG_Init||, CODE, READONLY, ALIGN=2

                  LL_ADC_REG_Init PROC
;;;691      */
;;;692    ErrorStatus LL_ADC_REG_Init(ADC_TypeDef *ADCx, LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;693    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;694      ErrorStatus status = SUCCESS;
000006  2601              MOVS     r6,#1
;;;695      
;;;696      /* Check the parameters */
;;;697      assert_param(IS_ADC_ALL_INSTANCE(ADCx));
;;;698      assert_param(IS_LL_ADC_REG_TRIG_SOURCE(ADC_REG_InitStruct->TriggerSource));
;;;699      assert_param(IS_LL_ADC_REG_SEQ_SCAN_LENGTH(ADC_REG_InitStruct->SequencerLength));
;;;700      if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
000008  6860              LDR      r0,[r4,#4]
00000a  b100              CBZ      r0,|L9.14|
;;;701      {
;;;702        assert_param(IS_LL_ADC_REG_SEQ_SCAN_DISCONT_MODE(ADC_REG_InitStruct->SequencerDiscont));
00000c  bf00              NOP      
                  |L9.14|
;;;703      }
;;;704      assert_param(IS_LL_ADC_REG_CONTINUOUS_MODE(ADC_REG_InitStruct->ContinuousMode));
;;;705      assert_param(IS_LL_ADC_REG_DMA_TRANSFER(ADC_REG_InitStruct->DMATransfer));
;;;706      
;;;707      /* Note: Hardware constraint (refer to description of this function):       */
;;;708      /*       ADC instance must be disabled.                                     */
;;;709      if(LL_ADC_IsEnabled(ADCx) == 0U)
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       LL_ADC_IsEnabled
000014  bb20              CBNZ     r0,|L9.96|
;;;710      {
;;;711        /* Configuration of ADC hierarchical scope:                               */
;;;712        /*  - ADC group regular                                                   */
;;;713        /*    - Set ADC group regular trigger source                              */
;;;714        /*    - Set ADC group regular sequencer length                            */
;;;715        /*    - Set ADC group regular sequencer discontinuous mode                */
;;;716        /*    - Set ADC group regular continuous mode                             */
;;;717        /*    - Set ADC group regular conversion data transfer: no transfer or    */
;;;718        /*      transfer by DMA, and DMA requests mode                            */
;;;719        /* Note: On this STM32 serie, ADC trigger edge is set when starting       */
;;;720        /*       ADC conversion.                                                  */
;;;721        /*       Refer to function @ref LL_ADC_REG_StartConversionExtTrig().      */
;;;722        if(ADC_REG_InitStruct->SequencerLength != LL_ADC_REG_SEQ_SCAN_DISABLE)
000016  6860              LDR      r0,[r4,#4]
000018  b140              CBZ      r0,|L9.44|
;;;723        {
;;;724          MODIFY_REG(ADCx->CR1,
00001a  e9d40101          LDRD     r0,r1,[r4,#4]
00001e  4308              ORRS     r0,r0,r1
000020  6869              LDR      r1,[r5,#4]
000022  f4214168          BIC      r1,r1,#0xe800
000026  4308              ORRS     r0,r0,r1
000028  6068              STR      r0,[r5,#4]
00002a  e005              B        |L9.56|
                  |L9.44|
;;;725                       ADC_CR1_DISCEN
;;;726                     | ADC_CR1_DISCNUM
;;;727                    ,
;;;728                       ADC_REG_InitStruct->SequencerLength
;;;729                     | ADC_REG_InitStruct->SequencerDiscont
;;;730                    );
;;;731        }
;;;732        else
;;;733        {
;;;734          MODIFY_REG(ADCx->CR1,
00002c  6868              LDR      r0,[r5,#4]
00002e  f4204068          BIC      r0,r0,#0xe800
000032  6861              LDR      r1,[r4,#4]
000034  4308              ORRS     r0,r0,r1
000036  6068              STR      r0,[r5,#4]
                  |L9.56|
;;;735                       ADC_CR1_DISCEN
;;;736                     | ADC_CR1_DISCNUM
;;;737                    ,
;;;738                       ADC_REG_InitStruct->SequencerLength
;;;739                     | LL_ADC_REG_SEQ_DISCONT_DISABLE
;;;740                    );
;;;741        }
;;;742        
;;;743        MODIFY_REG(ADCx->CR2,
000038  6820              LDR      r0,[r4,#0]
00003a  f0006070          AND      r0,r0,#0xf000000
00003e  68e1              LDR      r1,[r4,#0xc]
000040  4308              ORRS     r0,r0,r1
000042  6921              LDR      r1,[r4,#0x10]
000044  4308              ORRS     r0,r0,r1
000046  68a9              LDR      r1,[r5,#8]
000048  4a07              LDR      r2,|L9.104|
00004a  4011              ANDS     r1,r1,r2
00004c  4308              ORRS     r0,r0,r1
00004e  60a8              STR      r0,[r5,#8]
;;;744                     ADC_CR2_EXTSEL
;;;745                   | ADC_CR2_EXTEN
;;;746                   | ADC_CR2_CONT
;;;747                   | ADC_CR2_DMA
;;;748                   | ADC_CR2_DDS
;;;749                  ,
;;;750                    (ADC_REG_InitStruct->TriggerSource & ADC_CR2_EXTSEL)
;;;751                   | ADC_REG_InitStruct->ContinuousMode
;;;752                   | ADC_REG_InitStruct->DMATransfer
;;;753                  );
;;;754    
;;;755        /* Set ADC group regular sequencer length and scan direction */
;;;756        /* Note: Hardware constraint (refer to description of this function):     */
;;;757        /* Note: If ADC instance feature scan mode is disabled                    */
;;;758        /*       (refer to  ADC instance initialization structure                 */
;;;759        /*       parameter @ref SequencersScanMode                                */
;;;760        /*       or function @ref LL_ADC_SetSequencersScanMode() ),               */
;;;761        /*       this parameter is discarded.                                     */
;;;762        LL_ADC_REG_SetSequencerLength(ADCx, ADC_REG_InitStruct->SequencerLength);
000050  6860              LDR      r0,[r4,#4]
000052  6ae9              LDR      r1,[r5,#0x2c]
000054  f4210170          BIC      r1,r1,#0xf00000
000058  4301              ORRS     r1,r1,r0
00005a  62e9              STR      r1,[r5,#0x2c]
00005c  bf00              NOP      
00005e  e000              B        |L9.98|
                  |L9.96|
;;;763      }
;;;764      else
;;;765      {
;;;766        /* Initialization error: ADC instance is not disabled. */
;;;767        status = ERROR;
000060  2600              MOVS     r6,#0
                  |L9.98|
;;;768      }
;;;769      return status;
000062  4630              MOV      r0,r6
;;;770    }
000064  bd70              POP      {r4-r6,pc}
;;;771    
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      0xc0fffcfd

                          AREA ||i.LL_ADC_REG_StructInit||, CODE, READONLY, ALIGN=1

                  LL_ADC_REG_StructInit PROC
;;;777      */
;;;778    void LL_ADC_REG_StructInit(LL_ADC_REG_InitTypeDef *ADC_REG_InitStruct)
000000  2100              MOVS     r1,#0
;;;779    {
;;;780      /* Set ADC_REG_InitStruct fields to default values */
;;;781      /* Set fields of ADC group regular */
;;;782      /* Note: On this STM32 serie, ADC trigger edge is set when starting         */
;;;783      /*       ADC conversion.                                                    */
;;;784      /*       Refer to function @ref LL_ADC_REG_StartConversionExtTrig().        */
;;;785      ADC_REG_InitStruct->TriggerSource    = LL_ADC_REG_TRIG_SOFTWARE;
000002  6001              STR      r1,[r0,#0]
;;;786      ADC_REG_InitStruct->SequencerLength  = LL_ADC_REG_SEQ_SCAN_DISABLE;
000004  6041              STR      r1,[r0,#4]
;;;787      ADC_REG_InitStruct->SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
000006  6081              STR      r1,[r0,#8]
;;;788      ADC_REG_InitStruct->ContinuousMode   = LL_ADC_REG_CONV_SINGLE;
000008  60c1              STR      r1,[r0,#0xc]
;;;789      ADC_REG_InitStruct->DMATransfer      = LL_ADC_REG_DMA_TRANSFER_NONE;
00000a  6101              STR      r1,[r0,#0x10]
;;;790    }
00000c  4770              BX       lr
;;;791    
                          ENDP


                          AREA ||i.LL_ADC_StructInit||, CODE, READONLY, ALIGN=1

                  LL_ADC_StructInit PROC
;;;644      */
;;;645    void LL_ADC_StructInit(LL_ADC_InitTypeDef *ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;646    {
;;;647      /* Set ADC_InitStruct fields to default values */
;;;648      /* Set fields of ADC instance */
;;;649      ADC_InitStruct->Resolution    = LL_ADC_RESOLUTION_12B;
000002  6001              STR      r1,[r0,#0]
;;;650      ADC_InitStruct->DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
000004  6041              STR      r1,[r0,#4]
;;;651      
;;;652      /* Enable scan mode to have a generic behavior with ADC of other            */
;;;653      /* STM32 families, without this setting available:                          */
;;;654      /* ADC group regular sequencer and ADC group injected sequencer depend      */
;;;655      /* only of their own configuration.                                         */
;;;656      ADC_InitStruct->SequencersScanMode      = LL_ADC_SEQ_SCAN_ENABLE;
000006  f44f7180          MOV      r1,#0x100
00000a  6081              STR      r1,[r0,#8]
;;;657      
;;;658    }
00000c  4770              BX       lr
;;;659    
                          ENDP


;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_adc_c_d324f57e____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f4xx_ll_adc_c_d324f57e____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_adc_c_d324f57e____REVSH|
#line 402
|__asm___18_stm32f4xx_ll_adc_c_d324f57e____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_adc_c_d324f57e____RRX|
#line 587
|__asm___18_stm32f4xx_ll_adc_c_d324f57e____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
