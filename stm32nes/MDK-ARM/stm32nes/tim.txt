; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\tim.o --depend=stm32nes\tim.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\tim.crf ../Src/tim.c]
                          THUMB

                          AREA ||i.LL_APB1_GRP1_EnableClock||, CODE, READONLY, ALIGN=2

                  LL_APB1_GRP1_EnableClock PROC
;;;1202   */
;;;1203   __STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
000000  b508              PUSH     {r3,lr}
;;;1204   {
;;;1205     __IO uint32_t tmpreg;
;;;1206     SET_BIT(RCC->APB1ENR, Periphs);
000002  4905              LDR      r1,|L1.24|
000004  6809              LDR      r1,[r1,#0]
000006  4301              ORRS     r1,r1,r0
000008  4a03              LDR      r2,|L1.24|
00000a  6011              STR      r1,[r2,#0]
;;;1207     /* Delay after an RCC peripheral clock enabling */
;;;1208     tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4001              ANDS     r1,r1,r0
000012  9100              STR      r1,[sp,#0]
;;;1209     (void)tmpreg;
000014  bf00              NOP      
;;;1210   }
000016  bd08              POP      {r3,pc}
;;;1211   
                          ENDP

                  |L1.24|
                          DCD      0x40023840

                          AREA ||i.LL_APB2_GRP1_EnableClock||, CODE, READONLY, ALIGN=2

                  LL_APB2_GRP1_EnableClock PROC
;;;1721   */
;;;1722   __STATIC_INLINE void LL_APB2_GRP1_EnableClock(uint32_t Periphs)
000000  b508              PUSH     {r3,lr}
;;;1723   {
;;;1724     __IO uint32_t tmpreg;
;;;1725     SET_BIT(RCC->APB2ENR, Periphs);
000002  4905              LDR      r1,|L2.24|
000004  6809              LDR      r1,[r1,#0]
000006  4301              ORRS     r1,r1,r0
000008  4a03              LDR      r2,|L2.24|
00000a  6011              STR      r1,[r2,#0]
;;;1726     /* Delay after an RCC peripheral clock enabling */
;;;1727     tmpreg = READ_BIT(RCC->APB2ENR, Periphs);
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  4001              ANDS     r1,r1,r0
000012  9100              STR      r1,[sp,#0]
;;;1728     (void)tmpreg;
000014  bf00              NOP      
;;;1729   }
000016  bd08              POP      {r3,pc}
;;;1730   
                          ENDP

                  |L2.24|
                          DCD      0x40023844

                          AREA ||i.LL_TIM_DisableMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  LL_TIM_DisableMasterSlaveMode PROC
;;;2727     */
;;;2728   __STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
000000  6881              LDR      r1,[r0,#8]
;;;2729   {
;;;2730     CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
000002  f0210180          BIC      r1,r1,#0x80
000006  6081              STR      r1,[r0,#8]
;;;2731   }
000008  4770              BX       lr
;;;2732   
                          ENDP


                          AREA ||i.LL_TIM_OC_DisableFast||, CODE, READONLY, ALIGN=2

                  LL_TIM_OC_DisableFast PROC
;;;1848     */
;;;1849   __STATIC_INLINE void LL_TIM_OC_DisableFast(TIM_TypeDef *TIMx, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1850   {
000002  4602              MOV      r2,r0
;;;1851     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
000004  2901              CMP      r1,#1
000006  d101              BNE      |L4.12|
000008  2400              MOVS     r4,#0
00000a  e016              B        |L4.58|
                  |L4.12|
00000c  2904              CMP      r1,#4
00000e  d101              BNE      |L4.20|
000010  2401              MOVS     r4,#1
000012  e012              B        |L4.58|
                  |L4.20|
000014  2910              CMP      r1,#0x10
000016  d101              BNE      |L4.28|
000018  2402              MOVS     r4,#2
00001a  e00e              B        |L4.58|
                  |L4.28|
00001c  2940              CMP      r1,#0x40
00001e  d101              BNE      |L4.36|
000020  2403              MOVS     r4,#3
000022  e00a              B        |L4.58|
                  |L4.36|
000024  f5b17f80          CMP      r1,#0x100
000028  d101              BNE      |L4.46|
00002a  2404              MOVS     r4,#4
00002c  e005              B        |L4.58|
                  |L4.46|
00002e  f5b16f80          CMP      r1,#0x400
000032  d101              BNE      |L4.56|
000034  2405              MOVS     r4,#5
000036  e000              B        |L4.58|
                  |L4.56|
000038  2406              MOVS     r4,#6
                  |L4.58|
00003a  4623              MOV      r3,r4
;;;1852     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
00003c  4c06              LDR      r4,|L4.88|
00003e  5ce5              LDRB     r5,[r4,r3]
000040  f1020418          ADD      r4,r2,#0x18
000044  1928              ADDS     r0,r5,r4
;;;1853     CLEAR_BIT(*pReg, (TIM_CCMR1_OC1FE << SHIFT_TAB_OCxx[iChannel]));
000046  4d05              LDR      r5,|L4.92|
000048  5cee              LDRB     r6,[r5,r3]
00004a  2504              MOVS     r5,#4
00004c  40b5              LSLS     r5,r5,r6
00004e  6804              LDR      r4,[r0,#0]
000050  43ac              BICS     r4,r4,r5
000052  6004              STR      r4,[r0,#0]
;;;1854   
;;;1855   }
000054  bd70              POP      {r4-r6,pc}
;;;1856   
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      OFFSET_TAB_CCMRx
                  |L4.92|
                          DCD      SHIFT_TAB_OCxx

                          AREA ||i.LL_TIM_OC_EnablePreload||, CODE, READONLY, ALIGN=2

                  LL_TIM_OC_EnablePreload PROC
;;;1892     */
;;;1893   __STATIC_INLINE void LL_TIM_OC_EnablePreload(TIM_TypeDef *TIMx, uint32_t Channel)
000000  b570              PUSH     {r4-r6,lr}
;;;1894   {
000002  4602              MOV      r2,r0
;;;1895     register uint8_t iChannel = TIM_GET_CHANNEL_INDEX(Channel);
000004  2901              CMP      r1,#1
000006  d101              BNE      |L5.12|
000008  2400              MOVS     r4,#0
00000a  e016              B        |L5.58|
                  |L5.12|
00000c  2904              CMP      r1,#4
00000e  d101              BNE      |L5.20|
000010  2401              MOVS     r4,#1
000012  e012              B        |L5.58|
                  |L5.20|
000014  2910              CMP      r1,#0x10
000016  d101              BNE      |L5.28|
000018  2402              MOVS     r4,#2
00001a  e00e              B        |L5.58|
                  |L5.28|
00001c  2940              CMP      r1,#0x40
00001e  d101              BNE      |L5.36|
000020  2403              MOVS     r4,#3
000022  e00a              B        |L5.58|
                  |L5.36|
000024  f5b17f80          CMP      r1,#0x100
000028  d101              BNE      |L5.46|
00002a  2404              MOVS     r4,#4
00002c  e005              B        |L5.58|
                  |L5.46|
00002e  f5b16f80          CMP      r1,#0x400
000032  d101              BNE      |L5.56|
000034  2405              MOVS     r4,#5
000036  e000              B        |L5.58|
                  |L5.56|
000038  2406              MOVS     r4,#6
                  |L5.58|
00003a  4623              MOV      r3,r4
;;;1896     register uint32_t *pReg = (uint32_t *)((uint32_t)((uint32_t)(&TIMx->CCMR1) + OFFSET_TAB_CCMRx[iChannel]));
00003c  4c06              LDR      r4,|L5.88|
00003e  5ce5              LDRB     r5,[r4,r3]
000040  f1020418          ADD      r4,r2,#0x18
000044  1928              ADDS     r0,r5,r4
;;;1897     SET_BIT(*pReg, (TIM_CCMR1_OC1PE << SHIFT_TAB_OCxx[iChannel]));
000046  4d05              LDR      r5,|L5.92|
000048  5cee              LDRB     r6,[r5,r3]
00004a  2508              MOVS     r5,#8
00004c  40b5              LSLS     r5,r5,r6
00004e  6804              LDR      r4,[r0,#0]
000050  432c              ORRS     r4,r4,r5
000052  6004              STR      r4,[r0,#0]
;;;1898   }
000054  bd70              POP      {r4-r6,pc}
;;;1899   
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      OFFSET_TAB_CCMRx
                  |L5.92|
                          DCD      SHIFT_TAB_OCxx

                          AREA ||i.LL_TIM_SetClockSource||, CODE, READONLY, ALIGN=1

                  LL_TIM_SetClockSource PROC
;;;2615     */
;;;2616   __STATIC_INLINE void LL_TIM_SetClockSource(TIM_TypeDef *TIMx, uint32_t ClockSource)
000000  6882              LDR      r2,[r0,#8]
;;;2617   {
;;;2618     MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS | TIM_SMCR_ECE, ClockSource);
000002  f2440307          MOV      r3,#0x4007
000006  439a              BICS     r2,r2,r3
000008  430a              ORRS     r2,r2,r1
00000a  6082              STR      r2,[r0,#8]
;;;2619   }
00000c  4770              BX       lr
;;;2620   
                          ENDP


                          AREA ||i.LL_TIM_SetTriggerOutput||, CODE, READONLY, ALIGN=1

                  LL_TIM_SetTriggerOutput PROC
;;;2661     */
;;;2662   __STATIC_INLINE void LL_TIM_SetTriggerOutput(TIM_TypeDef *TIMx, uint32_t TimerSynchronization)
000000  6842              LDR      r2,[r0,#4]
;;;2663   {
;;;2664     MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
000002  f0220270          BIC      r2,r2,#0x70
000006  430a              ORRS     r2,r2,r1
000008  6042              STR      r2,[r0,#4]
;;;2665   }
00000a  4770              BX       lr
;;;2666   
                          ENDP


                          AREA ||i.MX_TIM10_Init||, CODE, READONLY, ALIGN=2

                  MX_TIM10_Init PROC
;;;99     /* TIM10 init function */
;;;100    void MX_TIM10_Init(void)
000000  b500              PUSH     {lr}
;;;101    {
000002  b085              SUB      sp,sp,#0x14
;;;102      LL_TIM_InitTypeDef TIM_InitStruct = {0};
000004  2114              MOVS     r1,#0x14
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;103    
;;;104      /* Peripheral clock enable */
;;;105      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM10);
00000c  f44f3000          MOV      r0,#0x20000
000010  f7fffffe          BL       LL_APB2_GRP1_EnableClock
;;;106    
;;;107      TIM_InitStruct.Prescaler = 0;
000014  2000              MOVS     r0,#0
000016  f8ad0000          STRH     r0,[sp,#0]
;;;108      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
00001a  9001              STR      r0,[sp,#4]
;;;109      TIM_InitStruct.Autoreload = 0;
00001c  9002              STR      r0,[sp,#8]
;;;110      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
00001e  9003              STR      r0,[sp,#0xc]
;;;111      LL_TIM_Init(TIM10, &TIM_InitStruct);
000020  4669              MOV      r1,sp
000022  4802              LDR      r0,|L8.44|
000024  f7fffffe          BL       LL_TIM_Init
;;;112    
;;;113    }
000028  b005              ADD      sp,sp,#0x14
00002a  bd00              POP      {pc}
;;;114    /* TIM11 init function */
                          ENDP

                  |L8.44|
                          DCD      0x40014400

                          AREA ||i.MX_TIM11_Init||, CODE, READONLY, ALIGN=2

                  MX_TIM11_Init PROC
;;;114    /* TIM11 init function */
;;;115    void MX_TIM11_Init(void)
000000  b500              PUSH     {lr}
;;;116    {
000002  b085              SUB      sp,sp,#0x14
;;;117      LL_TIM_InitTypeDef TIM_InitStruct = {0};
000004  2114              MOVS     r1,#0x14
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;118    
;;;119      /* Peripheral clock enable */
;;;120      LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM11);
00000c  f44f2080          MOV      r0,#0x40000
000010  f7fffffe          BL       LL_APB2_GRP1_EnableClock
;;;121    
;;;122      TIM_InitStruct.Prescaler = 0;
000014  2000              MOVS     r0,#0
000016  f8ad0000          STRH     r0,[sp,#0]
;;;123      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
00001a  9001              STR      r0,[sp,#4]
;;;124      TIM_InitStruct.Autoreload = 0;
00001c  9002              STR      r0,[sp,#8]
;;;125      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
00001e  9003              STR      r0,[sp,#0xc]
;;;126      LL_TIM_Init(TIM11, &TIM_InitStruct);
000020  4669              MOV      r1,sp
000022  4802              LDR      r0,|L9.44|
000024  f7fffffe          BL       LL_TIM_Init
;;;127    
;;;128    }
000028  b005              ADD      sp,sp,#0x14
00002a  bd00              POP      {pc}
;;;129    /* TIM12 init function */
                          ENDP

                  |L9.44|
                          DCD      0x40014800

                          AREA ||i.MX_TIM12_Init||, CODE, READONLY, ALIGN=2

                  MX_TIM12_Init PROC
;;;129    /* TIM12 init function */
;;;130    void MX_TIM12_Init(void)
000000  b500              PUSH     {lr}
;;;131    {
000002  b085              SUB      sp,sp,#0x14
;;;132      LL_TIM_InitTypeDef TIM_InitStruct = {0};
000004  2114              MOVS     r1,#0x14
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;133    
;;;134      /* Peripheral clock enable */
;;;135      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM12);
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       LL_APB1_GRP1_EnableClock
;;;136    
;;;137      TIM_InitStruct.Prescaler = 0;
000012  2000              MOVS     r0,#0
000014  f8ad0000          STRH     r0,[sp,#0]
;;;138      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
000018  9001              STR      r0,[sp,#4]
;;;139      TIM_InitStruct.Autoreload = 0;
00001a  9002              STR      r0,[sp,#8]
;;;140      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
00001c  9003              STR      r0,[sp,#0xc]
;;;141      LL_TIM_Init(TIM12, &TIM_InitStruct);
00001e  4669              MOV      r1,sp
000020  4804              LDR      r0,|L10.52|
000022  f7fffffe          BL       LL_TIM_Init
;;;142      LL_TIM_SetClockSource(TIM12, LL_TIM_CLOCKSOURCE_INTERNAL);
000026  2100              MOVS     r1,#0
000028  4802              LDR      r0,|L10.52|
00002a  f7fffffe          BL       LL_TIM_SetClockSource
;;;143    
;;;144    }
00002e  b005              ADD      sp,sp,#0x14
000030  bd00              POP      {pc}
;;;145    /* TIM13 init function */
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      0x40001800

                          AREA ||i.MX_TIM13_Init||, CODE, READONLY, ALIGN=2

                  MX_TIM13_Init PROC
;;;145    /* TIM13 init function */
;;;146    void MX_TIM13_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;147    {
000002  b095              SUB      sp,sp,#0x54
;;;148      LL_TIM_InitTypeDef TIM_InitStruct = {0};
000004  2114              MOVS     r1,#0x14
000006  a810              ADD      r0,sp,#0x40
000008  f7fffffe          BL       __aeabi_memclr4
;;;149      LL_TIM_OC_InitTypeDef TIM_OC_InitStruct = {0};
00000c  2120              MOVS     r1,#0x20
00000e  a808              ADD      r0,sp,#0x20
000010  f7fffffe          BL       __aeabi_memclr4
;;;150    
;;;151      LL_GPIO_InitTypeDef GPIO_InitStruct = {0};
000014  2118              MOVS     r1,#0x18
000016  a802              ADD      r0,sp,#8
000018  f7fffffe          BL       __aeabi_memclr4
;;;152      /* Peripheral clock enable */
;;;153      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM13);
00001c  2080              MOVS     r0,#0x80
00001e  f7fffffe          BL       LL_APB1_GRP1_EnableClock
;;;154    
;;;155      /* TIM13 interrupt Init */
;;;156      NVIC_SetPriority(TIM8_UP_TIM13_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
000022  f7fffffe          BL       NVIC_GetPriorityGrouping
000026  4605              MOV      r5,r0
000028  2200              MOVS     r2,#0
00002a  4611              MOV      r1,r2
00002c  f7fffffe          BL       NVIC_EncodePriority
000030  4604              MOV      r4,r0
000032  4621              MOV      r1,r4
000034  202c              MOVS     r0,#0x2c
000036  f7fffffe          BL       NVIC_SetPriority
;;;157      NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn);
00003a  202c              MOVS     r0,#0x2c
00003c  f7fffffe          BL       NVIC_EnableIRQ
;;;158    
;;;159      TIM_InitStruct.Prescaler = 0;
000040  2000              MOVS     r0,#0
000042  f8ad0040          STRH     r0,[sp,#0x40]
;;;160      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
000046  9011              STR      r0,[sp,#0x44]
;;;161      TIM_InitStruct.Autoreload = 0;
000048  9012              STR      r0,[sp,#0x48]
;;;162      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
00004a  9013              STR      r0,[sp,#0x4c]
;;;163      LL_TIM_Init(TIM13, &TIM_InitStruct);
00004c  a910              ADD      r1,sp,#0x40
00004e  481a              LDR      r0,|L11.184|
000050  f7fffffe          BL       LL_TIM_Init
;;;164      LL_TIM_OC_EnablePreload(TIM13, LL_TIM_CHANNEL_CH1);
000054  2101              MOVS     r1,#1
000056  4818              LDR      r0,|L11.184|
000058  f7fffffe          BL       LL_TIM_OC_EnablePreload
;;;165      TIM_OC_InitStruct.OCMode = LL_TIM_OCMODE_PWM1;
00005c  2060              MOVS     r0,#0x60
00005e  9008              STR      r0,[sp,#0x20]
;;;166      TIM_OC_InitStruct.OCState = LL_TIM_OCSTATE_ENABLE;
000060  2001              MOVS     r0,#1
000062  9009              STR      r0,[sp,#0x24]
;;;167      TIM_OC_InitStruct.OCNState = LL_TIM_OCSTATE_ENABLE;
000064  900a              STR      r0,[sp,#0x28]
;;;168      TIM_OC_InitStruct.CompareValue = 0;
000066  2000              MOVS     r0,#0
000068  900b              STR      r0,[sp,#0x2c]
;;;169      TIM_OC_InitStruct.OCPolarity = LL_TIM_OCPOLARITY_LOW;
00006a  2002              MOVS     r0,#2
00006c  900c              STR      r0,[sp,#0x30]
;;;170      LL_TIM_OC_Init(TIM13, LL_TIM_CHANNEL_CH1, &TIM_OC_InitStruct);
00006e  aa08              ADD      r2,sp,#0x20
000070  2101              MOVS     r1,#1
000072  4811              LDR      r0,|L11.184|
000074  f7fffffe          BL       LL_TIM_OC_Init
;;;171      LL_TIM_OC_DisableFast(TIM13, LL_TIM_CHANNEL_CH1);
000078  2101              MOVS     r1,#1
00007a  480f              LDR      r0,|L11.184|
00007c  f7fffffe          BL       LL_TIM_OC_DisableFast
;;;172      LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA);
000080  2001              MOVS     r0,#1
000082  490e              LDR      r1,|L11.188|
000084  6809              LDR      r1,[r1,#0]
000086  4301              ORRS     r1,r1,r0
000088  4a0c              LDR      r2,|L11.188|
00008a  6011              STR      r1,[r2,#0]
00008c  4611              MOV      r1,r2
00008e  6809              LDR      r1,[r1,#0]
000090  4001              ANDS     r1,r1,r0
000092  9101              STR      r1,[sp,#4]
000094  bf00              NOP      
000096  bf00              NOP      
;;;173        /**TIM13 GPIO Configuration    
;;;174        PA6     ------> TIM13_CH1 
;;;175        */
;;;176      GPIO_InitStruct.Pin = TFT_LED_Pin;
000098  2040              MOVS     r0,#0x40
00009a  9002              STR      r0,[sp,#8]
;;;177      GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
00009c  2002              MOVS     r0,#2
00009e  9003              STR      r0,[sp,#0xc]
;;;178      GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
0000a0  2000              MOVS     r0,#0
0000a2  9004              STR      r0,[sp,#0x10]
;;;179      GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
0000a4  9005              STR      r0,[sp,#0x14]
;;;180      GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
0000a6  9006              STR      r0,[sp,#0x18]
;;;181      GPIO_InitStruct.Alternate = LL_GPIO_AF_9;
0000a8  2009              MOVS     r0,#9
0000aa  9007              STR      r0,[sp,#0x1c]
;;;182      LL_GPIO_Init(TFT_LED_GPIO_Port, &GPIO_InitStruct);
0000ac  a902              ADD      r1,sp,#8
0000ae  4804              LDR      r0,|L11.192|
0000b0  f7fffffe          BL       LL_GPIO_Init
;;;183    
;;;184    }
0000b4  b015              ADD      sp,sp,#0x54
0000b6  bd30              POP      {r4,r5,pc}
;;;185    /* TIM14 init function */
                          ENDP

                  |L11.184|
                          DCD      0x40001c00
                  |L11.188|
                          DCD      0x40023830
                  |L11.192|
                          DCD      0x40020000

                          AREA ||i.MX_TIM14_Init||, CODE, READONLY, ALIGN=2

                  MX_TIM14_Init PROC
;;;185    /* TIM14 init function */
;;;186    void MX_TIM14_Init(void)
000000  b500              PUSH     {lr}
;;;187    {
000002  b085              SUB      sp,sp,#0x14
;;;188      LL_TIM_InitTypeDef TIM_InitStruct = {0};
000004  2114              MOVS     r1,#0x14
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;189    
;;;190      /* Peripheral clock enable */
;;;191      LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM14);
00000c  f44f7080          MOV      r0,#0x100
000010  f7fffffe          BL       LL_APB1_GRP1_EnableClock
;;;192    
;;;193      TIM_InitStruct.Prescaler = 0;
000014  2000              MOVS     r0,#0
000016  f8ad0000          STRH     r0,[sp,#0]
;;;194      TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
00001a  9001              STR      r0,[sp,#4]
;;;195      TIM_InitStruct.Autoreload = 0;
00001c  9002              STR      r0,[sp,#8]
;;;196      TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
00001e  9003              STR      r0,[sp,#0xc]
;;;197      LL_TIM_Init(TIM14, &TIM_InitStruct);
000020  4669              MOV      r1,sp
000022  4802              LDR      r0,|L12.44|
000024  f7fffffe          BL       LL_TIM_Init
;;;198    
;;;199    }
000028  b005              ADD      sp,sp,#0x14
00002a  bd00              POP      {pc}
;;;200    
                          ENDP

                  |L12.44|
                          DCD      0x40002000

                          AREA ||i.MX_TIM6_Init||, CODE, READONLY, ALIGN=2

                  MX_TIM6_Init PROC
;;;47     /* TIM6 init function */
;;;48     void MX_TIM6_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;49     {
000002  b085              SUB      sp,sp,#0x14
;;;50       LL_TIM_InitTypeDef TIM_InitStruct = {0};
000004  2114              MOVS     r1,#0x14
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;51     
;;;52       /* Peripheral clock enable */
;;;53       LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM6);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       LL_APB1_GRP1_EnableClock
;;;54     
;;;55       /* TIM6 interrupt Init */
;;;56       NVIC_SetPriority(TIM6_DAC_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
000012  f7fffffe          BL       NVIC_GetPriorityGrouping
000016  4605              MOV      r5,r0
000018  2200              MOVS     r2,#0
00001a  4611              MOV      r1,r2
00001c  f7fffffe          BL       NVIC_EncodePriority
000020  4604              MOV      r4,r0
000022  4621              MOV      r1,r4
000024  2036              MOVS     r0,#0x36
000026  f7fffffe          BL       NVIC_SetPriority
;;;57       NVIC_EnableIRQ(TIM6_DAC_IRQn);
00002a  2036              MOVS     r0,#0x36
00002c  f7fffffe          BL       NVIC_EnableIRQ
;;;58     
;;;59       TIM_InitStruct.Prescaler = 83;
000030  2053              MOVS     r0,#0x53
000032  f8ad0000          STRH     r0,[sp,#0]
;;;60       TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
000036  2000              MOVS     r0,#0
000038  9001              STR      r0,[sp,#4]
;;;61       TIM_InitStruct.Autoreload = 16666;
00003a  f244101a          MOV      r0,#0x411a
00003e  9002              STR      r0,[sp,#8]
;;;62       LL_TIM_Init(TIM6, &TIM_InitStruct);
000040  4669              MOV      r1,sp
000042  4806              LDR      r0,|L13.92|
000044  f7fffffe          BL       LL_TIM_Init
;;;63       LL_TIM_SetTriggerOutput(TIM6, LL_TIM_TRGO_RESET);
000048  2100              MOVS     r1,#0
00004a  4804              LDR      r0,|L13.92|
00004c  f7fffffe          BL       LL_TIM_SetTriggerOutput
;;;64       LL_TIM_DisableMasterSlaveMode(TIM6);
000050  4802              LDR      r0,|L13.92|
000052  f7fffffe          BL       LL_TIM_DisableMasterSlaveMode
;;;65     
;;;66     }
000056  b005              ADD      sp,sp,#0x14
000058  bd30              POP      {r4,r5,pc}
;;;67     /* TIM7 init function */
                          ENDP

00005a  0000              DCW      0x0000
                  |L13.92|
                          DCD      0x40001000

                          AREA ||i.MX_TIM7_Init||, CODE, READONLY, ALIGN=2

                  MX_TIM7_Init PROC
;;;67     /* TIM7 init function */
;;;68     void MX_TIM7_Init(void)
000000  b500              PUSH     {lr}
;;;69     {
000002  b085              SUB      sp,sp,#0x14
;;;70       LL_TIM_InitTypeDef TIM_InitStruct = {0};
000004  2114              MOVS     r1,#0x14
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;71     
;;;72       /* Peripheral clock enable */
;;;73       LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_TIM7);
00000c  2020              MOVS     r0,#0x20
00000e  f7fffffe          BL       LL_APB1_GRP1_EnableClock
;;;74     
;;;75       TIM_InitStruct.Prescaler = 0;
000012  2000              MOVS     r0,#0
000014  f8ad0000          STRH     r0,[sp,#0]
;;;76       TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
000018  9001              STR      r0,[sp,#4]
;;;77       TIM_InitStruct.Autoreload = 0;
00001a  9002              STR      r0,[sp,#8]
;;;78       LL_TIM_Init(TIM7, &TIM_InitStruct);
00001c  4669              MOV      r1,sp
00001e  4806              LDR      r0,|L14.56|
000020  f7fffffe          BL       LL_TIM_Init
;;;79       LL_TIM_SetTriggerOutput(TIM7, LL_TIM_TRGO_RESET);
000024  2100              MOVS     r1,#0
000026  4804              LDR      r0,|L14.56|
000028  f7fffffe          BL       LL_TIM_SetTriggerOutput
;;;80       LL_TIM_DisableMasterSlaveMode(TIM7);
00002c  4802              LDR      r0,|L14.56|
00002e  f7fffffe          BL       LL_TIM_DisableMasterSlaveMode
;;;81     
;;;82     }
000032  b005              ADD      sp,sp,#0x14
000034  bd00              POP      {pc}
;;;83     /* TIM9 init function */
                          ENDP

000036  0000              DCW      0x0000
                  |L14.56|
                          DCD      0x40001400

                          AREA ||i.MX_TIM9_Init||, CODE, READONLY, ALIGN=2

                  MX_TIM9_Init PROC
;;;83     /* TIM9 init function */
;;;84     void MX_TIM9_Init(void)
000000  b500              PUSH     {lr}
;;;85     {
000002  b085              SUB      sp,sp,#0x14
;;;86       LL_TIM_InitTypeDef TIM_InitStruct = {0};
000004  2114              MOVS     r1,#0x14
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;87     
;;;88       /* Peripheral clock enable */
;;;89       LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM9);
00000c  f44f3080          MOV      r0,#0x10000
000010  f7fffffe          BL       LL_APB2_GRP1_EnableClock
;;;90     
;;;91       TIM_InitStruct.Prescaler = 0;
000014  2000              MOVS     r0,#0
000016  f8ad0000          STRH     r0,[sp,#0]
;;;92       TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;
00001a  9001              STR      r0,[sp,#4]
;;;93       TIM_InitStruct.Autoreload = 0;
00001c  9002              STR      r0,[sp,#8]
;;;94       TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;
00001e  9003              STR      r0,[sp,#0xc]
;;;95       LL_TIM_Init(TIM9, &TIM_InitStruct);
000020  4669              MOV      r1,sp
000022  4804              LDR      r0,|L15.52|
000024  f7fffffe          BL       LL_TIM_Init
;;;96       LL_TIM_SetClockSource(TIM9, LL_TIM_CLOCKSOURCE_INTERNAL);
000028  2100              MOVS     r1,#0
00002a  4802              LDR      r0,|L15.52|
00002c  f7fffffe          BL       LL_TIM_SetClockSource
;;;97     
;;;98     }
000030  b005              ADD      sp,sp,#0x14
000032  bd00              POP      {pc}
;;;99     /* TIM10 init function */
                          ENDP

                  |L15.52|
                          DCD      0x40014000

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0942              LSRS     r2,r0,#5
00000a  0092              LSLS     r2,r2,#2
00000c  f10222e0          ADD      r2,r2,#0xe000e000
000010  f8c21100          STR      r1,[r2,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NVIC_EncodePriority||, CODE, READONLY, ALIGN=1

                  NVIC_EncodePriority PROC
;;;1744    */
;;;1745   __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1746   {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;1747     uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
000006  f0030107          AND      r1,r3,#7
;;;1748     uint32_t PreemptPriorityBits;
;;;1749     uint32_t SubPriorityBits;
;;;1750   
;;;1751     PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
00000a  f1c10007          RSB      r0,r1,#7
00000e  2804              CMP      r0,#4
000010  d901              BLS      |L17.22|
000012  2004              MOVS     r0,#4
000014  e001              B        |L17.26|
                  |L17.22|
000016  f1c10007          RSB      r0,r1,#7
                  |L17.26|
00001a  4606              MOV      r6,r0
;;;1752     SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
00001c  1d08              ADDS     r0,r1,#4
00001e  2807              CMP      r0,#7
000020  d201              BCS      |L17.38|
000022  2000              MOVS     r0,#0
000024  e000              B        |L17.40|
                  |L17.38|
000026  1ec8              SUBS     r0,r1,#3
                  |L17.40|
000028  4605              MOV      r5,r0
;;;1753   
;;;1754     return (
00002a  2001              MOVS     r0,#1
00002c  40b0              LSLS     r0,r0,r6
00002e  1e40              SUBS     r0,r0,#1
000030  4020              ANDS     r0,r0,r4
000032  40a8              LSLS     r0,r0,r5
000034  2701              MOVS     r7,#1
000036  40af              LSLS     r7,r7,r5
000038  1e7f              SUBS     r7,r7,#1
00003a  4017              ANDS     r7,r7,r2
00003c  4338              ORRS     r0,r0,r7
;;;1755              ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
;;;1756              ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
;;;1757            );
;;;1758   }
00003e  bdf0              POP      {r4-r7,pc}
;;;1759   
                          ENDP


                          AREA ||i.NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  NVIC_GetPriorityGrouping PROC
;;;1614    */
;;;1615   __STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
000000  4802              LDR      r0,|L18.12|
;;;1616   {
;;;1617     return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
000002  6800              LDR      r0,[r0,#0]
000004  f3c02002          UBFX     r0,r0,#8,#3
;;;1618   }
000008  4770              BX       lr
;;;1619   
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      0xe000ed0c

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;1697    */
;;;1698   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;1699   {
;;;1700     if ((int32_t)(IRQn) < 0)
000002  2800              CMP      r0,#0
000004  da07              BGE      |L19.22|
;;;1701     {
;;;1702       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000006  070a              LSLS     r2,r1,#28
000008  0e14              LSRS     r4,r2,#24
00000a  4a05              LDR      r2,|L19.32|
00000c  f000030f          AND      r3,r0,#0xf
000010  1f1b              SUBS     r3,r3,#4
000012  54d4              STRB     r4,[r2,r3]
000014  e003              B        |L19.30|
                  |L19.22|
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000016  070a              LSLS     r2,r1,#28
000018  0e13              LSRS     r3,r2,#24
00001a  4a02              LDR      r2,|L19.36|
00001c  5413              STRB     r3,[r2,r0]
                  |L19.30|
;;;1707     }
;;;1708   }
00001e  bd10              POP      {r4,pc}
;;;1709   
                          ENDP

                  |L19.32|
                          DCD      0xe000ed18
                  |L19.36|
                          DCD      0xe000e400

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  STREAM_OFFSET_TAB
000000  10284058          DCB      0x10,0x28,0x40,0x58
000004  7088a0b8          DCB      0x70,0x88,0xa0,0xb8
                  aRCC_PLLSAIDIVRPrescTable
000008  02040810          DCB      0x02,0x04,0x08,0x10
                  OFFSET_TAB_CCMRx
00000c  00000000          DCB      0x00,0x00,0x00,0x00
000010  040404            DCB      0x04,0x04,0x04
                  SHIFT_TAB_OCxx
000013  00                DCB      0x00
000014  00080000          DCB      0x00,0x08,0x00,0x00
000018  0008              DCB      0x00,0x08
                  SHIFT_TAB_ICxx
00001a  0000              DCB      0x00,0x00
00001c  08000000          DCB      0x08,0x00,0x00,0x00
000020  08                DCB      0x08
                  SHIFT_TAB_CCxP
000021  000204            DCB      0x00,0x02,0x04
000024  06080a0c          DCB      0x06,0x08,0x0a,0x0c
                  SHIFT_TAB_OISx
000028  00010203          DCB      0x00,0x01,0x02,0x03
00002c  040506            DCB      0x04,0x05,0x06

;*** Start embedded assembler ***

#line 1 "../Src/tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_tim_c_4ca9642c____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___5_tim_c_4ca9642c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_tim_c_4ca9642c____REVSH|
#line 402
|__asm___5_tim_c_4ca9642c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_tim_c_4ca9642c____RRX|
#line 587
|__asm___5_tim_c_4ca9642c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
