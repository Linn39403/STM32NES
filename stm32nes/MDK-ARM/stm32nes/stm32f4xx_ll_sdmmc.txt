; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_ll_sdmmc.o --depend=stm32nes\stm32f4xx_ll_sdmmc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_ll_sdmmc.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_sdmmc.c]
                          THUMB

                          AREA ||i.SDIO_ConfigData||, CODE, READONLY, ALIGN=1

                  SDIO_ConfigData PROC
;;;439      */
;;;440    HAL_StatusTypeDef SDIO_ConfigData(SDIO_TypeDef *SDIOx, SDIO_DataInitTypeDef* Data)
000000  b510              PUSH     {r4,lr}
;;;441    {
000002  4602              MOV      r2,r0
;;;442      uint32_t tmpreg = 0U;
000004  2300              MOVS     r3,#0
;;;443      
;;;444      /* Check the parameters */
;;;445      assert_param(IS_SDIO_DATA_LENGTH(Data->DataLength));
;;;446      assert_param(IS_SDIO_BLOCK_SIZE(Data->DataBlockSize));
;;;447      assert_param(IS_SDIO_TRANSFER_DIR(Data->TransferDir));
;;;448      assert_param(IS_SDIO_TRANSFER_MODE(Data->TransferMode));
;;;449      assert_param(IS_SDIO_DPSM(Data->DPSM));
;;;450    
;;;451      /* Set the SDMMC Data TimeOut value */
;;;452      SDIOx->DTIMER = Data->DataTimeOut;
000006  6808              LDR      r0,[r1,#0]
000008  6250              STR      r0,[r2,#0x24]
;;;453    
;;;454      /* Set the SDMMC DataLength value */
;;;455      SDIOx->DLEN = Data->DataLength;
00000a  6848              LDR      r0,[r1,#4]
00000c  6290              STR      r0,[r2,#0x28]
;;;456    
;;;457      /* Set the SDMMC data configuration parameters */
;;;458      tmpreg |= (uint32_t)(Data->DataBlockSize |\
00000e  e9d10402          LDRD     r0,r4,[r1,#8]
000012  4320              ORRS     r0,r0,r4
000014  690c              LDR      r4,[r1,#0x10]
000016  4320              ORRS     r0,r0,r4
000018  694c              LDR      r4,[r1,#0x14]
00001a  4320              ORRS     r0,r0,r4
00001c  4303              ORRS     r3,r3,r0
;;;459                           Data->TransferDir   |\
;;;460                           Data->TransferMode  |\
;;;461                           Data->DPSM);
;;;462      
;;;463      /* Write to SDMMC DCTRL */
;;;464      MODIFY_REG(SDIOx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
00001e  6ad0              LDR      r0,[r2,#0x2c]
000020  f02000f7          BIC      r0,r0,#0xf7
000024  4318              ORRS     r0,r0,r3
000026  62d0              STR      r0,[r2,#0x2c]
;;;465    
;;;466      return HAL_OK;
000028  2000              MOVS     r0,#0
;;;467    
;;;468    }
00002a  bd10              POP      {r4,pc}
;;;469    
                          ENDP


                          AREA ||i.SDIO_GetCommandResponse||, CODE, READONLY, ALIGN=1

                  SDIO_GetCommandResponse PROC
;;;401      */
;;;402    uint8_t SDIO_GetCommandResponse(SDIO_TypeDef *SDIOx)
000000  4601              MOV      r1,r0
;;;403    {
;;;404      return (uint8_t)(SDIOx->RESPCMD);
000002  6908              LDR      r0,[r1,#0x10]
000004  b2c0              UXTB     r0,r0
;;;405    }
000006  4770              BX       lr
;;;406    
                          ENDP


                          AREA ||i.SDIO_GetDataCounter||, CODE, READONLY, ALIGN=1

                  SDIO_GetDataCounter PROC
;;;474      */
;;;475    uint32_t SDIO_GetDataCounter(SDIO_TypeDef *SDIOx)
000000  4601              MOV      r1,r0
;;;476    {
;;;477      return (SDIOx->DCOUNT);
000002  6b08              LDR      r0,[r1,#0x30]
;;;478    }
000004  4770              BX       lr
;;;479    
                          ENDP


                          AREA ||i.SDIO_GetFIFOCount||, CODE, READONLY, ALIGN=1

                  SDIO_GetFIFOCount PROC
;;;484      */
;;;485    uint32_t SDIO_GetFIFOCount(SDIO_TypeDef *SDIOx)
000000  4601              MOV      r1,r0
;;;486    {
;;;487      return (SDIOx->FIFO);
000002  f8d10080          LDR      r0,[r1,#0x80]
;;;488    }
000006  4770              BX       lr
;;;489    
                          ENDP


                          AREA ||i.SDIO_GetPowerState||, CODE, READONLY, ALIGN=1

                  SDIO_GetPowerState PROC
;;;358      */
;;;359    uint32_t SDIO_GetPowerState(SDIO_TypeDef *SDIOx)  
000000  4601              MOV      r1,r0
;;;360    {
;;;361      return (SDIOx->POWER & SDIO_POWER_PWRCTRL);
000002  6808              LDR      r0,[r1,#0]
000004  f0000003          AND      r0,r0,#3
;;;362    }
000008  4770              BX       lr
;;;363    
                          ENDP


                          AREA ||i.SDIO_GetResponse||, CODE, READONLY, ALIGN=1

                  SDIO_GetResponse PROC
;;;418      */
;;;419    uint32_t SDIO_GetResponse(SDIO_TypeDef *SDIOx, uint32_t Response)
000000  b508              PUSH     {r3,lr}
;;;420    {
000002  4602              MOV      r2,r0
;;;421      __IO uint32_t tmp = 0U;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;422    
;;;423      /* Check the parameters */
;;;424      assert_param(IS_SDIO_RESP(Response));
;;;425      
;;;426      /* Get the response */
;;;427      tmp = (uint32_t)&(SDIOx->RESP1) + Response;
000008  f1020014          ADD      r0,r2,#0x14
00000c  4408              ADD      r0,r0,r1
00000e  9000              STR      r0,[sp,#0]
;;;428      
;;;429      return (*(__IO uint32_t *) tmp);
000010  9800              LDR      r0,[sp,#0]
000012  6800              LDR      r0,[r0,#0]
;;;430    }  
000014  bd08              POP      {r3,pc}
;;;431    
                          ENDP


                          AREA ||i.SDIO_Init||, CODE, READONLY, ALIGN=1

                  SDIO_Init PROC
;;;231      */
;;;232    HAL_StatusTypeDef SDIO_Init(SDIO_TypeDef *SDIOx, SDIO_InitTypeDef Init)
000000  b40f              PUSH     {r0-r3}
;;;233    {
000002  b510              PUSH     {r4,lr}
000004  4604              MOV      r4,r0
;;;234      uint32_t tmpreg = 0U;
000006  2100              MOVS     r1,#0
;;;235    
;;;236      /* Check the parameters */
;;;237      assert_param(IS_SDIO_ALL_INSTANCE(SDIOx));
;;;238      assert_param(IS_SDIO_CLOCK_EDGE(Init.ClockEdge)); 
;;;239      assert_param(IS_SDIO_CLOCK_BYPASS(Init.ClockBypass));
;;;240      assert_param(IS_SDIO_CLOCK_POWER_SAVE(Init.ClockPowerSave));
;;;241      assert_param(IS_SDIO_BUS_WIDE(Init.BusWide));
;;;242      assert_param(IS_SDIO_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
;;;243      assert_param(IS_SDIO_CLKDIV(Init.ClockDiv));
;;;244      
;;;245      /* Set SDMMC configuration parameters */
;;;246      tmpreg |= (Init.ClockEdge           |\
000008  e9dd0203          LDRD     r0,r2,[sp,#0xc]
00000c  4310              ORRS     r0,r0,r2
00000e  9a05              LDR      r2,[sp,#0x14]
000010  4310              ORRS     r0,r0,r2
000012  9a06              LDR      r2,[sp,#0x18]
000014  4310              ORRS     r0,r0,r2
000016  9a07              LDR      r2,[sp,#0x1c]
000018  4310              ORRS     r0,r0,r2
00001a  9a08              LDR      r2,[sp,#0x20]
00001c  4310              ORRS     r0,r0,r2
00001e  4301              ORRS     r1,r1,r0
;;;247                 Init.ClockBypass         |\
;;;248                 Init.ClockPowerSave      |\
;;;249                 Init.BusWide             |\
;;;250                 Init.HardwareFlowControl |\
;;;251                 Init.ClockDiv
;;;252                 ); 
;;;253      
;;;254      /* Write to SDMMC CLKCR */
;;;255      MODIFY_REG(SDIOx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
000020  6860              LDR      r0,[r4,#4]
000022  f64762ff          MOV      r2,#0x7eff
000026  4390              BICS     r0,r0,r2
000028  4308              ORRS     r0,r0,r1
00002a  6060              STR      r0,[r4,#4]
;;;256    
;;;257      return HAL_OK;
00002c  2000              MOVS     r0,#0
;;;258    }
00002e  bc10              POP      {r4}
000030  f85dfb14          LDR      pc,[sp],#0x14
;;;259    
                          ENDP


                          AREA ||i.SDIO_PowerState_OFF||, CODE, READONLY, ALIGN=1

                  SDIO_PowerState_OFF PROC
;;;341      */
;;;342    HAL_StatusTypeDef SDIO_PowerState_OFF(SDIO_TypeDef *SDIOx)
000000  4601              MOV      r1,r0
;;;343    {
;;;344      /* Set power state to OFF */
;;;345      SDIOx->POWER = 0x00000000U;
000002  2000              MOVS     r0,#0
000004  6008              STR      r0,[r1,#0]
;;;346      
;;;347      return HAL_OK;
;;;348    }
000006  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.SDIO_PowerState_ON||, CODE, READONLY, ALIGN=1

                  SDIO_PowerState_ON PROC
;;;328      */
;;;329    HAL_StatusTypeDef SDIO_PowerState_ON(SDIO_TypeDef *SDIOx)
000000  4601              MOV      r1,r0
;;;330    {  
;;;331      /* Set power state to ON */ 
;;;332      SDIOx->POWER = SDIO_POWER_PWRCTRL;
000002  2003              MOVS     r0,#3
000004  6008              STR      r0,[r1,#0]
;;;333      
;;;334      return HAL_OK;
000006  2000              MOVS     r0,#0
;;;335    }
000008  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.SDIO_ReadFIFO||, CODE, READONLY, ALIGN=1

                  SDIO_ReadFIFO PROC
;;;284      */
;;;285    uint32_t SDIO_ReadFIFO(SDIO_TypeDef *SDIOx)
000000  4601              MOV      r1,r0
;;;286    {
;;;287      /* Read data from Rx FIFO */ 
;;;288      return (SDIOx->FIFO);
000002  f8d10080          LDR      r0,[r1,#0x80]
;;;289    }
000006  4770              BX       lr
;;;290    
                          ENDP


                          AREA ||i.SDIO_SendCommand||, CODE, READONLY, ALIGN=1

                  SDIO_SendCommand PROC
;;;371      */
;;;372    HAL_StatusTypeDef SDIO_SendCommand(SDIO_TypeDef *SDIOx, SDIO_CmdInitTypeDef *Command)
000000  b510              PUSH     {r4,lr}
;;;373    {
000002  4602              MOV      r2,r0
;;;374      uint32_t tmpreg = 0U;
000004  2300              MOVS     r3,#0
;;;375      
;;;376      /* Check the parameters */
;;;377      assert_param(IS_SDIO_CMD_INDEX(Command->CmdIndex));
;;;378      assert_param(IS_SDIO_RESPONSE(Command->Response));
;;;379      assert_param(IS_SDIO_WAIT(Command->WaitForInterrupt));
;;;380      assert_param(IS_SDIO_CPSM(Command->CPSM));
;;;381    
;;;382      /* Set the SDMMC Argument value */
;;;383      SDIOx->ARG = Command->Argument;
000006  6808              LDR      r0,[r1,#0]
000008  6090              STR      r0,[r2,#8]
;;;384    
;;;385      /* Set SDMMC command parameters */
;;;386      tmpreg |= (uint32_t)(Command->CmdIndex         |\
00000a  e9d10401          LDRD     r0,r4,[r1,#4]
00000e  4320              ORRS     r0,r0,r4
000010  68cc              LDR      r4,[r1,#0xc]
000012  4320              ORRS     r0,r0,r4
000014  690c              LDR      r4,[r1,#0x10]
000016  4320              ORRS     r0,r0,r4
000018  4303              ORRS     r3,r3,r0
;;;387                           Command->Response         |\
;;;388                           Command->WaitForInterrupt |\
;;;389                           Command->CPSM);
;;;390      
;;;391      /* Write to SDMMC CMD register */
;;;392      MODIFY_REG(SDIOx->CMD, CMD_CLEAR_MASK, tmpreg); 
00001a  68d0              LDR      r0,[r2,#0xc]
00001c  f36f000b          BFC      r0,#0,#12
000020  4318              ORRS     r0,r0,r3
000022  60d0              STR      r0,[r2,#0xc]
;;;393      
;;;394      return HAL_OK;  
000024  2000              MOVS     r0,#0
;;;395    }
000026  bd10              POP      {r4,pc}
;;;396    
                          ENDP


                          AREA ||i.SDIO_SetSDMMCReadWaitMode||, CODE, READONLY, ALIGN=1

                  SDIO_SetSDMMCReadWaitMode PROC
;;;498      */
;;;499    HAL_StatusTypeDef SDIO_SetSDMMCReadWaitMode(SDIO_TypeDef *SDIOx, uint32_t SDIO_ReadWaitMode)
000000  4602              MOV      r2,r0
;;;500    {
;;;501      /* Check the parameters */
;;;502      assert_param(IS_SDIO_READWAIT_MODE(SDIO_ReadWaitMode));
;;;503    
;;;504      /* Set SDMMC read wait mode */
;;;505      MODIFY_REG(SDIOx->DCTRL, SDIO_DCTRL_RWMOD, SDIO_ReadWaitMode);
000002  6ad0              LDR      r0,[r2,#0x2c]
000004  f4206080          BIC      r0,r0,#0x400
000008  4308              ORRS     r0,r0,r1
00000a  62d0              STR      r0,[r2,#0x2c]
;;;506      
;;;507      return HAL_OK;  
00000c  2000              MOVS     r0,#0
;;;508    }
00000e  4770              BX       lr
;;;509    
                          ENDP


                          AREA ||i.SDIO_WriteFIFO||, CODE, READONLY, ALIGN=1

                  SDIO_WriteFIFO PROC
;;;296      */
;;;297    HAL_StatusTypeDef SDIO_WriteFIFO(SDIO_TypeDef *SDIOx, uint32_t *pWriteData)
000000  4602              MOV      r2,r0
;;;298    { 
;;;299      /* Write data to FIFO */ 
;;;300      SDIOx->FIFO = *pWriteData;
000002  6808              LDR      r0,[r1,#0]
000004  f8c20080          STR      r0,[r2,#0x80]
;;;301    
;;;302      return HAL_OK;
000008  2000              MOVS     r0,#0
;;;303    }
00000a  4770              BX       lr
;;;304    
                          ENDP


                          AREA ||i.SDMMC_CmdAppCommand||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdAppCommand PROC
;;;875      */
;;;876    uint32_t SDMMC_CmdAppCommand(SDIO_TypeDef *SDIOx, uint32_t Argument)
000000  b570              PUSH     {r4-r6,lr}
;;;877    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;878      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;879      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;880      
;;;881      sdmmc_cmdinit.Argument         = (uint32_t)Argument;
00000a  9401              STR      r4,[sp,#4]
;;;882      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
00000c  2037              MOVS     r0,#0x37
00000e  9002              STR      r0,[sp,#8]
;;;883      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;884      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;885      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;886      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;887      
;;;888      /* Check for error conditions */
;;;889      /* If there is a HAL_ERROR, it is a MMC card, else
;;;890      it is a SD card: SD card 2.0 (voltage range mismatch)
;;;891         or SD card 1.x */
;;;892      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_APP_CMD, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2137              MOVS     r1,#0x37
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;893    
;;;894      return errorstate;
000034  4630              MOV      r0,r6
;;;895    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;896    
                          ENDP


                          AREA ||i.SDMMC_CmdAppOperCommand||, CODE, READONLY, ALIGN=2

                  SDMMC_CmdAppOperCommand PROC
;;;902      */
;;;903    uint32_t SDMMC_CmdAppOperCommand(SDIO_TypeDef *SDIOx, uint32_t SdType)
000000  b570              PUSH     {r4-r6,lr}
;;;904    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;905      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;906      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;907      
;;;908      sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | SdType;
00000a  480b              LDR      r0,|L15.56|
00000c  4320              ORRS     r0,r0,r4
00000e  9001              STR      r0,[sp,#4]
;;;909      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
000010  2029              MOVS     r0,#0x29
000012  9002              STR      r0,[sp,#8]
;;;910      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000014  2040              MOVS     r0,#0x40
000016  9003              STR      r0,[sp,#0xc]
;;;911      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000018  2000              MOVS     r0,#0
00001a  9004              STR      r0,[sp,#0x10]
;;;912      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
00001c  f44f6080          MOV      r0,#0x400
000020  9005              STR      r0,[sp,#0x14]
;;;913      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
000022  a901              ADD      r1,sp,#4
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       SDIO_SendCommand
;;;914      
;;;915      /* Check for error conditions */
;;;916      errorstate = SDMMC_GetCmdResp3(SDIOx);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       SDMMC_GetCmdResp3
000030  4606              MOV      r6,r0
;;;917    
;;;918      return errorstate;
000032  4630              MOV      r0,r6
;;;919    }
000034  b006              ADD      sp,sp,#0x18
000036  bd70              POP      {r4-r6,pc}
;;;920    
                          ENDP

                  |L15.56|
                          DCD      0x80100000

                          AREA ||i.SDMMC_CmdBlockLength||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdBlockLength PROC
;;;533      */
;;;534    uint32_t SDMMC_CmdBlockLength(SDIO_TypeDef *SDIOx, uint32_t BlockSize)
000000  b570              PUSH     {r4-r6,lr}
;;;535    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;536      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;537      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;538      
;;;539      /* Set Block Size for Card */ 
;;;540      sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
00000a  9401              STR      r4,[sp,#4]
;;;541      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
00000c  2010              MOVS     r0,#0x10
00000e  9002              STR      r0,[sp,#8]
;;;542      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;543      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;544      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;545      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;546      
;;;547      /* Check for error conditions */
;;;548      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SET_BLOCKLEN, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2110              MOVS     r1,#0x10
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;549    
;;;550      return errorstate;
000034  4630              MOV      r0,r6
;;;551    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;552    
                          ENDP


                          AREA ||i.SDMMC_CmdBusWidth||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdBusWidth PROC
;;;925      */
;;;926    uint32_t SDMMC_CmdBusWidth(SDIO_TypeDef *SDIOx, uint32_t BusWidth)
000000  b570              PUSH     {r4-r6,lr}
;;;927    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;928      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;929      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;930      
;;;931      sdmmc_cmdinit.Argument         = (uint32_t)BusWidth;
00000a  9401              STR      r4,[sp,#4]
;;;932      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_SD_SET_BUSWIDTH;
00000c  2006              MOVS     r0,#6
00000e  9002              STR      r0,[sp,#8]
;;;933      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;934      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;935      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;936      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;937      
;;;938      /* Check for error conditions */
;;;939      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2106              MOVS     r1,#6
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;940    
;;;941      return errorstate;
000034  4630              MOV      r0,r6
;;;942    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;943    
                          ENDP


                          AREA ||i.SDMMC_CmdErase||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdErase PROC
;;;749      */
;;;750    uint32_t SDMMC_CmdErase(SDIO_TypeDef *SDIOx)
000000  b530              PUSH     {r4,r5,lr}
;;;751    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;752      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;753      uint32_t errorstate = SDMMC_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;754      
;;;755      /* Set Block Size for Card */ 
;;;756      sdmmc_cmdinit.Argument         = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;757      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE;
00000c  2026              MOVS     r0,#0x26
00000e  9001              STR      r0,[sp,#4]
;;;758      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9002              STR      r0,[sp,#8]
;;;759      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9003              STR      r0,[sp,#0xc]
;;;760      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9004              STR      r0,[sp,#0x10]
;;;761      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SDIO_SendCommand
;;;762      
;;;763      /* Check for error conditions */
;;;764      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_ERASE, SDIO_MAXERASETIMEOUT);
000026  f24f6218          MOV      r2,#0xf618
00002a  2126              MOVS     r1,#0x26
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4605              MOV      r5,r0
;;;765    
;;;766      return errorstate;
000034  4628              MOV      r0,r5
;;;767    }
000036  b005              ADD      sp,sp,#0x14
000038  bd30              POP      {r4,r5,pc}
;;;768    
                          ENDP


                          AREA ||i.SDMMC_CmdEraseEndAdd||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdEraseEndAdd PROC
;;;725      */
;;;726    uint32_t SDMMC_CmdEraseEndAdd(SDIO_TypeDef *SDIOx, uint32_t EndAdd)
000000  b570              PUSH     {r4-r6,lr}
;;;727    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;728      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;729      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;730      
;;;731      /* Set Block Size for Card */ 
;;;732      sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
00000a  9401              STR      r4,[sp,#4]
;;;733      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_END;
00000c  2024              MOVS     r0,#0x24
00000e  9002              STR      r0,[sp,#8]
;;;734      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;735      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;736      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;737      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;738      
;;;739      /* Check for error conditions */
;;;740      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_ERASE_GRP_END, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2124              MOVS     r1,#0x24
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;741    
;;;742      return errorstate;
000034  4630              MOV      r0,r6
;;;743    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;744    
                          ENDP


                          AREA ||i.SDMMC_CmdEraseStartAdd||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdEraseStartAdd PROC
;;;701      */
;;;702    uint32_t SDMMC_CmdEraseStartAdd(SDIO_TypeDef *SDIOx, uint32_t StartAdd)
000000  b570              PUSH     {r4-r6,lr}
;;;703    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;704      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;705      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;706      
;;;707      /* Set Block Size for Card */ 
;;;708      sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
00000a  9401              STR      r4,[sp,#4]
;;;709      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ERASE_GRP_START;
00000c  2023              MOVS     r0,#0x23
00000e  9002              STR      r0,[sp,#8]
;;;710      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;711      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;712      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;713      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;714      
;;;715      /* Check for error conditions */
;;;716      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_ERASE_GRP_START, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2123              MOVS     r1,#0x23
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;717    
;;;718      return errorstate;
000034  4630              MOV      r0,r6
;;;719    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;720    
                          ENDP


                          AREA ||i.SDMMC_CmdGoIdleState||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdGoIdleState PROC
;;;822      */
;;;823    uint32_t SDMMC_CmdGoIdleState(SDIO_TypeDef *SDIOx)
000000  b530              PUSH     {r4,r5,lr}
;;;824    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;825      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;826      uint32_t errorstate = SDMMC_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;827      
;;;828      sdmmc_cmdinit.Argument         = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;829      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
00000c  9001              STR      r0,[sp,#4]
;;;830      sdmmc_cmdinit.Response         = SDIO_RESPONSE_NO;
00000e  9002              STR      r0,[sp,#8]
;;;831      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000010  9003              STR      r0,[sp,#0xc]
;;;832      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000012  f44f6080          MOV      r0,#0x400
000016  9004              STR      r0,[sp,#0x10]
;;;833      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
000018  4669              MOV      r1,sp
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SDIO_SendCommand
;;;834      
;;;835      /* Check for error conditions */
;;;836      errorstate = SDMMC_GetCmdError(SDIOx);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SDMMC_GetCmdError
000026  4605              MOV      r5,r0
;;;837    
;;;838      return errorstate;
000028  4628              MOV      r0,r5
;;;839    }
00002a  b005              ADD      sp,sp,#0x14
00002c  bd30              POP      {r4,r5,pc}
;;;840    
                          ENDP


                          AREA ||i.SDMMC_CmdOpCondition||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdOpCondition PROC
;;;1092     */
;;;1093   uint32_t SDMMC_CmdOpCondition(SDIO_TypeDef *SDIOx, uint32_t Argument)
000000  b570              PUSH     {r4-r6,lr}
;;;1094   {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1095     SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1096     uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;1097     
;;;1098     sdmmc_cmdinit.Argument         = Argument;
00000a  9401              STR      r4,[sp,#4]
;;;1099     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_OP_COND;
00000c  2001              MOVS     r0,#1
00000e  9002              STR      r0,[sp,#8]
;;;1100     sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;1101     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;1102     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;1103     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;1104     
;;;1105     /* Check for error conditions */
;;;1106     errorstate = SDMMC_GetCmdResp3(SDIOx);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       SDMMC_GetCmdResp3
00002c  4606              MOV      r6,r0
;;;1107   
;;;1108     return errorstate;
00002e  4630              MOV      r0,r6
;;;1109   }
000030  b006              ADD      sp,sp,#0x18
000032  bd70              POP      {r4-r6,pc}
;;;1110   
                          ENDP


                          AREA ||i.SDMMC_CmdOperCond||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdOperCond PROC
;;;845      */
;;;846    uint32_t SDMMC_CmdOperCond(SDIO_TypeDef *SDIOx)
000000  b530              PUSH     {r4,r5,lr}
;;;847    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;848      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;849      uint32_t errorstate = SDMMC_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;850      
;;;851      /* Send CMD8 to verify SD card interface operating condition */
;;;852      /* Argument: - [31:12]: Reserved (shall be set to '0')
;;;853      - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
;;;854      - [7:0]: Check Pattern (recommended 0xAA) */
;;;855      /* CMD Response: R7 */
;;;856      sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
000008  f44f70d5          MOV      r0,#0x1aa
00000c  9000              STR      r0,[sp,#0]
;;;857      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
00000e  2008              MOVS     r0,#8
000010  9001              STR      r0,[sp,#4]
;;;858      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000012  2040              MOVS     r0,#0x40
000014  9002              STR      r0,[sp,#8]
;;;859      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000016  2000              MOVS     r0,#0
000018  9003              STR      r0,[sp,#0xc]
;;;860      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
00001a  f44f6080          MOV      r0,#0x400
00001e  9004              STR      r0,[sp,#0x10]
;;;861      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
000020  4669              MOV      r1,sp
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       SDIO_SendCommand
;;;862      
;;;863      /* Check for error conditions */
;;;864      errorstate = SDMMC_GetCmdResp7(SDIOx);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       SDMMC_GetCmdResp7
00002e  4605              MOV      r5,r0
;;;865    
;;;866      return errorstate;
000030  4628              MOV      r0,r5
;;;867    }
000032  b005              ADD      sp,sp,#0x14
000034  bd30              POP      {r4,r5,pc}
;;;868    
                          ENDP


                          AREA ||i.SDMMC_CmdReadMultiBlock||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdReadMultiBlock PROC
;;;581      */
;;;582    uint32_t SDMMC_CmdReadMultiBlock(SDIO_TypeDef *SDIOx, uint32_t ReadAdd)
000000  b570              PUSH     {r4-r6,lr}
;;;583    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;584      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;585      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;586      
;;;587      /* Set Block Size for Card */ 
;;;588      sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
00000a  9401              STR      r4,[sp,#4]
;;;589      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
00000c  2012              MOVS     r0,#0x12
00000e  9002              STR      r0,[sp,#8]
;;;590      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;591      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;592      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;593      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;594      
;;;595      /* Check for error conditions */
;;;596      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_READ_MULT_BLOCK, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2112              MOVS     r1,#0x12
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;597    
;;;598      return errorstate;
000034  4630              MOV      r0,r6
;;;599    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;600    
                          ENDP


                          AREA ||i.SDMMC_CmdReadSingleBlock||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdReadSingleBlock PROC
;;;557      */
;;;558    uint32_t SDMMC_CmdReadSingleBlock(SDIO_TypeDef *SDIOx, uint32_t ReadAdd)
000000  b570              PUSH     {r4-r6,lr}
;;;559    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;560      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;561      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;562      
;;;563      /* Set Block Size for Card */ 
;;;564      sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
00000a  9401              STR      r4,[sp,#4]
;;;565      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
00000c  2011              MOVS     r0,#0x11
00000e  9002              STR      r0,[sp,#8]
;;;566      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;567      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;568      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;569      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;570      
;;;571      /* Check for error conditions */
;;;572      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_READ_SINGLE_BLOCK, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2111              MOVS     r1,#0x11
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;573    
;;;574      return errorstate;
000034  4630              MOV      r0,r6
;;;575    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;576    
                          ENDP


                          AREA ||i.SDMMC_CmdSDEraseEndAdd||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSDEraseEndAdd PROC
;;;677      */
;;;678    uint32_t SDMMC_CmdSDEraseEndAdd(SDIO_TypeDef *SDIOx, uint32_t EndAdd)
000000  b570              PUSH     {r4-r6,lr}
;;;679    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;680      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;681      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;682      
;;;683      /* Set Block Size for Card */ 
;;;684      sdmmc_cmdinit.Argument         = (uint32_t)EndAdd;
00000a  9401              STR      r4,[sp,#4]
;;;685      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_END;
00000c  2021              MOVS     r0,#0x21
00000e  9002              STR      r0,[sp,#8]
;;;686      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;687      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;688      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;689      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;690      
;;;691      /* Check for error conditions */
;;;692      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_ERASE_GRP_END, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2121              MOVS     r1,#0x21
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;693    
;;;694      return errorstate;
000034  4630              MOV      r0,r6
;;;695    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;696    
                          ENDP


                          AREA ||i.SDMMC_CmdSDEraseStartAdd||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSDEraseStartAdd PROC
;;;653      */
;;;654    uint32_t SDMMC_CmdSDEraseStartAdd(SDIO_TypeDef *SDIOx, uint32_t StartAdd)
000000  b570              PUSH     {r4-r6,lr}
;;;655    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;656      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;657      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;658      
;;;659      /* Set Block Size for Card */ 
;;;660      sdmmc_cmdinit.Argument         = (uint32_t)StartAdd;
00000a  9401              STR      r4,[sp,#4]
;;;661      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_ERASE_GRP_START;
00000c  2020              MOVS     r0,#0x20
00000e  9002              STR      r0,[sp,#8]
;;;662      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;663      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;664      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;665      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;666      
;;;667      /* Check for error conditions */
;;;668      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_ERASE_GRP_START, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2120              MOVS     r1,#0x20
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;669    
;;;670      return errorstate;
000034  4630              MOV      r0,r6
;;;671    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;672    
                          ENDP


                          AREA ||i.SDMMC_CmdSelDesel||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSelDesel PROC
;;;798      */
;;;799    uint32_t SDMMC_CmdSelDesel(SDIO_TypeDef *SDIOx, uint64_t Addr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;800    {
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
000006  4614              MOV      r4,r2
000008  461d              MOV      r5,r3
;;;801      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;802      uint32_t errorstate = SDMMC_ERROR_NONE;
00000a  2700              MOVS     r7,#0
;;;803      
;;;804      /* Send CMD7 SDMMC_SEL_DESEL_CARD */
;;;805      sdmmc_cmdinit.Argument         = (uint32_t)Addr;
00000c  9400              STR      r4,[sp,#0]
;;;806      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
00000e  2007              MOVS     r0,#7
000010  9001              STR      r0,[sp,#4]
;;;807      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000012  2040              MOVS     r0,#0x40
000014  9002              STR      r0,[sp,#8]
;;;808      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000016  2000              MOVS     r0,#0
000018  9003              STR      r0,[sp,#0xc]
;;;809      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
00001a  f44f6080          MOV      r0,#0x400
00001e  9004              STR      r0,[sp,#0x10]
;;;810      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
000020  4669              MOV      r1,sp
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       SDIO_SendCommand
;;;811      
;;;812      /* Check for error conditions */
;;;813      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SEL_DESEL_CARD, SDIO_CMDTIMEOUT);
000028  f2413288          MOV      r2,#0x1388
00002c  2107              MOVS     r1,#7
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       SDMMC_GetCmdResp1
000034  4607              MOV      r7,r0
;;;814    
;;;815      return errorstate;
000036  4638              MOV      r0,r7
;;;816    }
000038  b005              ADD      sp,sp,#0x14
00003a  bdf0              POP      {r4-r7,pc}
;;;817    
                          ENDP


                          AREA ||i.SDMMC_CmdSendCID||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSendCID PROC
;;;972      */
;;;973    uint32_t SDMMC_CmdSendCID(SDIO_TypeDef *SDIOx)
000000  b530              PUSH     {r4,r5,lr}
;;;974    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;975      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;976      uint32_t errorstate = SDMMC_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;977      
;;;978      /* Send CMD2 ALL_SEND_CID */
;;;979      sdmmc_cmdinit.Argument         = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;980      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
00000c  2002              MOVS     r0,#2
00000e  9001              STR      r0,[sp,#4]
;;;981      sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
000010  20c0              MOVS     r0,#0xc0
000012  9002              STR      r0,[sp,#8]
;;;982      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9003              STR      r0,[sp,#0xc]
;;;983      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9004              STR      r0,[sp,#0x10]
;;;984      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SDIO_SendCommand
;;;985      
;;;986      /* Check for error conditions */
;;;987      errorstate = SDMMC_GetCmdResp2(SDIOx);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       SDMMC_GetCmdResp2
00002c  4605              MOV      r5,r0
;;;988    
;;;989      return errorstate;
00002e  4628              MOV      r0,r5
;;;990    }
000030  b005              ADD      sp,sp,#0x14
000032  bd30              POP      {r4,r5,pc}
;;;991    
                          ENDP


                          AREA ||i.SDMMC_CmdSendCSD||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSendCSD PROC
;;;996      */
;;;997    uint32_t SDMMC_CmdSendCSD(SDIO_TypeDef *SDIOx, uint32_t Argument)
000000  b570              PUSH     {r4-r6,lr}
;;;998    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;999      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1000     uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;1001     
;;;1002     /* Send CMD9 SEND_CSD */
;;;1003     sdmmc_cmdinit.Argument         = (uint32_t)Argument;
00000a  9401              STR      r4,[sp,#4]
;;;1004     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
00000c  2009              MOVS     r0,#9
00000e  9002              STR      r0,[sp,#8]
;;;1005     sdmmc_cmdinit.Response         = SDIO_RESPONSE_LONG;
000010  20c0              MOVS     r0,#0xc0
000012  9003              STR      r0,[sp,#0xc]
;;;1006     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;1007     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;1008     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;1009     
;;;1010     /* Check for error conditions */
;;;1011     errorstate = SDMMC_GetCmdResp2(SDIOx);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       SDMMC_GetCmdResp2
00002c  4606              MOV      r6,r0
;;;1012   
;;;1013     return errorstate;
00002e  4630              MOV      r0,r6
;;;1014   }
000030  b006              ADD      sp,sp,#0x18
000032  bd70              POP      {r4-r6,pc}
;;;1015   
                          ENDP


                          AREA ||i.SDMMC_CmdSendSCR||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSendSCR PROC
;;;948      */
;;;949    uint32_t SDMMC_CmdSendSCR(SDIO_TypeDef *SDIOx)
000000  b530              PUSH     {r4,r5,lr}
;;;950    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;951      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;952      uint32_t errorstate = SDMMC_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;953      
;;;954      /* Send CMD51 SD_APP_SEND_SCR */
;;;955      sdmmc_cmdinit.Argument         = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;956      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
00000c  2033              MOVS     r0,#0x33
00000e  9001              STR      r0,[sp,#4]
;;;957      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9002              STR      r0,[sp,#8]
;;;958      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9003              STR      r0,[sp,#0xc]
;;;959      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9004              STR      r0,[sp,#0x10]
;;;960      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SDIO_SendCommand
;;;961      
;;;962      /* Check for error conditions */
;;;963      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_APP_SEND_SCR, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2133              MOVS     r1,#0x33
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4605              MOV      r5,r0
;;;964    
;;;965      return errorstate;
000034  4628              MOV      r0,r5
;;;966    }
000036  b005              ADD      sp,sp,#0x14
000038  bd30              POP      {r4,r5,pc}
;;;967    
                          ENDP


                          AREA ||i.SDMMC_CmdSendStatus||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSendStatus PROC
;;;1044     */
;;;1045   uint32_t SDMMC_CmdSendStatus(SDIO_TypeDef *SDIOx, uint32_t Argument)
000000  b570              PUSH     {r4-r6,lr}
;;;1046   {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1047     SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1048     uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;1049     
;;;1050     sdmmc_cmdinit.Argument         = (uint32_t)Argument;
00000a  9401              STR      r4,[sp,#4]
;;;1051     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
00000c  200d              MOVS     r0,#0xd
00000e  9002              STR      r0,[sp,#8]
;;;1052     sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;1053     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;1054     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;1055     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;1056     
;;;1057     /* Check for error conditions */
;;;1058     errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SEND_STATUS, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  210d              MOVS     r1,#0xd
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;1059   
;;;1060     return errorstate;
000034  4630              MOV      r0,r6
;;;1061   }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;1062   
                          ENDP


                          AREA ||i.SDMMC_CmdSetRelAdd||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSetRelAdd PROC
;;;1020     */
;;;1021   uint32_t SDMMC_CmdSetRelAdd(SDIO_TypeDef *SDIOx, uint16_t *pRCA)
000000  b570              PUSH     {r4-r6,lr}
;;;1022   {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1023     SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1024     uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;1025     
;;;1026     /* Send CMD3 SD_CMD_SET_REL_ADDR */
;;;1027     sdmmc_cmdinit.Argument         = 0U;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;1028     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
00000e  2003              MOVS     r0,#3
000010  9002              STR      r0,[sp,#8]
;;;1029     sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000012  2040              MOVS     r0,#0x40
000014  9003              STR      r0,[sp,#0xc]
;;;1030     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000016  2000              MOVS     r0,#0
000018  9004              STR      r0,[sp,#0x10]
;;;1031     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
00001a  f44f6080          MOV      r0,#0x400
00001e  9005              STR      r0,[sp,#0x14]
;;;1032     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
000020  a901              ADD      r1,sp,#4
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       SDIO_SendCommand
;;;1033     
;;;1034     /* Check for error conditions */
;;;1035     errorstate = SDMMC_GetCmdResp6(SDIOx, SDMMC_CMD_SET_REL_ADDR, pRCA);
000028  4622              MOV      r2,r4
00002a  2103              MOVS     r1,#3
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp6
000032  4606              MOV      r6,r0
;;;1036   
;;;1037     return errorstate;
000034  4630              MOV      r0,r6
;;;1038   }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;1039   
                          ENDP


                          AREA ||i.SDMMC_CmdStatusRegister||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdStatusRegister PROC
;;;1067     */
;;;1068   uint32_t SDMMC_CmdStatusRegister(SDIO_TypeDef *SDIOx)
000000  b530              PUSH     {r4,r5,lr}
;;;1069   {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;1070     SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1071     uint32_t errorstate = SDMMC_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;1072     
;;;1073     sdmmc_cmdinit.Argument         = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;1074     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_STATUS;
00000c  200d              MOVS     r0,#0xd
00000e  9001              STR      r0,[sp,#4]
;;;1075     sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9002              STR      r0,[sp,#8]
;;;1076     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9003              STR      r0,[sp,#0xc]
;;;1077     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9004              STR      r0,[sp,#0x10]
;;;1078     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SDIO_SendCommand
;;;1079     
;;;1080     /* Check for error conditions */
;;;1081     errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_SD_APP_STATUS, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  210d              MOVS     r1,#0xd
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4605              MOV      r5,r0
;;;1082   
;;;1083     return errorstate;
000034  4628              MOV      r0,r5
;;;1084   }
000036  b005              ADD      sp,sp,#0x14
000038  bd30              POP      {r4,r5,pc}
;;;1085   
                          ENDP


                          AREA ||i.SDMMC_CmdStopTransfer||, CODE, READONLY, ALIGN=2

                  SDMMC_CmdStopTransfer PROC
;;;773      */
;;;774    uint32_t SDMMC_CmdStopTransfer(SDIO_TypeDef *SDIOx)
000000  b530              PUSH     {r4,r5,lr}
;;;775    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;776      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;777      uint32_t errorstate = SDMMC_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;778      
;;;779      /* Send CMD12 STOP_TRANSMISSION  */
;;;780      sdmmc_cmdinit.Argument         = 0U;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;781      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
00000c  200c              MOVS     r0,#0xc
00000e  9001              STR      r0,[sp,#4]
;;;782      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9002              STR      r0,[sp,#8]
;;;783      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9003              STR      r0,[sp,#0xc]
;;;784      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9004              STR      r0,[sp,#0x10]
;;;785      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       SDIO_SendCommand
;;;786      
;;;787      /* Check for error conditions */
;;;788      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_STOP_TRANSMISSION, 100000000U);
000026  4a04              LDR      r2,|L35.56|
000028  210c              MOVS     r1,#0xc
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SDMMC_GetCmdResp1
000030  4605              MOV      r5,r0
;;;789    
;;;790      return errorstate;
000032  4628              MOV      r0,r5
;;;791    }
000034  b005              ADD      sp,sp,#0x14
000036  bd30              POP      {r4,r5,pc}
;;;792    
                          ENDP

                  |L35.56|
                          DCD      0x05f5e100

                          AREA ||i.SDMMC_CmdSwitch||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdSwitch PROC
;;;1116     */
;;;1117   uint32_t SDMMC_CmdSwitch(SDIO_TypeDef *SDIOx, uint32_t Argument)
000000  b570              PUSH     {r4-r6,lr}
;;;1118   {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1119     SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;1120     uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;1121     
;;;1122     sdmmc_cmdinit.Argument         = Argument;
00000a  9401              STR      r4,[sp,#4]
;;;1123     sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SWITCH;
00000c  2006              MOVS     r0,#6
00000e  9002              STR      r0,[sp,#8]
;;;1124     sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;1125     sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;1126     sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;1127     SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;1128     
;;;1129     /* Check for error conditions */
;;;1130     errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_HS_SWITCH, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2106              MOVS     r1,#6
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;1131   
;;;1132     return errorstate;
000034  4630              MOV      r0,r6
;;;1133   }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;1134   
                          ENDP


                          AREA ||i.SDMMC_CmdWriteMultiBlock||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdWriteMultiBlock PROC
;;;629      */
;;;630    uint32_t SDMMC_CmdWriteMultiBlock(SDIO_TypeDef *SDIOx, uint32_t WriteAdd)
000000  b570              PUSH     {r4-r6,lr}
;;;631    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;632      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;633      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;634      
;;;635      /* Set Block Size for Card */ 
;;;636      sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
00000a  9401              STR      r4,[sp,#4]
;;;637      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
00000c  2019              MOVS     r0,#0x19
00000e  9002              STR      r0,[sp,#8]
;;;638      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;639      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;640      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;641      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;642      
;;;643      /* Check for error conditions */
;;;644      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_WRITE_MULT_BLOCK, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2119              MOVS     r1,#0x19
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;645    
;;;646      return errorstate;
000034  4630              MOV      r0,r6
;;;647    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;648    
                          ENDP


                          AREA ||i.SDMMC_CmdWriteSingleBlock||, CODE, READONLY, ALIGN=1

                  SDMMC_CmdWriteSingleBlock PROC
;;;605      */
;;;606    uint32_t SDMMC_CmdWriteSingleBlock(SDIO_TypeDef *SDIOx, uint32_t WriteAdd)
000000  b570              PUSH     {r4-r6,lr}
;;;607    {
000002  b086              SUB      sp,sp,#0x18
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;608      SDIO_CmdInitTypeDef  sdmmc_cmdinit;
;;;609      uint32_t errorstate = SDMMC_ERROR_NONE;
000008  2600              MOVS     r6,#0
;;;610      
;;;611      /* Set Block Size for Card */ 
;;;612      sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
00000a  9401              STR      r4,[sp,#4]
;;;613      sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
00000c  2018              MOVS     r0,#0x18
00000e  9002              STR      r0,[sp,#8]
;;;614      sdmmc_cmdinit.Response         = SDIO_RESPONSE_SHORT;
000010  2040              MOVS     r0,#0x40
000012  9003              STR      r0,[sp,#0xc]
;;;615      sdmmc_cmdinit.WaitForInterrupt = SDIO_WAIT_NO;
000014  2000              MOVS     r0,#0
000016  9004              STR      r0,[sp,#0x10]
;;;616      sdmmc_cmdinit.CPSM             = SDIO_CPSM_ENABLE;
000018  f44f6080          MOV      r0,#0x400
00001c  9005              STR      r0,[sp,#0x14]
;;;617      SDIO_SendCommand(SDIOx, &sdmmc_cmdinit);
00001e  a901              ADD      r1,sp,#4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       SDIO_SendCommand
;;;618      
;;;619      /* Check for error conditions */
;;;620      errorstate = SDMMC_GetCmdResp1(SDIOx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDIO_CMDTIMEOUT);
000026  f2413288          MOV      r2,#0x1388
00002a  2118              MOVS     r1,#0x18
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       SDMMC_GetCmdResp1
000032  4606              MOV      r6,r0
;;;621    
;;;622      return errorstate;
000034  4630              MOV      r0,r6
;;;623    }
000036  b006              ADD      sp,sp,#0x18
000038  bd70              POP      {r4-r6,pc}
;;;624    
                          ENDP


                          AREA ||i.SDMMC_GetCmdError||, CODE, READONLY, ALIGN=2

                  SDMMC_GetCmdError PROC
;;;1148     */
;;;1149   static uint32_t SDMMC_GetCmdError(SDIO_TypeDef *SDIOx)
000000  4601              MOV      r1,r0
;;;1150   {
;;;1151     /* 8 is the number of required instructions cycles for the below loop statement.
;;;1152     The SDMMC_CMDTIMEOUT is expressed in ms */
;;;1153     register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
000002  480e              LDR      r0,|L39.60|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  08c0              LSRS     r0,r0,#3
000008  f44f737a          MOV      r3,#0x3e8
00000c  fbb0f0f3          UDIV     r0,r0,r3
000010  f2413388          MOV      r3,#0x1388
000014  fb00f203          MUL      r2,r0,r3
;;;1154     
;;;1155     do
000018  bf00              NOP      
                  |L39.26|
;;;1156     {
;;;1157       if (count-- == 0U)
00001a  1e10              SUBS     r0,r2,#0
00001c  f1a20201          SUB      r2,r2,#1
000020  d102              BNE      |L39.40|
;;;1158       {
;;;1159         return SDMMC_ERROR_TIMEOUT;
000022  f04f4000          MOV      r0,#0x80000000
                  |L39.38|
;;;1160       }
;;;1161       
;;;1162     }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CMDSENT));
;;;1163     
;;;1164     /* Clear all the static flags */
;;;1165     __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
;;;1166     
;;;1167     return SDMMC_ERROR_NONE;
;;;1168   }
000026  4770              BX       lr
                  |L39.40|
000028  6b48              LDR      r0,[r1,#0x34]         ;1162
00002a  f0000080          AND      r0,r0,#0x80           ;1162
00002e  2800              CMP      r0,#0                 ;1162
000030  d0f3              BEQ      |L39.26|
000032  f24050ff          MOV      r0,#0x5ff             ;1165
000036  6388              STR      r0,[r1,#0x38]         ;1165
000038  2000              MOVS     r0,#0                 ;1167
00003a  e7f4              B        |L39.38|
;;;1169   
                          ENDP

                  |L39.60|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_GetCmdResp1||, CODE, READONLY, ALIGN=2

                  SDMMC_GetCmdResp1 PROC
;;;1175     */
;;;1176   static uint32_t SDMMC_GetCmdResp1(SDIO_TypeDef *SDIOx, uint8_t SD_CMD, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1177   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1178     uint32_t response_r1;
;;;1179     
;;;1180     /* 8 is the number of required instructions cycles for the below loop statement.
;;;1181     The Timeout is expressed in ms */
;;;1182     register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
00000a  4864              LDR      r0,|L40.412|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  08c0              LSRS     r0,r0,#3
000010  f44f717a          MOV      r1,#0x3e8
000014  fbb0f0f1          UDIV     r0,r0,r1
000018  fb00f807          MUL      r8,r0,r7
;;;1183     
;;;1184     do
00001c  bf00              NOP      
                  |L40.30|
;;;1185     {
;;;1186       if (count-- == 0U)
00001e  f1b80000          SUBS     r0,r8,#0
000022  f1a80801          SUB      r8,r8,#1
000026  d103              BNE      |L40.48|
;;;1187       {
;;;1188         return SDMMC_ERROR_TIMEOUT;
000028  f04f4000          MOV      r0,#0x80000000
                  |L40.44|
;;;1189       }
;;;1190       
;;;1191     }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
;;;1192     
;;;1193     if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
;;;1194     {
;;;1195       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
;;;1196       
;;;1197       return SDMMC_ERROR_CMD_RSP_TIMEOUT;
;;;1198     }
;;;1199     else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
;;;1200     {
;;;1201       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
;;;1202       
;;;1203       return SDMMC_ERROR_CMD_CRC_FAIL;
;;;1204     }
;;;1205     
;;;1206     /* Check response received is of desired command */
;;;1207     if(SDIO_GetCommandResponse(SDIOx) != SD_CMD)
;;;1208     {
;;;1209       return SDMMC_ERROR_CMD_CRC_FAIL;
;;;1210     }
;;;1211     
;;;1212     /* Clear all the static flags */
;;;1213     __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
;;;1214     
;;;1215     /* We have received response, retrieve it for analysis  */
;;;1216     response_r1 = SDIO_GetResponse(SDIOx, SDIO_RESP1);
;;;1217     
;;;1218     if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
;;;1219     {
;;;1220       return SDMMC_ERROR_NONE;
;;;1221     }
;;;1222     else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
;;;1223     {
;;;1224       return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
;;;1225     }
;;;1226     else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
;;;1227     {
;;;1228       return SDMMC_ERROR_ADDR_MISALIGNED;
;;;1229     }
;;;1230     else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
;;;1231     {
;;;1232       return SDMMC_ERROR_BLOCK_LEN_ERR;
;;;1233     }
;;;1234     else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
;;;1235     {
;;;1236       return SDMMC_ERROR_ERASE_SEQ_ERR;
;;;1237     }
;;;1238     else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
;;;1239     {
;;;1240       return SDMMC_ERROR_BAD_ERASE_PARAM;
;;;1241     }
;;;1242     else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
;;;1243     {
;;;1244       return SDMMC_ERROR_WRITE_PROT_VIOLATION;
;;;1245     }
;;;1246     else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
;;;1247     {
;;;1248       return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
;;;1249     }
;;;1250     else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
;;;1251     {
;;;1252       return SDMMC_ERROR_COM_CRC_FAILED;
;;;1253     }
;;;1254     else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
;;;1255     {
;;;1256       return SDMMC_ERROR_ILLEGAL_CMD;
;;;1257     }
;;;1258     else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
;;;1259     {
;;;1260       return SDMMC_ERROR_CARD_ECC_FAILED;
;;;1261     }
;;;1262     else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
;;;1263     {
;;;1264       return SDMMC_ERROR_CC_ERR;
;;;1265     }
;;;1266     else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
;;;1267     {
;;;1268       return SDMMC_ERROR_STREAM_READ_UNDERRUN;
;;;1269     }
;;;1270     else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
;;;1271     {
;;;1272       return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
;;;1273     }
;;;1274     else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
;;;1275     {
;;;1276       return SDMMC_ERROR_CID_CSD_OVERWRITE;
;;;1277     }
;;;1278     else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
;;;1279     {
;;;1280       return SDMMC_ERROR_WP_ERASE_SKIP;
;;;1281     }
;;;1282     else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
;;;1283     {
;;;1284       return SDMMC_ERROR_CARD_ECC_DISABLED;
;;;1285     }
;;;1286     else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
;;;1287     {
;;;1288       return SDMMC_ERROR_ERASE_RESET;
;;;1289     }
;;;1290     else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
;;;1291     {
;;;1292       return SDMMC_ERROR_AKE_SEQ_ERR;
;;;1293     }
;;;1294     else
;;;1295     {
;;;1296       return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
;;;1297     }
;;;1298   }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L40.48|
000030  6b68              LDR      r0,[r5,#0x34]         ;1191
000032  f0000045          AND      r0,r0,#0x45           ;1191
000036  2800              CMP      r0,#0                 ;1191
000038  d0f1              BEQ      |L40.30|
00003a  6b68              LDR      r0,[r5,#0x34]         ;1193
00003c  f0000004          AND      r0,r0,#4              ;1193
000040  b110              CBZ      r0,|L40.72|
000042  2004              MOVS     r0,#4                 ;1195
000044  63a8              STR      r0,[r5,#0x38]         ;1195
000046  e7f1              B        |L40.44|
                  |L40.72|
000048  6b68              LDR      r0,[r5,#0x34]         ;1199
00004a  f0000001          AND      r0,r0,#1              ;1199
00004e  b110              CBZ      r0,|L40.86|
000050  2001              MOVS     r0,#1                 ;1201
000052  63a8              STR      r0,[r5,#0x38]         ;1201
000054  e7ea              B        |L40.44|
                  |L40.86|
000056  4628              MOV      r0,r5                 ;1207
000058  f7fffffe          BL       SDIO_GetCommandResponse
00005c  42b0              CMP      r0,r6                 ;1207
00005e  d001              BEQ      |L40.100|
000060  2001              MOVS     r0,#1                 ;1209
000062  e7e3              B        |L40.44|
                  |L40.100|
000064  f24050ff          MOV      r0,#0x5ff             ;1213
000068  63a8              STR      r0,[r5,#0x38]         ;1213
00006a  2100              MOVS     r1,#0                 ;1216
00006c  4628              MOV      r0,r5                 ;1216
00006e  f7fffffe          BL       SDIO_GetResponse
000072  4604              MOV      r4,r0                 ;1216
000074  484a              LDR      r0,|L40.416|
000076  4020              ANDS     r0,r0,r4              ;1218
000078  b908              CBNZ     r0,|L40.126|
00007a  2000              MOVS     r0,#0                 ;1220
00007c  e7d6              B        |L40.44|
                  |L40.126|
00007e  f0044000          AND      r0,r4,#0x80000000     ;1222
000082  f1b04f00          CMP      r0,#0x80000000        ;1222
000086  d102              BNE      |L40.142|
000088  f04f7000          MOV      r0,#0x2000000         ;1224
00008c  e7ce              B        |L40.44|
                  |L40.142|
00008e  f0044080          AND      r0,r4,#0x40000000     ;1226
000092  f1b04f80          CMP      r0,#0x40000000        ;1226
000096  d101              BNE      |L40.156|
000098  2040              MOVS     r0,#0x40              ;1228
00009a  e7c7              B        |L40.44|
                  |L40.156|
00009c  f0045000          AND      r0,r4,#0x20000000     ;1230
0000a0  f1b05f00          CMP      r0,#0x20000000        ;1230
0000a4  d101              BNE      |L40.170|
0000a6  2080              MOVS     r0,#0x80              ;1232
0000a8  e7c0              B        |L40.44|
                  |L40.170|
0000aa  f0045080          AND      r0,r4,#0x10000000     ;1234
0000ae  f1b05f80          CMP      r0,#0x10000000        ;1234
0000b2  d102              BNE      |L40.186|
0000b4  f44f7080          MOV      r0,#0x100             ;1236
0000b8  e7b8              B        |L40.44|
                  |L40.186|
0000ba  f0046000          AND      r0,r4,#0x8000000      ;1238
0000be  f1b06f00          CMP      r0,#0x8000000         ;1238
0000c2  d102              BNE      |L40.202|
0000c4  f44f7000          MOV      r0,#0x200             ;1240
0000c8  e7b0              B        |L40.44|
                  |L40.202|
0000ca  f0046080          AND      r0,r4,#0x4000000      ;1242
0000ce  f1b06f80          CMP      r0,#0x4000000         ;1242
0000d2  d102              BNE      |L40.218|
0000d4  f44f6080          MOV      r0,#0x400             ;1244
0000d8  e7a8              B        |L40.44|
                  |L40.218|
0000da  f0047080          AND      r0,r4,#0x1000000      ;1246
0000de  f1b07f80          CMP      r0,#0x1000000         ;1246
0000e2  d102              BNE      |L40.234|
0000e4  f44f6000          MOV      r0,#0x800             ;1248
0000e8  e7a0              B        |L40.44|
                  |L40.234|
0000ea  f4040000          AND      r0,r4,#0x800000       ;1250
0000ee  f5b00f00          CMP      r0,#0x800000          ;1250
0000f2  d102              BNE      |L40.250|
0000f4  f44f5080          MOV      r0,#0x1000            ;1252
0000f8  e798              B        |L40.44|
                  |L40.250|
0000fa  f4040080          AND      r0,r4,#0x400000       ;1254
0000fe  f5b00f80          CMP      r0,#0x400000          ;1254
000102  d102              BNE      |L40.266|
000104  f44f5000          MOV      r0,#0x2000            ;1256
000108  e790              B        |L40.44|
                  |L40.266|
00010a  f4041000          AND      r0,r4,#0x200000       ;1258
00010e  f5b01f00          CMP      r0,#0x200000          ;1258
000112  d102              BNE      |L40.282|
000114  f44f4080          MOV      r0,#0x4000            ;1260
000118  e788              B        |L40.44|
                  |L40.282|
00011a  f4041080          AND      r0,r4,#0x100000       ;1262
00011e  f5b01f80          CMP      r0,#0x100000          ;1262
000122  d102              BNE      |L40.298|
000124  f44f4000          MOV      r0,#0x8000            ;1264
000128  e780              B        |L40.44|
                  |L40.298|
00012a  f4042080          AND      r0,r4,#0x40000        ;1266
00012e  f5b02f80          CMP      r0,#0x40000           ;1266
000132  d102              BNE      |L40.314|
000134  f44f3000          MOV      r0,#0x20000           ;1268
000138  e778              B        |L40.44|
                  |L40.314|
00013a  f4043000          AND      r0,r4,#0x20000        ;1270
00013e  f5b03f00          CMP      r0,#0x20000           ;1270
000142  d102              BNE      |L40.330|
000144  f44f2080          MOV      r0,#0x40000           ;1272
000148  e770              B        |L40.44|
                  |L40.330|
00014a  f4043080          AND      r0,r4,#0x10000        ;1274
00014e  f5b03f80          CMP      r0,#0x10000           ;1274
000152  d102              BNE      |L40.346|
000154  f44f2000          MOV      r0,#0x80000           ;1276
000158  e768              B        |L40.44|
                  |L40.346|
00015a  f4044000          AND      r0,r4,#0x8000         ;1278
00015e  f5b04f00          CMP      r0,#0x8000            ;1278
000162  d102              BNE      |L40.362|
000164  f44f1080          MOV      r0,#0x100000          ;1280
000168  e760              B        |L40.44|
                  |L40.362|
00016a  f4044080          AND      r0,r4,#0x4000         ;1282
00016e  f5b04f80          CMP      r0,#0x4000            ;1282
000172  d102              BNE      |L40.378|
000174  f44f1000          MOV      r0,#0x200000          ;1284
000178  e758              B        |L40.44|
                  |L40.378|
00017a  f4045000          AND      r0,r4,#0x2000         ;1286
00017e  f5b05f00          CMP      r0,#0x2000            ;1286
000182  d102              BNE      |L40.394|
000184  f44f0080          MOV      r0,#0x400000          ;1288
000188  e750              B        |L40.44|
                  |L40.394|
00018a  f0040008          AND      r0,r4,#8              ;1290
00018e  2808              CMP      r0,#8                 ;1290
000190  d101              BNE      |L40.406|
000192  0500              LSLS     r0,r0,#20             ;1292
000194  e74a              B        |L40.44|
                  |L40.406|
000196  f44f3080          MOV      r0,#0x10000           ;1296
00019a  e747              B        |L40.44|
;;;1299   
                          ENDP

                  |L40.412|
                          DCD      SystemCoreClock
                  |L40.416|
                          DCD      0xfdffe008

                          AREA ||i.SDMMC_GetCmdResp2||, CODE, READONLY, ALIGN=2

                  SDMMC_GetCmdResp2 PROC
;;;1304     */
;;;1305   static uint32_t SDMMC_GetCmdResp2(SDIO_TypeDef *SDIOx)
000000  4601              MOV      r1,r0
;;;1306   {
;;;1307     /* 8 is the number of required instructions cycles for the below loop statement.
;;;1308     The SDMMC_CMDTIMEOUT is expressed in ms */
;;;1309     register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
000002  4815              LDR      r0,|L41.88|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  08c0              LSRS     r0,r0,#3
000008  f44f737a          MOV      r3,#0x3e8
00000c  fbb0f0f3          UDIV     r0,r0,r3
000010  f2413388          MOV      r3,#0x1388
000014  fb00f203          MUL      r2,r0,r3
;;;1310     
;;;1311     do
000018  bf00              NOP      
                  |L41.26|
;;;1312     {
;;;1313       if (count-- == 0U)
00001a  1e10              SUBS     r0,r2,#0
00001c  f1a20201          SUB      r2,r2,#1
000020  d102              BNE      |L41.40|
;;;1314       {
;;;1315         return SDMMC_ERROR_TIMEOUT;
000022  f04f4000          MOV      r0,#0x80000000
                  |L41.38|
;;;1316       }
;;;1317       
;;;1318     }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
;;;1319       
;;;1320     if (__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
;;;1321     {
;;;1322       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
;;;1323       
;;;1324       return SDMMC_ERROR_CMD_RSP_TIMEOUT;
;;;1325     }
;;;1326     else if (__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
;;;1327     {
;;;1328       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
;;;1329       
;;;1330       return SDMMC_ERROR_CMD_CRC_FAIL;
;;;1331     }
;;;1332     else
;;;1333     {
;;;1334       /* No error flag set */
;;;1335       /* Clear all the static flags */
;;;1336       __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
;;;1337     }
;;;1338   
;;;1339     return SDMMC_ERROR_NONE;
;;;1340   }
000026  4770              BX       lr
                  |L41.40|
000028  6b48              LDR      r0,[r1,#0x34]         ;1318
00002a  f0000045          AND      r0,r0,#0x45           ;1318
00002e  2800              CMP      r0,#0                 ;1318
000030  d0f3              BEQ      |L41.26|
000032  6b48              LDR      r0,[r1,#0x34]         ;1320
000034  f0000004          AND      r0,r0,#4              ;1320
000038  b110              CBZ      r0,|L41.64|
00003a  2004              MOVS     r0,#4                 ;1322
00003c  6388              STR      r0,[r1,#0x38]         ;1322
00003e  e7f2              B        |L41.38|
                  |L41.64|
000040  6b48              LDR      r0,[r1,#0x34]         ;1326
000042  f0000001          AND      r0,r0,#1              ;1326
000046  b110              CBZ      r0,|L41.78|
000048  2001              MOVS     r0,#1                 ;1328
00004a  6388              STR      r0,[r1,#0x38]         ;1328
00004c  e7eb              B        |L41.38|
                  |L41.78|
00004e  f24050ff          MOV      r0,#0x5ff             ;1336
000052  6388              STR      r0,[r1,#0x38]         ;1336
000054  2000              MOVS     r0,#0                 ;1339
000056  e7e6              B        |L41.38|
;;;1341   
                          ENDP

                  |L41.88|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_GetCmdResp3||, CODE, READONLY, ALIGN=2

                  SDMMC_GetCmdResp3 PROC
;;;1346     */
;;;1347   static uint32_t SDMMC_GetCmdResp3(SDIO_TypeDef *SDIOx)
000000  4601              MOV      r1,r0
;;;1348   {
;;;1349     /* 8 is the number of required instructions cycles for the below loop statement.
;;;1350     The SDMMC_CMDTIMEOUT is expressed in ms */
;;;1351     register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
000002  4812              LDR      r0,|L42.76|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  08c0              LSRS     r0,r0,#3
000008  f44f737a          MOV      r3,#0x3e8
00000c  fbb0f0f3          UDIV     r0,r0,r3
000010  f2413388          MOV      r3,#0x1388
000014  fb00f203          MUL      r2,r0,r3
;;;1352     
;;;1353     do
000018  bf00              NOP      
                  |L42.26|
;;;1354     {
;;;1355       if (count-- == 0U)
00001a  1e10              SUBS     r0,r2,#0
00001c  f1a20201          SUB      r2,r2,#1
000020  d102              BNE      |L42.40|
;;;1356       {
;;;1357         return SDMMC_ERROR_TIMEOUT;
000022  f04f4000          MOV      r0,#0x80000000
                  |L42.38|
;;;1358       }
;;;1359       
;;;1360     }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
;;;1361     
;;;1362     if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
;;;1363     {
;;;1364       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
;;;1365       
;;;1366       return SDMMC_ERROR_CMD_RSP_TIMEOUT;
;;;1367     }
;;;1368     else
;;;1369    
;;;1370     {  
;;;1371       /* Clear all the static flags */
;;;1372       __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
;;;1373     }
;;;1374     
;;;1375     return SDMMC_ERROR_NONE;
;;;1376   }
000026  4770              BX       lr
                  |L42.40|
000028  6b48              LDR      r0,[r1,#0x34]         ;1360
00002a  f0000045          AND      r0,r0,#0x45           ;1360
00002e  2800              CMP      r0,#0                 ;1360
000030  d0f3              BEQ      |L42.26|
000032  6b48              LDR      r0,[r1,#0x34]         ;1362
000034  f0000004          AND      r0,r0,#4              ;1362
000038  b110              CBZ      r0,|L42.64|
00003a  2004              MOVS     r0,#4                 ;1364
00003c  6388              STR      r0,[r1,#0x38]         ;1364
00003e  e7f2              B        |L42.38|
                  |L42.64|
000040  f24050ff          MOV      r0,#0x5ff             ;1372
000044  6388              STR      r0,[r1,#0x38]         ;1372
000046  2000              MOVS     r0,#0                 ;1375
000048  e7ed              B        |L42.38|
;;;1377   
                          ENDP

00004a  0000              DCW      0x0000
                  |L42.76|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_GetCmdResp6||, CODE, READONLY, ALIGN=2

                  SDMMC_GetCmdResp6 PROC
;;;1385     */
;;;1386   static uint32_t SDMMC_GetCmdResp6(SDIO_TypeDef *SDIOx, uint8_t SD_CMD, uint16_t *pRCA)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1387   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1388     uint32_t response_r1;
;;;1389   
;;;1390     /* 8 is the number of required instructions cycles for the below loop statement.
;;;1391     The SDMMC_CMDTIMEOUT is expressed in ms */
;;;1392     register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
00000a  4828              LDR      r0,|L43.172|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  08c0              LSRS     r0,r0,#3
000010  f44f717a          MOV      r1,#0x3e8
000014  fbb0f0f1          UDIV     r0,r0,r1
000018  f2413188          MOV      r1,#0x1388
00001c  fb00f801          MUL      r8,r0,r1
;;;1393     
;;;1394     do
000020  bf00              NOP      
                  |L43.34|
;;;1395     {
;;;1396       if (count-- == 0U)
000022  f1b80000          SUBS     r0,r8,#0
000026  f1a80801          SUB      r8,r8,#1
00002a  d103              BNE      |L43.52|
;;;1397       {
;;;1398         return SDMMC_ERROR_TIMEOUT;
00002c  f04f4000          MOV      r0,#0x80000000
                  |L43.48|
;;;1399       }
;;;1400       
;;;1401     }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
;;;1402     
;;;1403     if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
;;;1404     {
;;;1405       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT);
;;;1406       
;;;1407       return SDMMC_ERROR_CMD_RSP_TIMEOUT;
;;;1408     }
;;;1409     else if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL))
;;;1410     {
;;;1411       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL);
;;;1412       
;;;1413       return SDMMC_ERROR_CMD_CRC_FAIL;
;;;1414     }
;;;1415     
;;;1416     /* Check response received is of desired command */
;;;1417     if(SDIO_GetCommandResponse(SDIOx) != SD_CMD)
;;;1418     {
;;;1419       return SDMMC_ERROR_CMD_CRC_FAIL;
;;;1420     }
;;;1421     
;;;1422     /* Clear all the static flags */
;;;1423     __SDIO_CLEAR_FLAG(SDIOx, SDIO_STATIC_FLAGS);
;;;1424     
;;;1425     /* We have received response, retrieve it.  */
;;;1426     response_r1 = SDIO_GetResponse(SDIOx, SDIO_RESP1);
;;;1427     
;;;1428     if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
;;;1429     {
;;;1430       *pRCA = (uint16_t) (response_r1 >> 16);
;;;1431       
;;;1432       return SDMMC_ERROR_NONE;
;;;1433     }
;;;1434     else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
;;;1435     {
;;;1436       return SDMMC_ERROR_ILLEGAL_CMD;
;;;1437     }
;;;1438     else if((response_r1 & SDMMC_R6_COM_CRC_FAILED) == SDMMC_R6_COM_CRC_FAILED)
;;;1439     {
;;;1440       return SDMMC_ERROR_COM_CRC_FAILED;
;;;1441     }
;;;1442     else
;;;1443     {
;;;1444       return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
;;;1445     }
;;;1446   }
000030  e8bd81f0          POP      {r4-r8,pc}
                  |L43.52|
000034  6b60              LDR      r0,[r4,#0x34]         ;1401
000036  f0000045          AND      r0,r0,#0x45           ;1401
00003a  2800              CMP      r0,#0                 ;1401
00003c  d0f1              BEQ      |L43.34|
00003e  6b60              LDR      r0,[r4,#0x34]         ;1403
000040  f0000004          AND      r0,r0,#4              ;1403
000044  b110              CBZ      r0,|L43.76|
000046  2004              MOVS     r0,#4                 ;1405
000048  63a0              STR      r0,[r4,#0x38]         ;1405
00004a  e7f1              B        |L43.48|
                  |L43.76|
00004c  6b60              LDR      r0,[r4,#0x34]         ;1409
00004e  f0000001          AND      r0,r0,#1              ;1409
000052  b110              CBZ      r0,|L43.90|
000054  2001              MOVS     r0,#1                 ;1411
000056  63a0              STR      r0,[r4,#0x38]         ;1411
000058  e7ea              B        |L43.48|
                  |L43.90|
00005a  4620              MOV      r0,r4                 ;1417
00005c  f7fffffe          BL       SDIO_GetCommandResponse
000060  42b0              CMP      r0,r6                 ;1417
000062  d001              BEQ      |L43.104|
000064  2001              MOVS     r0,#1                 ;1419
000066  e7e3              B        |L43.48|
                  |L43.104|
000068  f24050ff          MOV      r0,#0x5ff             ;1423
00006c  63a0              STR      r0,[r4,#0x38]         ;1423
00006e  2100              MOVS     r1,#0                 ;1426
000070  4620              MOV      r0,r4                 ;1426
000072  f7fffffe          BL       SDIO_GetResponse
000076  4605              MOV      r5,r0                 ;1426
000078  f4054060          AND      r0,r5,#0xe000         ;1428
00007c  b918              CBNZ     r0,|L43.134|
00007e  0c28              LSRS     r0,r5,#16             ;1430
000080  8038              STRH     r0,[r7,#0]            ;1430
000082  2000              MOVS     r0,#0                 ;1432
000084  e7d4              B        |L43.48|
                  |L43.134|
000086  f4054080          AND      r0,r5,#0x4000         ;1434
00008a  f5b04f80          CMP      r0,#0x4000            ;1434
00008e  d102              BNE      |L43.150|
000090  f44f5000          MOV      r0,#0x2000            ;1436
000094  e7cc              B        |L43.48|
                  |L43.150|
000096  f4054000          AND      r0,r5,#0x8000         ;1438
00009a  f5b04f00          CMP      r0,#0x8000            ;1438
00009e  d102              BNE      |L43.166|
0000a0  f44f5080          MOV      r0,#0x1000            ;1440
0000a4  e7c4              B        |L43.48|
                  |L43.166|
0000a6  f44f3080          MOV      r0,#0x10000           ;1444
0000aa  e7c1              B        |L43.48|
;;;1447   
                          ENDP

                  |L43.172|
                          DCD      SystemCoreClock

                          AREA ||i.SDMMC_GetCmdResp7||, CODE, READONLY, ALIGN=2

                  SDMMC_GetCmdResp7 PROC
;;;1452     */
;;;1453   static uint32_t SDMMC_GetCmdResp7(SDIO_TypeDef *SDIOx)
000000  4601              MOV      r1,r0
;;;1454   {
;;;1455     /* 8 is the number of required instructions cycles for the below loop statement.
;;;1456     The SDIO_CMDTIMEOUT is expressed in ms */
;;;1457     register uint32_t count = SDIO_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
000002  4814              LDR      r0,|L44.84|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  08c0              LSRS     r0,r0,#3
000008  f44f737a          MOV      r3,#0x3e8
00000c  fbb0f0f3          UDIV     r0,r0,r3
000010  f2413388          MOV      r3,#0x1388
000014  fb00f203          MUL      r2,r0,r3
;;;1458     
;;;1459     do
000018  bf00              NOP      
                  |L44.26|
;;;1460     {
;;;1461       if (count-- == 0U)
00001a  1e10              SUBS     r0,r2,#0
00001c  f1a20201          SUB      r2,r2,#1
000020  d102              BNE      |L44.40|
;;;1462       {
;;;1463         return SDMMC_ERROR_TIMEOUT;
000022  f04f4000          MOV      r0,#0x80000000
                  |L44.38|
;;;1464       }
;;;1465       
;;;1466     }while(!__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CCRCFAIL | SDIO_FLAG_CMDREND | SDIO_FLAG_CTIMEOUT));
;;;1467   
;;;1468     if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CTIMEOUT))
;;;1469     {
;;;1470       /* Card is SD V2.0 compliant */
;;;1471       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CMDREND);
;;;1472       
;;;1473       return SDMMC_ERROR_CMD_RSP_TIMEOUT;
;;;1474     }
;;;1475     
;;;1476     if(__SDIO_GET_FLAG(SDIOx, SDIO_FLAG_CMDREND))
;;;1477     {
;;;1478       /* Card is SD V2.0 compliant */
;;;1479       __SDIO_CLEAR_FLAG(SDIOx, SDIO_FLAG_CMDREND);
;;;1480     }
;;;1481     
;;;1482     return SDMMC_ERROR_NONE;
;;;1483     
;;;1484   }
000026  4770              BX       lr
                  |L44.40|
000028  6b48              LDR      r0,[r1,#0x34]         ;1466
00002a  f0000045          AND      r0,r0,#0x45           ;1466
00002e  2800              CMP      r0,#0                 ;1466
000030  d0f3              BEQ      |L44.26|
000032  6b48              LDR      r0,[r1,#0x34]         ;1468
000034  f0000004          AND      r0,r0,#4              ;1468
000038  b118              CBZ      r0,|L44.66|
00003a  2040              MOVS     r0,#0x40              ;1471
00003c  6388              STR      r0,[r1,#0x38]         ;1471
00003e  2004              MOVS     r0,#4                 ;1473
000040  e7f1              B        |L44.38|
                  |L44.66|
000042  6b48              LDR      r0,[r1,#0x34]         ;1476
000044  f0000040          AND      r0,r0,#0x40           ;1476
000048  b108              CBZ      r0,|L44.78|
00004a  2040              MOVS     r0,#0x40              ;1479
00004c  6388              STR      r0,[r1,#0x38]         ;1479
                  |L44.78|
00004e  2000              MOVS     r0,#0                 ;1482
000050  e7e9              B        |L44.38|
;;;1485   
                          ENDP

000052  0000              DCW      0x0000
                  |L44.84|
                          DCD      SystemCoreClock

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_sdmmc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____REVSH|
#line 402
|__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____RRX|
#line 587
|__asm___20_stm32f4xx_ll_sdmmc_c_d2dde155____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
