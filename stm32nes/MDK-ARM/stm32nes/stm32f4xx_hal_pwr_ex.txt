; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_hal_pwr_ex.o --depend=stm32nes\stm32f4xx_hal_pwr_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_hal_pwr_ex.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pwr_ex.c]
                          THUMB

                          AREA ||i.HAL_PWREx_ControlVoltageScaling||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_ControlVoltageScaling PROC
;;;305      */
;;;306    HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
000000  b538              PUSH     {r3-r5,lr}
;;;307    {
000002  4605              MOV      r5,r0
;;;308      uint32_t tickstart = 0U;
000004  2400              MOVS     r4,#0
;;;309      
;;;310      assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
;;;311      
;;;312      /* Enable PWR RCC Clock Peripheral */
;;;313      __HAL_RCC_PWR_CLK_ENABLE();
000006  bf00              NOP      
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4832              LDR      r0,|L1.216|
00000e  6800              LDR      r0,[r0,#0]
000010  f0405080          ORR      r0,r0,#0x10000000
000014  4930              LDR      r1,|L1.216|
000016  6008              STR      r0,[r1,#0]
000018  4608              MOV      r0,r1
00001a  6800              LDR      r0,[r0,#0]
00001c  f0005080          AND      r0,r0,#0x10000000
000020  9000              STR      r0,[sp,#0]
000022  bf00              NOP      
000024  bf00              NOP      
;;;314      
;;;315      /* Check if the PLL is used as system clock or not */
;;;316      if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
000026  482c              LDR      r0,|L1.216|
000028  3838              SUBS     r0,r0,#0x38
00002a  6800              LDR      r0,[r0,#0]
00002c  f000000c          AND      r0,r0,#0xc
000030  2808              CMP      r0,#8
000032  d04c              BEQ      |L1.206|
;;;317      {
;;;318        /* Disable the main PLL */
;;;319        __HAL_RCC_PLL_DISABLE();
000034  2000              MOVS     r0,#0
000036  4929              LDR      r1,|L1.220|
000038  6608              STR      r0,[r1,#0x60]
;;;320        
;;;321        /* Get Start Tick */
;;;322        tickstart = HAL_GetTick();    
00003a  f7fffffe          BL       HAL_GetTick
00003e  4604              MOV      r4,r0
;;;323        /* Wait till PLL is disabled */  
;;;324        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
000040  e006              B        |L1.80|
                  |L1.66|
;;;325        {
;;;326          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
000042  f7fffffe          BL       HAL_GetTick
000046  1b00              SUBS     r0,r0,r4
000048  2802              CMP      r0,#2
00004a  d901              BLS      |L1.80|
;;;327          {
;;;328            return HAL_TIMEOUT;
00004c  2003              MOVS     r0,#3
                  |L1.78|
;;;329          }
;;;330        }
;;;331        
;;;332        /* Set Range */
;;;333        __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
;;;334        
;;;335        /* Enable the main PLL */
;;;336        __HAL_RCC_PLL_ENABLE();
;;;337        
;;;338        /* Get Start Tick */
;;;339        tickstart = HAL_GetTick();
;;;340        /* Wait till PLL is ready */  
;;;341        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;342        {
;;;343          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;344          {
;;;345            return HAL_TIMEOUT;
;;;346          } 
;;;347        }
;;;348        
;;;349        /* Get Start Tick */
;;;350        tickstart = HAL_GetTick();
;;;351        while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
;;;352        {
;;;353          if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
;;;354          {
;;;355            return HAL_TIMEOUT;
;;;356          } 
;;;357        }
;;;358      }
;;;359      else
;;;360      {
;;;361        return HAL_ERROR;
;;;362      }
;;;363    
;;;364      return HAL_OK;
;;;365    }
00004e  bd38              POP      {r3-r5,pc}
                  |L1.80|
000050  4821              LDR      r0,|L1.216|
000052  3840              SUBS     r0,r0,#0x40           ;324
000054  6800              LDR      r0,[r0,#0]            ;324
000056  f3c06040          UBFX     r0,r0,#25,#1          ;324
00005a  2800              CMP      r0,#0                 ;324
00005c  d1f1              BNE      |L1.66|
00005e  bf00              NOP                            ;333
000060  9000              STR      r0,[sp,#0]            ;333
000062  481f              LDR      r0,|L1.224|
000064  6800              LDR      r0,[r0,#0]            ;333
000066  f4204040          BIC      r0,r0,#0xc000         ;333
00006a  4328              ORRS     r0,r0,r5              ;333
00006c  491c              LDR      r1,|L1.224|
00006e  6008              STR      r0,[r1,#0]            ;333
000070  4608              MOV      r0,r1                 ;333
000072  6800              LDR      r0,[r0,#0]            ;333
000074  f4004040          AND      r0,r0,#0xc000         ;333
000078  9000              STR      r0,[sp,#0]            ;333
00007a  bf00              NOP                            ;333
00007c  bf00              NOP                            ;333
00007e  2001              MOVS     r0,#1                 ;336
000080  4916              LDR      r1,|L1.220|
000082  6608              STR      r0,[r1,#0x60]         ;336
000084  f7fffffe          BL       HAL_GetTick
000088  4604              MOV      r4,r0                 ;339
00008a  e006              B        |L1.154|
                  |L1.140|
00008c  f7fffffe          BL       HAL_GetTick
000090  1b00              SUBS     r0,r0,r4              ;343
000092  2802              CMP      r0,#2                 ;343
000094  d901              BLS      |L1.154|
000096  2003              MOVS     r0,#3                 ;345
000098  e7d9              B        |L1.78|
                  |L1.154|
00009a  480f              LDR      r0,|L1.216|
00009c  3840              SUBS     r0,r0,#0x40           ;341
00009e  6800              LDR      r0,[r0,#0]            ;341
0000a0  f3c06040          UBFX     r0,r0,#25,#1          ;341
0000a4  2800              CMP      r0,#0                 ;341
0000a6  d0f1              BEQ      |L1.140|
0000a8  f7fffffe          BL       HAL_GetTick
0000ac  4604              MOV      r4,r0                 ;350
0000ae  e007              B        |L1.192|
                  |L1.176|
0000b0  f7fffffe          BL       HAL_GetTick
0000b4  1b00              SUBS     r0,r0,r4              ;353
0000b6  f5b07f7a          CMP      r0,#0x3e8             ;353
0000ba  d901              BLS      |L1.192|
0000bc  2003              MOVS     r0,#3                 ;355
0000be  e7c6              B        |L1.78|
                  |L1.192|
0000c0  4807              LDR      r0,|L1.224|
0000c2  6840              LDR      r0,[r0,#4]            ;351
0000c4  f3c03080          UBFX     r0,r0,#14,#1          ;351
0000c8  2800              CMP      r0,#0                 ;351
0000ca  d0f1              BEQ      |L1.176|
0000cc  e001              B        |L1.210|
                  |L1.206|
0000ce  2001              MOVS     r0,#1                 ;361
0000d0  e7bd              B        |L1.78|
                  |L1.210|
0000d2  2000              MOVS     r0,#0                 ;364
0000d4  e7bb              B        |L1.78|
;;;366    #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
                          ENDP

0000d6  0000              DCW      0x0000
                  |L1.216|
                          DCD      0x40023840
                  |L1.220|
                          DCD      0x42470000
                  |L1.224|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableBkUpReg PROC
;;;182      */
;;;183    HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185      uint32_t tickstart = 0U;
000002  2400              MOVS     r4,#0
;;;186    
;;;187      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)DISABLE;
000004  2000              MOVS     r0,#0
000006  490b              LDR      r1,|L2.52|
000008  6008              STR      r0,[r1,#0]
;;;188    
;;;189      /* Get tick */
;;;190      tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4604              MOV      r4,r0
;;;191    
;;;192      /* Wait till Backup regulator ready flag is set */  
;;;193      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
000010  e007              B        |L2.34|
                  |L2.18|
;;;194      {
;;;195        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000012  f7fffffe          BL       HAL_GetTick
000016  1b00              SUBS     r0,r0,r4
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d901              BLS      |L2.34|
;;;196        {
;;;197          return HAL_TIMEOUT;
00001e  2003              MOVS     r0,#3
                  |L2.32|
;;;198        } 
;;;199      }
;;;200      return HAL_OK;
;;;201    }
000020  bd10              POP      {r4,pc}
                  |L2.34|
000022  4805              LDR      r0,|L2.56|
000024  6840              LDR      r0,[r0,#4]            ;193
000026  f3c000c0          UBFX     r0,r0,#3,#1           ;193
00002a  2800              CMP      r0,#0                 ;193
00002c  d1f1              BNE      |L2.18|
00002e  bf00              NOP                            ;200
000030  e7f6              B        |L2.32|
;;;202    
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      0x420e00a4
                  |L2.56|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableFlashPowerDown PROC
;;;215      */
;;;216    void HAL_PWREx_DisableFlashPowerDown(void)
000000  2000              MOVS     r0,#0
;;;217    {
;;;218      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)DISABLE;
000002  4901              LDR      r1,|L3.8|
000004  6248              STR      r0,[r1,#0x24]
;;;219    }
000006  4770              BX       lr
;;;220    
                          ENDP

                  |L3.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWREx_DisableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableOverDrive PROC
;;;497      */
;;;498    HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
000000  b538              PUSH     {r3-r5,lr}
;;;499    {
;;;500      uint32_t tickstart = 0U;
000002  2400              MOVS     r4,#0
;;;501      
;;;502      __HAL_RCC_PWR_CLK_ENABLE();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  481d              LDR      r0,|L4.128|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0405080          ORR      r0,r0,#0x10000000
000012  491b              LDR      r1,|L4.128|
000014  6008              STR      r0,[r1,#0]
000016  4608              MOV      r0,r1
000018  6800              LDR      r0,[r0,#0]
00001a  f0005080          AND      r0,r0,#0x10000000
00001e  9000              STR      r0,[sp,#0]
000020  bf00              NOP      
000022  bf00              NOP      
;;;503        
;;;504      /* Disable the Over-drive switch */
;;;505      __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
000024  2000              MOVS     r0,#0
000026  4917              LDR      r1,|L4.132|
000028  6448              STR      r0,[r1,#0x44]
;;;506      
;;;507      /* Get tick */
;;;508      tickstart = HAL_GetTick();
00002a  f7fffffe          BL       HAL_GetTick
00002e  4604              MOV      r4,r0
;;;509     
;;;510      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
000030  e007              B        |L4.66|
                  |L4.50|
;;;511      {
;;;512        if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000032  f7fffffe          BL       HAL_GetTick
000036  1b00              SUBS     r0,r0,r4
000038  f5b07f7a          CMP      r0,#0x3e8
00003c  d901              BLS      |L4.66|
;;;513        {
;;;514          return HAL_TIMEOUT;
00003e  2003              MOVS     r0,#3
                  |L4.64|
;;;515        }
;;;516      } 
;;;517      
;;;518      /* Disable the Over-drive */
;;;519      __HAL_PWR_OVERDRIVE_DISABLE();
;;;520    
;;;521      /* Get tick */
;;;522      tickstart = HAL_GetTick();
;;;523    
;;;524      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
;;;525      {
;;;526        if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
;;;527        {
;;;528          return HAL_TIMEOUT;
;;;529        }
;;;530      }
;;;531      
;;;532      return HAL_OK;
;;;533    }
000040  bd38              POP      {r3-r5,pc}
                  |L4.66|
000042  4811              LDR      r0,|L4.136|
000044  6840              LDR      r0,[r0,#4]            ;510
000046  f4003000          AND      r0,r0,#0x20000        ;510
00004a  f5b03f00          CMP      r0,#0x20000           ;510
00004e  d0f0              BEQ      |L4.50|
000050  2000              MOVS     r0,#0                 ;519
000052  490c              LDR      r1,|L4.132|
000054  6408              STR      r0,[r1,#0x40]         ;519
000056  f7fffffe          BL       HAL_GetTick
00005a  4604              MOV      r4,r0                 ;522
00005c  e007              B        |L4.110|
                  |L4.94|
00005e  f7fffffe          BL       HAL_GetTick
000062  1b00              SUBS     r0,r0,r4              ;526
000064  f5b07f7a          CMP      r0,#0x3e8             ;526
000068  d901              BLS      |L4.110|
00006a  2003              MOVS     r0,#3                 ;528
00006c  e7e8              B        |L4.64|
                  |L4.110|
00006e  4806              LDR      r0,|L4.136|
000070  6840              LDR      r0,[r0,#4]            ;524
000072  f4003080          AND      r0,r0,#0x10000        ;524
000076  f5b03f80          CMP      r0,#0x10000           ;524
00007a  d0f0              BEQ      |L4.94|
00007c  2000              MOVS     r0,#0                 ;532
00007e  e7df              B        |L4.64|
;;;534    
                          ENDP

                  |L4.128|
                          DCD      0x40023840
                  |L4.132|
                          DCD      0x420e0000
                  |L4.136|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableBkUpReg PROC
;;;158      */
;;;159    HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
000000  b510              PUSH     {r4,lr}
;;;160    {
;;;161      uint32_t tickstart = 0U;
000002  2400              MOVS     r4,#0
;;;162    
;;;163      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)ENABLE;
000004  2001              MOVS     r0,#1
000006  490b              LDR      r1,|L5.52|
000008  6008              STR      r0,[r1,#0]
;;;164    
;;;165      /* Get tick */
;;;166      tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
00000e  4604              MOV      r4,r0
;;;167    
;;;168      /* Wait till Backup regulator ready flag is set */  
;;;169      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
000010  e007              B        |L5.34|
                  |L5.18|
;;;170      {
;;;171        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
000012  f7fffffe          BL       HAL_GetTick
000016  1b00              SUBS     r0,r0,r4
000018  f5b07f7a          CMP      r0,#0x3e8
00001c  d901              BLS      |L5.34|
;;;172        {
;;;173          return HAL_TIMEOUT;
00001e  2003              MOVS     r0,#3
                  |L5.32|
;;;174        } 
;;;175      }
;;;176      return HAL_OK;
;;;177    }
000020  bd10              POP      {r4,pc}
                  |L5.34|
000022  4805              LDR      r0,|L5.56|
000024  6840              LDR      r0,[r0,#4]            ;169
000026  f3c000c0          UBFX     r0,r0,#3,#1           ;169
00002a  2800              CMP      r0,#0                 ;169
00002c  d0f1              BEQ      |L5.18|
00002e  2000              MOVS     r0,#0                 ;176
000030  e7f6              B        |L5.32|
;;;178    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x420e00a4
                  |L5.56|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableFlashPowerDown PROC
;;;206      */
;;;207    void HAL_PWREx_EnableFlashPowerDown(void)
000000  2001              MOVS     r0,#1
;;;208    {
;;;209      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)ENABLE;
000002  4901              LDR      r1,|L6.8|
000004  6248              STR      r0,[r1,#0x24]
;;;210    }
000006  4770              BX       lr
;;;211    
                          ENDP

                  |L6.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWREx_EnableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableOverDrive PROC
;;;450      */
;;;451    HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
000000  b538              PUSH     {r3-r5,lr}
;;;452    {
;;;453      uint32_t tickstart = 0U;
000002  2400              MOVS     r4,#0
;;;454    
;;;455      __HAL_RCC_PWR_CLK_ENABLE();
000004  bf00              NOP      
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  481d              LDR      r0,|L7.128|
00000c  6800              LDR      r0,[r0,#0]
00000e  f0405080          ORR      r0,r0,#0x10000000
000012  491b              LDR      r1,|L7.128|
000014  6008              STR      r0,[r1,#0]
000016  4608              MOV      r0,r1
000018  6800              LDR      r0,[r0,#0]
00001a  f0005080          AND      r0,r0,#0x10000000
00001e  9000              STR      r0,[sp,#0]
000020  bf00              NOP      
000022  bf00              NOP      
;;;456      
;;;457      /* Enable the Over-drive to extend the clock frequency to 180 Mhz */
;;;458      __HAL_PWR_OVERDRIVE_ENABLE();
000024  2001              MOVS     r0,#1
000026  4917              LDR      r1,|L7.132|
000028  6408              STR      r0,[r1,#0x40]
;;;459    
;;;460      /* Get tick */
;;;461      tickstart = HAL_GetTick();
00002a  f7fffffe          BL       HAL_GetTick
00002e  4604              MOV      r4,r0
;;;462    
;;;463      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
000030  e007              B        |L7.66|
                  |L7.50|
;;;464      {
;;;465        if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000032  f7fffffe          BL       HAL_GetTick
000036  1b00              SUBS     r0,r0,r4
000038  f5b07f7a          CMP      r0,#0x3e8
00003c  d901              BLS      |L7.66|
;;;466        {
;;;467          return HAL_TIMEOUT;
00003e  2003              MOVS     r0,#3
                  |L7.64|
;;;468        }
;;;469      }
;;;470      
;;;471      /* Enable the Over-drive switch */
;;;472      __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
;;;473    
;;;474      /* Get tick */
;;;475      tickstart = HAL_GetTick();
;;;476    
;;;477      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
;;;478      {
;;;479        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
;;;480        {
;;;481          return HAL_TIMEOUT;
;;;482        }
;;;483      } 
;;;484      return HAL_OK;
;;;485    }
000040  bd38              POP      {r3-r5,pc}
                  |L7.66|
000042  4811              LDR      r0,|L7.136|
000044  6840              LDR      r0,[r0,#4]            ;463
000046  f4003080          AND      r0,r0,#0x10000        ;463
00004a  f5b03f80          CMP      r0,#0x10000           ;463
00004e  d1f0              BNE      |L7.50|
000050  2001              MOVS     r0,#1                 ;472
000052  490c              LDR      r1,|L7.132|
000054  6448              STR      r0,[r1,#0x44]         ;472
000056  f7fffffe          BL       HAL_GetTick
00005a  4604              MOV      r4,r0                 ;475
00005c  e007              B        |L7.110|
                  |L7.94|
00005e  f7fffffe          BL       HAL_GetTick
000062  1b00              SUBS     r0,r0,r4              ;479
000064  f5b07f7a          CMP      r0,#0x3e8             ;479
000068  d901              BLS      |L7.110|
00006a  2003              MOVS     r0,#3                 ;481
00006c  e7e8              B        |L7.64|
                  |L7.110|
00006e  4806              LDR      r0,|L7.136|
000070  6840              LDR      r0,[r0,#4]            ;477
000072  f4003000          AND      r0,r0,#0x20000        ;477
000076  f5b03f00          CMP      r0,#0x20000           ;477
00007a  d1f0              BNE      |L7.94|
00007c  2000              MOVS     r0,#0                 ;484
00007e  e7df              B        |L7.64|
;;;486    
                          ENDP

                  |L7.128|
                          DCD      0x40023840
                  |L7.132|
                          DCD      0x420e0000
                  |L7.136|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnterUnderDriveSTOPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterUnderDriveSTOPMode PROC
;;;573      */
;;;574    HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
000000  b518              PUSH     {r3,r4,lr}
;;;575    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;576      uint32_t tmpreg1 = 0U;
000006  2100              MOVS     r1,#0
;;;577    
;;;578      /* Check the parameters */
;;;579      assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
;;;580      assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;581      
;;;582      /* Enable Power ctrl clock */
;;;583      __HAL_RCC_PWR_CLK_ENABLE();
000008  bf00              NOP      
00000a  2000              MOVS     r0,#0
00000c  9000              STR      r0,[sp,#0]
00000e  4819              LDR      r0,|L8.116|
000010  6800              LDR      r0,[r0,#0]
000012  f0405080          ORR      r0,r0,#0x10000000
000016  4c17              LDR      r4,|L8.116|
000018  6020              STR      r0,[r4,#0]
00001a  4620              MOV      r0,r4
00001c  6800              LDR      r0,[r0,#0]
00001e  f0005080          AND      r0,r0,#0x10000000
000022  9000              STR      r0,[sp,#0]
000024  bf00              NOP      
000026  bf00              NOP      
;;;584      /* Enable the Under-drive Mode ---------------------------------------------*/
;;;585      /* Clear Under-drive flag */
;;;586      __HAL_PWR_CLEAR_ODRUDR_FLAG();
000028  4813              LDR      r0,|L8.120|
00002a  6840              LDR      r0,[r0,#4]
00002c  f4402040          ORR      r0,r0,#0xc0000
000030  4c11              LDR      r4,|L8.120|
000032  6060              STR      r0,[r4,#4]
;;;587      
;;;588      /* Enable the Under-drive */ 
;;;589      __HAL_PWR_UNDERDRIVE_ENABLE();
000034  4620              MOV      r0,r4
000036  6800              LDR      r0,[r0,#0]
000038  f4402040          ORR      r0,r0,#0xc0000
00003c  6020              STR      r0,[r4,#0]
;;;590    
;;;591      /* Select the regulator state in STOP mode ---------------------------------*/
;;;592      tmpreg1 = PWR->CR;
00003e  4620              MOV      r0,r4
000040  6801              LDR      r1,[r0,#0]
;;;593      /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
;;;594      tmpreg1 &= (uint32_t)~(PWR_CR_PDDS | PWR_CR_LPDS | PWR_CR_LPUDS | PWR_CR_MRUDS);
000042  f6404003          MOV      r0,#0xc03
000046  4381              BICS     r1,r1,r0
;;;595      
;;;596      /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
;;;597      tmpreg1 |= Regulator;
000048  4311              ORRS     r1,r1,r2
;;;598      
;;;599      /* Store the new value */
;;;600      PWR->CR = tmpreg1;
00004a  4620              MOV      r0,r4
00004c  6001              STR      r1,[r0,#0]
;;;601      
;;;602      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;603      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00004e  480b              LDR      r0,|L8.124|
000050  6800              LDR      r0,[r0,#0]
000052  f0400004          ORR      r0,r0,#4
000056  4c09              LDR      r4,|L8.124|
000058  6020              STR      r0,[r4,#0]
;;;604      
;;;605      /* Select STOP mode entry --------------------------------------------------*/
;;;606      if(STOPEntry == PWR_SLEEPENTRY_WFI)
00005a  2b01              CMP      r3,#1
00005c  d101              BNE      |L8.98|
;;;607      {   
;;;608        /* Request Wait For Interrupt */
;;;609        __WFI();
00005e  bf30              WFI      
000060  e000              B        |L8.100|
                  |L8.98|
;;;610      }
;;;611      else
;;;612      {
;;;613        /* Request Wait For Event */
;;;614        __WFE();
000062  bf20              WFE      
                  |L8.100|
;;;615      }
;;;616      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;617      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
000064  4805              LDR      r0,|L8.124|
000066  6800              LDR      r0,[r0,#0]
000068  f0200004          BIC      r0,r0,#4
00006c  4c03              LDR      r4,|L8.124|
00006e  6020              STR      r0,[r4,#0]
;;;618    
;;;619      return HAL_OK;  
000070  2000              MOVS     r0,#0
;;;620    }
000072  bd18              POP      {r3,r4,pc}
;;;621    
                          ENDP

                  |L8.116|
                          DCD      0x40023840
                  |L8.120|
                          DCD      0x40007000
                  |L8.124|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_GetVoltageRange||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_GetVoltageRange PROC
;;;228      */  
;;;229    uint32_t HAL_PWREx_GetVoltageRange(void)
000000  4802              LDR      r0,|L9.12|
;;;230    {
;;;231      return (PWR->CR & PWR_CR_VOS);
000002  6800              LDR      r0,[r0,#0]
000004  f4004040          AND      r0,r0,#0xc000
;;;232    }
000008  4770              BX       lr
;;;233    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pwr_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REVSH|
#line 402
|__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____RRX|
#line 587
|__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
