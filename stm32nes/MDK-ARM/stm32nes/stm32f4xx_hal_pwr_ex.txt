; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_hal_pwr_ex.o --depend=stm32nes\stm32f4xx_hal_pwr_ex.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 -Otime --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_hal_pwr_ex.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pwr_ex.c]
                          THUMB

                          AREA ||i.HAL_PWREx_ControlVoltageScaling||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_ControlVoltageScaling PROC
;;;305      */
;;;306    HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;307    {
000004  4680              MOV      r8,r0
;;;308      uint32_t tickstart = 0U;
;;;309      
;;;310      assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));
;;;311      
;;;312      /* Enable PWR RCC Clock Peripheral */
;;;313      __HAL_RCC_PWR_CLK_ENABLE();
000006  482d              LDR      r0,|L1.188|
000008  2100              MOVS     r1,#0
00000a  6802              LDR      r2,[r0,#0]
00000c  f0425280          ORR      r2,r2,#0x10000000
000010  6002              STR      r2,[r0,#0]
000012  6800              LDR      r0,[r0,#0]
000014  f0005080          AND      r0,r0,#0x10000000
;;;314      
;;;315      /* Check if the PLL is used as system clock or not */
;;;316      if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
000018  9000              STR      r0,[sp,#0]
00001a  4829              LDR      r0,|L1.192|
00001c  6800              LDR      r0,[r0,#0]
00001e  f000000c          AND      r0,r0,#0xc
000022  2808              CMP      r0,#8
;;;317      {
;;;318        /* Disable the main PLL */
;;;319        __HAL_RCC_PLL_DISABLE();
;;;320        
;;;321        /* Get Start Tick */
;;;322        tickstart = HAL_GetTick();    
;;;323        /* Wait till PLL is disabled */  
;;;324        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
;;;325        {
;;;326          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;327          {
;;;328            return HAL_TIMEOUT;
;;;329          }
;;;330        }
;;;331        
;;;332        /* Set Range */
;;;333        __HAL_PWR_VOLTAGESCALING_CONFIG(VoltageScaling);
;;;334        
;;;335        /* Enable the main PLL */
;;;336        __HAL_RCC_PLL_ENABLE();
;;;337        
;;;338        /* Get Start Tick */
;;;339        tickstart = HAL_GetTick();
;;;340        /* Wait till PLL is ready */  
;;;341        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
;;;342        {
;;;343          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
;;;344          {
;;;345            return HAL_TIMEOUT;
;;;346          } 
;;;347        }
;;;348        
;;;349        /* Get Start Tick */
;;;350        tickstart = HAL_GetTick();
;;;351        while((__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY) == RESET))
;;;352        {
;;;353          if((HAL_GetTick() - tickstart ) > PWR_VOSRDY_TIMEOUT_VALUE)
;;;354          {
;;;355            return HAL_TIMEOUT;
;;;356          } 
;;;357        }
;;;358      }
;;;359      else
;;;360      {
;;;361        return HAL_ERROR;
000024  bf04              ITT      EQ
000026  2001              MOVEQ    r0,#1
;;;362      }
;;;363    
;;;364      return HAL_OK;
;;;365    }
000028  e8bd83f8          POPEQ    {r3-r9,pc}
00002c  4f25              LDR      r7,|L1.196|
00002e  6639              STR      r1,[r7,#0x60]         ;319
000030  f7fffffe          BL       HAL_GetTick
000034  4c24              LDR      r4,|L1.200|
000036  4605              MOV      r5,r0                 ;322
000038  6820              LDR      r0,[r4,#0]            ;324
00003a  f0107f00          TST      r0,#0x2000000         ;324
00003e  d008              BEQ      |L1.82|
                  |L1.64|
000040  f7fffffe          BL       HAL_GetTick
000044  1b40              SUBS     r0,r0,r5              ;326
000046  2802              CMP      r0,#2                 ;326
000048  d82e              BHI      |L1.168|
00004a  6820              LDR      r0,[r4,#0]            ;328
00004c  f0107f00          TST      r0,#0x2000000         ;328
000050  d1f6              BNE      |L1.64|
                  |L1.82|
000052  4e1e              LDR      r6,|L1.204|
000054  6830              LDR      r0,[r6,#0]            ;333
000056  f4204040          BIC      r0,r0,#0xc000         ;333
00005a  ea400008          ORR      r0,r0,r8              ;333
00005e  6030              STR      r0,[r6,#0]            ;333
000060  6830              LDR      r0,[r6,#0]            ;333
000062  f4004040          AND      r0,r0,#0xc000         ;333
000066  9000              STR      r0,[sp,#0]            ;336
000068  2001              MOVS     r0,#1                 ;336
00006a  6638              STR      r0,[r7,#0x60]         ;336
00006c  f7fffffe          BL       HAL_GetTick
000070  4605              MOV      r5,r0                 ;339
000072  6820              LDR      r0,[r4,#0]            ;341
000074  f0107f00          TST      r0,#0x2000000         ;341
000078  d109              BNE      |L1.142|
00007a  bf00              NOP                            ;343
                  |L1.124|
00007c  f7fffffe          BL       HAL_GetTick
000080  1b40              SUBS     r0,r0,r5              ;343
000082  2802              CMP      r0,#2                 ;343
000084  d810              BHI      |L1.168|
000086  6820              LDR      r0,[r4,#0]            ;345
000088  f0107f00          TST      r0,#0x2000000         ;345
00008c  d0f6              BEQ      |L1.124|
                  |L1.142|
00008e  f7fffffe          BL       HAL_GetTick
000092  4604              MOV      r4,r0                 ;350
000094  6870              LDR      r0,[r6,#4]            ;351
000096  f4104f80          TST      r0,#0x4000            ;351
00009a  d10c              BNE      |L1.182|
                  |L1.156|
00009c  f7fffffe          BL       HAL_GetTick
0000a0  1b00              SUBS     r0,r0,r4              ;353
0000a2  f5b07f7a          CMP      r0,#0x3e8             ;353
0000a6  d902              BLS      |L1.174|
                  |L1.168|
0000a8  2003              MOVS     r0,#3                 ;355
0000aa  e8bd83f8          POP      {r3-r9,pc}
                  |L1.174|
0000ae  6870              LDR      r0,[r6,#4]            ;355
0000b0  f4104f80          TST      r0,#0x4000            ;355
0000b4  d0f2              BEQ      |L1.156|
                  |L1.182|
0000b6  2000              MOVS     r0,#0                 ;364
0000b8  e8bd83f8          POP      {r3-r9,pc}
;;;366    #endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */
                          ENDP

                  |L1.188|
                          DCD      0x40023840
                  |L1.192|
                          DCD      0x40023808
                  |L1.196|
                          DCD      0x42470000
                  |L1.200|
                          DCD      0x40023800
                  |L1.204|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableBkUpReg PROC
;;;182      */
;;;183    HAL_StatusTypeDef HAL_PWREx_DisableBkUpReg(void)
000000  b570              PUSH     {r4-r6,lr}
;;;184    {
;;;185      uint32_t tickstart = 0U;
;;;186    
;;;187      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)DISABLE;
000002  490d              LDR      r1,|L2.56|
000004  2000              MOVS     r0,#0
000006  f8c100a4          STR      r0,[r1,#0xa4]
;;;188    
;;;189      /* Get tick */
;;;190      tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
;;;191    
;;;192      /* Wait till Backup regulator ready flag is set */  
;;;193      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) != RESET)
00000e  4d0b              LDR      r5,|L2.60|
000010  4604              MOV      r4,r0                 ;190
000012  6868              LDR      r0,[r5,#4]
000014  f0100f08          TST      r0,#8
000018  d00c              BEQ      |L2.52|
;;;194      {
;;;195        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
00001a  bf00              NOP      
                  |L2.28|
00001c  f7fffffe          BL       HAL_GetTick
000020  1b00              SUBS     r0,r0,r4
000022  f5b07f7a          CMP      r0,#0x3e8
000026  d901              BLS      |L2.44|
;;;196        {
;;;197          return HAL_TIMEOUT;
000028  2003              MOVS     r0,#3
;;;198        } 
;;;199      }
;;;200      return HAL_OK;
;;;201    }
00002a  bd70              POP      {r4-r6,pc}
                  |L2.44|
00002c  6868              LDR      r0,[r5,#4]            ;193
00002e  f0100f08          TST      r0,#8                 ;193
000032  d1f3              BNE      |L2.28|
                  |L2.52|
000034  2000              MOVS     r0,#0                 ;200
000036  bd70              POP      {r4-r6,pc}
;;;202    
                          ENDP

                  |L2.56|
                          DCD      0x420e0000
                  |L2.60|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_DisableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableFlashPowerDown PROC
;;;215      */
;;;216    void HAL_PWREx_DisableFlashPowerDown(void)
000000  4901              LDR      r1,|L3.8|
;;;217    {
;;;218      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)DISABLE;
000002  2000              MOVS     r0,#0
000004  6248              STR      r0,[r1,#0x24]
;;;219    }
000006  4770              BX       lr
;;;220    
                          ENDP

                  |L3.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWREx_DisableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_DisableOverDrive PROC
;;;497      */
;;;498    HAL_StatusTypeDef HAL_PWREx_DisableOverDrive(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;499    {
;;;500      uint32_t tickstart = 0U;
;;;501      
;;;502      __HAL_RCC_PWR_CLK_ENABLE();
000002  481a              LDR      r0,|L4.108|
000004  2600              MOVS     r6,#0
000006  6801              LDR      r1,[r0,#0]
000008  f0415180          ORR      r1,r1,#0x10000000
00000c  6001              STR      r1,[r0,#0]
00000e  6800              LDR      r0,[r0,#0]
;;;503        
;;;504      /* Disable the Over-drive switch */
;;;505      __HAL_PWR_OVERDRIVESWITCHING_DISABLE();
000010  4f17              LDR      r7,|L4.112|
000012  f0005080          AND      r0,r0,#0x10000000     ;502
000016  9000              STR      r0,[sp,#0]
000018  647e              STR      r6,[r7,#0x44]
;;;506      
;;;507      /* Get tick */
;;;508      tickstart = HAL_GetTick();
00001a  f7fffffe          BL       HAL_GetTick
;;;509     
;;;510      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
00001e  4c15              LDR      r4,|L4.116|
000020  4605              MOV      r5,r0                 ;508
000022  6860              LDR      r0,[r4,#4]
000024  f4103f00          TST      r0,#0x20000
000028  d00a              BEQ      |L4.64|
;;;511      {
;;;512        if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
00002a  bf00              NOP      
                  |L4.44|
00002c  f7fffffe          BL       HAL_GetTick
000030  1b40              SUBS     r0,r0,r5
000032  f5b07f7a          CMP      r0,#0x3e8
000036  d811              BHI      |L4.92|
;;;513        {
;;;514          return HAL_TIMEOUT;
000038  6860              LDR      r0,[r4,#4]
00003a  f4103f00          TST      r0,#0x20000
00003e  d1f5              BNE      |L4.44|
                  |L4.64|
;;;515        }
;;;516      } 
;;;517      
;;;518      /* Disable the Over-drive */
;;;519      __HAL_PWR_OVERDRIVE_DISABLE();
000040  643e              STR      r6,[r7,#0x40]
;;;520    
;;;521      /* Get tick */
;;;522      tickstart = HAL_GetTick();
000042  f7fffffe          BL       HAL_GetTick
000046  4605              MOV      r5,r0
;;;523    
;;;524      while(__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
000048  6860              LDR      r0,[r4,#4]
00004a  f4103f80          TST      r0,#0x10000
00004e  d00b              BEQ      |L4.104|
                  |L4.80|
;;;525      {
;;;526        if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000050  f7fffffe          BL       HAL_GetTick
000054  1b40              SUBS     r0,r0,r5
000056  f5b07f7a          CMP      r0,#0x3e8
00005a  d901              BLS      |L4.96|
                  |L4.92|
;;;527        {
;;;528          return HAL_TIMEOUT;
00005c  2003              MOVS     r0,#3
;;;529        }
;;;530      }
;;;531      
;;;532      return HAL_OK;
;;;533    }
00005e  bdf8              POP      {r3-r7,pc}
                  |L4.96|
000060  6860              LDR      r0,[r4,#4]            ;528
000062  f4103f80          TST      r0,#0x10000           ;528
000066  d1f3              BNE      |L4.80|
                  |L4.104|
000068  2000              MOVS     r0,#0                 ;532
00006a  bdf8              POP      {r3-r7,pc}
;;;534    
                          ENDP

                  |L4.108|
                          DCD      0x40023840
                  |L4.112|
                          DCD      0x420e0000
                  |L4.116|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableBkUpReg||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableBkUpReg PROC
;;;158      */
;;;159    HAL_StatusTypeDef HAL_PWREx_EnableBkUpReg(void)
000000  b570              PUSH     {r4-r6,lr}
;;;160    {
;;;161      uint32_t tickstart = 0U;
;;;162    
;;;163      *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)ENABLE;
000002  490d              LDR      r1,|L5.56|
000004  2001              MOVS     r0,#1
000006  f8c100a4          STR      r0,[r1,#0xa4]
;;;164    
;;;165      /* Get tick */
;;;166      tickstart = HAL_GetTick();
00000a  f7fffffe          BL       HAL_GetTick
;;;167    
;;;168      /* Wait till Backup regulator ready flag is set */  
;;;169      while(__HAL_PWR_GET_FLAG(PWR_FLAG_BRR) == RESET)
00000e  4d0b              LDR      r5,|L5.60|
000010  4604              MOV      r4,r0                 ;166
000012  6868              LDR      r0,[r5,#4]
000014  f0100f08          TST      r0,#8
000018  d10c              BNE      |L5.52|
;;;170      {
;;;171        if((HAL_GetTick() - tickstart ) > PWR_BKPREG_TIMEOUT_VALUE)
00001a  bf00              NOP      
                  |L5.28|
00001c  f7fffffe          BL       HAL_GetTick
000020  1b00              SUBS     r0,r0,r4
000022  f5b07f7a          CMP      r0,#0x3e8
000026  d901              BLS      |L5.44|
;;;172        {
;;;173          return HAL_TIMEOUT;
000028  2003              MOVS     r0,#3
;;;174        } 
;;;175      }
;;;176      return HAL_OK;
;;;177    }
00002a  bd70              POP      {r4-r6,pc}
                  |L5.44|
00002c  6868              LDR      r0,[r5,#4]            ;169
00002e  f0100f08          TST      r0,#8                 ;169
000032  d0f3              BEQ      |L5.28|
                  |L5.52|
000034  2000              MOVS     r0,#0                 ;176
000036  bd70              POP      {r4-r6,pc}
;;;178    
                          ENDP

                  |L5.56|
                          DCD      0x420e0000
                  |L5.60|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnableFlashPowerDown||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableFlashPowerDown PROC
;;;206      */
;;;207    void HAL_PWREx_EnableFlashPowerDown(void)
000000  4901              LDR      r1,|L6.8|
;;;208    {
;;;209      *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)ENABLE;
000002  2001              MOVS     r0,#1
000004  6248              STR      r0,[r1,#0x24]
;;;210    }
000006  4770              BX       lr
;;;211    
                          ENDP

                  |L6.8|
                          DCD      0x420e0000

                          AREA ||i.HAL_PWREx_EnableOverDrive||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnableOverDrive PROC
;;;450      */
;;;451    HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;452    {
;;;453      uint32_t tickstart = 0U;
;;;454    
;;;455      __HAL_RCC_PWR_CLK_ENABLE();
000002  481a              LDR      r0,|L7.108|
000004  6801              LDR      r1,[r0,#0]
000006  f0415180          ORR      r1,r1,#0x10000000
00000a  6001              STR      r1,[r0,#0]
00000c  6800              LDR      r0,[r0,#0]
;;;456      
;;;457      /* Enable the Over-drive to extend the clock frequency to 180 Mhz */
;;;458      __HAL_PWR_OVERDRIVE_ENABLE();
00000e  4f18              LDR      r7,|L7.112|
000010  f0005080          AND      r0,r0,#0x10000000     ;455
000014  2601              MOVS     r6,#1
000016  9000              STR      r0,[sp,#0]
000018  643e              STR      r6,[r7,#0x40]
;;;459    
;;;460      /* Get tick */
;;;461      tickstart = HAL_GetTick();
00001a  f7fffffe          BL       HAL_GetTick
;;;462    
;;;463      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
00001e  4c15              LDR      r4,|L7.116|
000020  4605              MOV      r5,r0                 ;461
000022  6860              LDR      r0,[r4,#4]
000024  f4103f80          TST      r0,#0x10000
000028  d10a              BNE      |L7.64|
;;;464      {
;;;465        if((HAL_GetTick() - tickstart) > PWR_OVERDRIVE_TIMEOUT_VALUE)
00002a  bf00              NOP      
                  |L7.44|
00002c  f7fffffe          BL       HAL_GetTick
000030  1b40              SUBS     r0,r0,r5
000032  f5b07f7a          CMP      r0,#0x3e8
000036  d811              BHI      |L7.92|
;;;466        {
;;;467          return HAL_TIMEOUT;
000038  6860              LDR      r0,[r4,#4]
00003a  f4103f80          TST      r0,#0x10000
00003e  d0f5              BEQ      |L7.44|
                  |L7.64|
;;;468        }
;;;469      }
;;;470      
;;;471      /* Enable the Over-drive switch */
;;;472      __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
000040  647e              STR      r6,[r7,#0x44]
;;;473    
;;;474      /* Get tick */
;;;475      tickstart = HAL_GetTick();
000042  f7fffffe          BL       HAL_GetTick
000046  4605              MOV      r5,r0
;;;476    
;;;477      while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
000048  6860              LDR      r0,[r4,#4]
00004a  f4103f00          TST      r0,#0x20000
00004e  d10b              BNE      |L7.104|
                  |L7.80|
;;;478      {
;;;479        if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
000050  f7fffffe          BL       HAL_GetTick
000054  1b40              SUBS     r0,r0,r5
000056  f5b07f7a          CMP      r0,#0x3e8
00005a  d901              BLS      |L7.96|
                  |L7.92|
;;;480        {
;;;481          return HAL_TIMEOUT;
00005c  2003              MOVS     r0,#3
;;;482        }
;;;483      } 
;;;484      return HAL_OK;
;;;485    }
00005e  bdf8              POP      {r3-r7,pc}
                  |L7.96|
000060  6860              LDR      r0,[r4,#4]            ;481
000062  f4103f00          TST      r0,#0x20000           ;481
000066  d0f3              BEQ      |L7.80|
                  |L7.104|
000068  2000              MOVS     r0,#0                 ;484
00006a  bdf8              POP      {r3-r7,pc}
;;;486    
                          ENDP

                  |L7.108|
                          DCD      0x40023840
                  |L7.112|
                          DCD      0x420e0000
                  |L7.116|
                          DCD      0x40007000

                          AREA ||i.HAL_PWREx_EnterUnderDriveSTOPMode||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_EnterUnderDriveSTOPMode PROC
;;;573      */
;;;574    HAL_StatusTypeDef HAL_PWREx_EnterUnderDriveSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
000000  4a14              LDR      r2,|L8.84|
;;;575    {
000002  b081              SUB      sp,sp,#4
;;;576      uint32_t tmpreg1 = 0U;
;;;577    
;;;578      /* Check the parameters */
;;;579      assert_param(IS_PWR_REGULATOR_UNDERDRIVE(Regulator));
;;;580      assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
;;;581      
;;;582      /* Enable Power ctrl clock */
;;;583      __HAL_RCC_PWR_CLK_ENABLE();
000004  6813              LDR      r3,[r2,#0]
000006  f0435380          ORR      r3,r3,#0x10000000
00000a  6013              STR      r3,[r2,#0]
00000c  6812              LDR      r2,[r2,#0]
00000e  f0025280          AND      r2,r2,#0x10000000
;;;584      /* Enable the Under-drive Mode ---------------------------------------------*/
;;;585      /* Clear Under-drive flag */
;;;586      __HAL_PWR_CLEAR_ODRUDR_FLAG();
000012  9200              STR      r2,[sp,#0]
000014  4a10              LDR      r2,|L8.88|
000016  6853              LDR      r3,[r2,#4]
000018  f4432340          ORR      r3,r3,#0xc0000
00001c  6053              STR      r3,[r2,#4]
;;;587      
;;;588      /* Enable the Under-drive */ 
;;;589      __HAL_PWR_UNDERDRIVE_ENABLE();
00001e  6813              LDR      r3,[r2,#0]
000020  f4432340          ORR      r3,r3,#0xc0000
000024  6013              STR      r3,[r2,#0]
;;;590    
;;;591      /* Select the regulator state in STOP mode ---------------------------------*/
;;;592      tmpreg1 = PWR->CR;
000026  6813              LDR      r3,[r2,#0]
;;;593      /* Clear PDDS, LPDS, MRLUDS and LPLUDS bits */
;;;594      tmpreg1 &= (uint32_t)~(PWR_CR_PDDS | PWR_CR_LPDS | PWR_CR_LPUDS | PWR_CR_MRUDS);
000028  f0230303          BIC      r3,r3,#3
00002c  f4236340          BIC      r3,r3,#0xc00
;;;595      
;;;596      /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
;;;597      tmpreg1 |= Regulator;
000030  4318              ORRS     r0,r0,r3
;;;598      
;;;599      /* Store the new value */
;;;600      PWR->CR = tmpreg1;
000032  6010              STR      r0,[r2,#0]
;;;601      
;;;602      /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;603      SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000034  4809              LDR      r0,|L8.92|
000036  6802              LDR      r2,[r0,#0]
000038  f0420204          ORR      r2,r2,#4
00003c  6002              STR      r2,[r0,#0]
;;;604      
;;;605      /* Select STOP mode entry --------------------------------------------------*/
;;;606      if(STOPEntry == PWR_SLEEPENTRY_WFI)
00003e  2901              CMP      r1,#1
;;;607      {   
;;;608        /* Request Wait For Interrupt */
;;;609        __WFI();
000040  bf0c              ITE      EQ
000042  bf30              WFIEQ    
;;;610      }
;;;611      else
;;;612      {
;;;613        /* Request Wait For Event */
;;;614        __WFE();
000044  bf20              WFENE    
;;;615      }
;;;616      /* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;617      SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);
000046  6801              LDR      r1,[r0,#0]
000048  f0210104          BIC      r1,r1,#4
00004c  6001              STR      r1,[r0,#0]
;;;618    
;;;619      return HAL_OK;  
00004e  2000              MOVS     r0,#0
;;;620    }
000050  b001              ADD      sp,sp,#4
000052  4770              BX       lr
;;;621    
                          ENDP

                  |L8.84|
                          DCD      0x40023840
                  |L8.88|
                          DCD      0x40007000
                  |L8.92|
                          DCD      0xe000ed10

                          AREA ||i.HAL_PWREx_GetVoltageRange||, CODE, READONLY, ALIGN=2

                  HAL_PWREx_GetVoltageRange PROC
;;;228      */  
;;;229    uint32_t HAL_PWREx_GetVoltageRange(void)
000000  4802              LDR      r0,|L9.12|
;;;230    {
;;;231      return (PWR->CR & PWR_CR_VOS);
000002  6800              LDR      r0,[r0,#0]
000004  f4004040          AND      r0,r0,#0xc000
;;;232    }
000008  4770              BX       lr
;;;233    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_hal_pwr_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REVSH|
#line 402
|__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____RRX|
#line 587
|__asm___22_stm32f4xx_hal_pwr_ex_c_1028ebfa____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
