; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --split_sections --debug -c --asm --interleave -ostm32nes\stm32f4xx_ll_tim.o --depend=stm32nes\stm32f4xx_ll_tim.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 --diag_suppress=9931 -I../Inc -I../Drivers/STM32F4xx_HAL_Driver/Inc -I../Drivers/CMSIS/Device/ST/STM32F4xx/Include -I../Drivers/CMSIS/Include -I../Drivers/STM32F4xx_HAL_Driver/Inc/Legacy -I.\RTE\_stm32nes -ID:\Keil_v5\Arm\Packs\ARM\CMSIS\5.8.0\CMSIS\Core\Include -ID:\Keil_v5\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=531 -D_RTE_ -DSTM32F429xx -D_RTE_ -DUSE_FULL_LL_DRIVER -DSTM32F429xx -DUSE_HAL_DRIVER --omf_browse=stm32nes\stm32f4xx_ll_tim.crf ../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_tim.c]
                          THUMB

                          AREA ||i.IC1Config||, CODE, READONLY, ALIGN=1

                  IC1Config PROC
;;;1054     */
;;;1055   static ErrorStatus IC1Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
000000  4602              MOV      r2,r0
;;;1056   {
;;;1057     /* Check the parameters */
;;;1058     assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;1059     assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
;;;1060     assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
;;;1061     assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
;;;1062     assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
;;;1063   
;;;1064     /* Disable the Channel 1: Reset the CC1E Bit */
;;;1065     TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
000002  6a10              LDR      r0,[r2,#0x20]
000004  f0200001          BIC      r0,r0,#1
000008  6210              STR      r0,[r2,#0x20]
;;;1066   
;;;1067     /* Select the Input and set the filter and the prescaler value */
;;;1068     MODIFY_REG(TIMx->CCMR1,
00000a  68cb              LDR      r3,[r1,#0xc]
00000c  6848              LDR      r0,[r1,#4]
00000e  4318              ORRS     r0,r0,r3
000010  688b              LDR      r3,[r1,#8]
000012  4318              ORRS     r0,r0,r3
000014  6993              LDR      r3,[r2,#0x18]
000016  f02303ff          BIC      r3,r3,#0xff
00001a  ea434010          ORR      r0,r3,r0,LSR #16
00001e  6190              STR      r0,[r2,#0x18]
;;;1069                (TIM_CCMR1_CC1S | TIM_CCMR1_IC1F | TIM_CCMR1_IC1PSC),
;;;1070                (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 16U);
;;;1071   
;;;1072     /* Select the Polarity and set the CC1E Bit */
;;;1073     MODIFY_REG(TIMx->CCER,
000020  6a10              LDR      r0,[r2,#0x20]
000022  f020000a          BIC      r0,r0,#0xa
000026  680b              LDR      r3,[r1,#0]
000028  f0430301          ORR      r3,r3,#1
00002c  4318              ORRS     r0,r0,r3
00002e  6210              STR      r0,[r2,#0x20]
;;;1074                (TIM_CCER_CC1P | TIM_CCER_CC1NP),
;;;1075                (TIM_ICInitStruct->ICPolarity | TIM_CCER_CC1E));
;;;1076   
;;;1077     return SUCCESS;
000030  2001              MOVS     r0,#1
;;;1078   }
000032  4770              BX       lr
;;;1079   
                          ENDP


                          AREA ||i.IC2Config||, CODE, READONLY, ALIGN=1

                  IC2Config PROC
;;;1087     */
;;;1088   static ErrorStatus IC2Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
000000  b510              PUSH     {r4,lr}
;;;1089   {
000002  4602              MOV      r2,r0
;;;1090     /* Check the parameters */
;;;1091     assert_param(IS_TIM_CC2_INSTANCE(TIMx));
;;;1092     assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
;;;1093     assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
;;;1094     assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
;;;1095     assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
;;;1096   
;;;1097     /* Disable the Channel 2: Reset the CC2E Bit */
;;;1098     TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;
000004  6a10              LDR      r0,[r2,#0x20]
000006  f0200010          BIC      r0,r0,#0x10
00000a  6210              STR      r0,[r2,#0x20]
;;;1099   
;;;1100     /* Select the Input and set the filter and the prescaler value */
;;;1101     MODIFY_REG(TIMx->CCMR1,
00000c  68cb              LDR      r3,[r1,#0xc]
00000e  6848              LDR      r0,[r1,#4]
000010  4318              ORRS     r0,r0,r3
000012  688b              LDR      r3,[r1,#8]
000014  4318              ORRS     r0,r0,r3
000016  6993              LDR      r3,[r2,#0x18]
000018  f423437f          BIC      r3,r3,#0xff00
00001c  ea432010          ORR      r0,r3,r0,LSR #8
000020  6190              STR      r0,[r2,#0x18]
;;;1102                (TIM_CCMR1_CC2S | TIM_CCMR1_IC2F | TIM_CCMR1_IC2PSC),
;;;1103                (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 8U);
;;;1104   
;;;1105     /* Select the Polarity and set the CC2E Bit */
;;;1106     MODIFY_REG(TIMx->CCER,
000022  6a10              LDR      r0,[r2,#0x20]
000024  f02000a0          BIC      r0,r0,#0xa0
000028  2410              MOVS     r4,#0x10
00002a  680b              LDR      r3,[r1,#0]
00002c  ea441303          ORR      r3,r4,r3,LSL #4
000030  4318              ORRS     r0,r0,r3
000032  6210              STR      r0,[r2,#0x20]
;;;1107                (TIM_CCER_CC2P | TIM_CCER_CC2NP),
;;;1108                ((TIM_ICInitStruct->ICPolarity << 4U) | TIM_CCER_CC2E));
;;;1109   
;;;1110     return SUCCESS;
000034  2001              MOVS     r0,#1
;;;1111   }
000036  bd10              POP      {r4,pc}
;;;1112   
                          ENDP


                          AREA ||i.IC3Config||, CODE, READONLY, ALIGN=1

                  IC3Config PROC
;;;1120     */
;;;1121   static ErrorStatus IC3Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
000000  b510              PUSH     {r4,lr}
;;;1122   {
000002  4602              MOV      r2,r0
;;;1123     /* Check the parameters */
;;;1124     assert_param(IS_TIM_CC3_INSTANCE(TIMx));
;;;1125     assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
;;;1126     assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
;;;1127     assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
;;;1128     assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
;;;1129   
;;;1130     /* Disable the Channel 3: Reset the CC3E Bit */
;;;1131     TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
000004  6a10              LDR      r0,[r2,#0x20]
000006  f4207080          BIC      r0,r0,#0x100
00000a  6210              STR      r0,[r2,#0x20]
;;;1132   
;;;1133     /* Select the Input and set the filter and the prescaler value */
;;;1134     MODIFY_REG(TIMx->CCMR2,
00000c  68cb              LDR      r3,[r1,#0xc]
00000e  6848              LDR      r0,[r1,#4]
000010  4318              ORRS     r0,r0,r3
000012  688b              LDR      r3,[r1,#8]
000014  4318              ORRS     r0,r0,r3
000016  69d3              LDR      r3,[r2,#0x1c]
000018  f02303ff          BIC      r3,r3,#0xff
00001c  ea434010          ORR      r0,r3,r0,LSR #16
000020  61d0              STR      r0,[r2,#0x1c]
;;;1135                (TIM_CCMR2_CC3S | TIM_CCMR2_IC3F | TIM_CCMR2_IC3PSC),
;;;1136                (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 16U);
;;;1137   
;;;1138     /* Select the Polarity and set the CC3E Bit */
;;;1139     MODIFY_REG(TIMx->CCER,
000022  6a10              LDR      r0,[r2,#0x20]
000024  f4206020          BIC      r0,r0,#0xa00
000028  f44f7480          MOV      r4,#0x100
00002c  680b              LDR      r3,[r1,#0]
00002e  ea442303          ORR      r3,r4,r3,LSL #8
000032  4318              ORRS     r0,r0,r3
000034  6210              STR      r0,[r2,#0x20]
;;;1140                (TIM_CCER_CC3P | TIM_CCER_CC3NP),
;;;1141                ((TIM_ICInitStruct->ICPolarity << 8U) | TIM_CCER_CC3E));
;;;1142   
;;;1143     return SUCCESS;
000036  2001              MOVS     r0,#1
;;;1144   }
000038  bd10              POP      {r4,pc}
;;;1145   
                          ENDP


                          AREA ||i.IC4Config||, CODE, READONLY, ALIGN=1

                  IC4Config PROC
;;;1153     */
;;;1154   static ErrorStatus IC4Config(TIM_TypeDef *TIMx, LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
000000  b510              PUSH     {r4,lr}
;;;1155   {
000002  4602              MOV      r2,r0
;;;1156     /* Check the parameters */
;;;1157     assert_param(IS_TIM_CC4_INSTANCE(TIMx));
;;;1158     assert_param(IS_LL_TIM_IC_POLARITY(TIM_ICInitStruct->ICPolarity));
;;;1159     assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_ICInitStruct->ICActiveInput));
;;;1160     assert_param(IS_LL_TIM_ICPSC(TIM_ICInitStruct->ICPrescaler));
;;;1161     assert_param(IS_LL_TIM_IC_FILTER(TIM_ICInitStruct->ICFilter));
;;;1162   
;;;1163     /* Disable the Channel 4: Reset the CC4E Bit */
;;;1164     TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
000004  6a10              LDR      r0,[r2,#0x20]
000006  f4205080          BIC      r0,r0,#0x1000
00000a  6210              STR      r0,[r2,#0x20]
;;;1165   
;;;1166     /* Select the Input and set the filter and the prescaler value */
;;;1167     MODIFY_REG(TIMx->CCMR2,
00000c  68cb              LDR      r3,[r1,#0xc]
00000e  6848              LDR      r0,[r1,#4]
000010  4318              ORRS     r0,r0,r3
000012  688b              LDR      r3,[r1,#8]
000014  4318              ORRS     r0,r0,r3
000016  69d3              LDR      r3,[r2,#0x1c]
000018  f423437f          BIC      r3,r3,#0xff00
00001c  ea432010          ORR      r0,r3,r0,LSR #8
000020  61d0              STR      r0,[r2,#0x1c]
;;;1168                (TIM_CCMR2_CC4S | TIM_CCMR2_IC4F | TIM_CCMR2_IC4PSC),
;;;1169                (TIM_ICInitStruct->ICActiveInput | TIM_ICInitStruct->ICFilter | TIM_ICInitStruct->ICPrescaler) >> 8U);
;;;1170   
;;;1171     /* Select the Polarity and set the CC2E Bit */
;;;1172     MODIFY_REG(TIMx->CCER,
000022  6a10              LDR      r0,[r2,#0x20]
000024  f4204020          BIC      r0,r0,#0xa000
000028  f44f5480          MOV      r4,#0x1000
00002c  680b              LDR      r3,[r1,#0]
00002e  ea443303          ORR      r3,r4,r3,LSL #12
000032  4318              ORRS     r0,r0,r3
000034  6210              STR      r0,[r2,#0x20]
;;;1173                (TIM_CCER_CC4P | TIM_CCER_CC4NP),
;;;1174                ((TIM_ICInitStruct->ICPolarity << 12U) | TIM_CCER_CC4E));
;;;1175   
;;;1176     return SUCCESS;
000036  2001              MOVS     r0,#1
;;;1177   }
000038  bd10              POP      {r4,pc}
;;;1178   
                          ENDP


                          AREA ||i.LL_APB1_GRP1_ForceReset||, CODE, READONLY, ALIGN=2

                  LL_APB1_GRP1_ForceReset PROC
;;;1426   */
;;;1427   __STATIC_INLINE void LL_APB1_GRP1_ForceReset(uint32_t Periphs)
000000  4902              LDR      r1,|L5.12|
;;;1428   {
;;;1429     SET_BIT(RCC->APB1RSTR, Periphs);
000002  6809              LDR      r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L5.12|
000008  6011              STR      r1,[r2,#0]
;;;1430   }
00000a  4770              BX       lr
;;;1431   
                          ENDP

                  |L5.12|
                          DCD      0x40023820

                          AREA ||i.LL_APB1_GRP1_ReleaseReset||, CODE, READONLY, ALIGN=2

                  LL_APB1_GRP1_ReleaseReset PROC
;;;1498   */
;;;1499   __STATIC_INLINE void LL_APB1_GRP1_ReleaseReset(uint32_t Periphs)
000000  4902              LDR      r1,|L6.12|
;;;1500   {
;;;1501     CLEAR_BIT(RCC->APB1RSTR, Periphs);
000002  6809              LDR      r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L6.12|
000008  6011              STR      r1,[r2,#0]
;;;1502   }
00000a  4770              BX       lr
;;;1503   
                          ENDP

                  |L6.12|
                          DCD      0x40023820

                          AREA ||i.LL_APB2_GRP1_ForceReset||, CODE, READONLY, ALIGN=2

                  LL_APB2_GRP1_ForceReset PROC
;;;1906   */
;;;1907   __STATIC_INLINE void LL_APB2_GRP1_ForceReset(uint32_t Periphs)
000000  4902              LDR      r1,|L7.12|
;;;1908   {
;;;1909     SET_BIT(RCC->APB2RSTR, Periphs);
000002  6809              LDR      r1,[r1,#0]
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L7.12|
000008  6011              STR      r1,[r2,#0]
;;;1910   }
00000a  4770              BX       lr
;;;1911   
                          ENDP

                  |L7.12|
                          DCD      0x40023824

                          AREA ||i.LL_APB2_GRP1_ReleaseReset||, CODE, READONLY, ALIGN=2

                  LL_APB2_GRP1_ReleaseReset PROC
;;;1964   */
;;;1965   __STATIC_INLINE void LL_APB2_GRP1_ReleaseReset(uint32_t Periphs)
000000  4902              LDR      r1,|L8.12|
;;;1966   {
;;;1967     CLEAR_BIT(RCC->APB2RSTR, Periphs);
000002  6809              LDR      r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L8.12|
000008  6011              STR      r1,[r2,#0]
;;;1968   }
00000a  4770              BX       lr
;;;1969   
                          ENDP

                  |L8.12|
                          DCD      0x40023824

                          AREA ||i.LL_TIM_BDTR_Init||, CODE, READONLY, ALIGN=1

                  LL_TIM_BDTR_Init PROC
;;;695      */
;;;696    ErrorStatus LL_TIM_BDTR_Init(TIM_TypeDef *TIMx, LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)
000000  b510              PUSH     {r4,lr}
;;;697    {
000002  4603              MOV      r3,r0
000004  460a              MOV      r2,r1
;;;698      uint32_t tmpbdtr = 0;
000006  2100              MOVS     r1,#0
;;;699    
;;;700      /* Check the parameters */
;;;701      assert_param(IS_TIM_BREAK_INSTANCE(TIMx));
;;;702      assert_param(IS_LL_TIM_OSSR_STATE(TIM_BDTRInitStruct->OSSRState));
;;;703      assert_param(IS_LL_TIM_OSSI_STATE(TIM_BDTRInitStruct->OSSIState));
;;;704      assert_param(IS_LL_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->LockLevel));
;;;705      assert_param(IS_LL_TIM_BREAK_STATE(TIM_BDTRInitStruct->BreakState));
;;;706      assert_param(IS_LL_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->BreakPolarity));
;;;707      assert_param(IS_LL_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->AutomaticOutput));
;;;708    
;;;709      /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;710      the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;711    
;;;712      /* Set the BDTR bits */
;;;713      MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, TIM_BDTRInitStruct->DeadTime);
000008  7b14              LDRB     r4,[r2,#0xc]
00000a  4621              MOV      r1,r4
;;;714      MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, TIM_BDTRInitStruct->LockLevel);
00000c  6890              LDR      r0,[r2,#8]
00000e  4301              ORRS     r1,r1,r0
;;;715      MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, TIM_BDTRInitStruct->OSSIState);
000010  f4216080          BIC      r0,r1,#0x400
000014  6854              LDR      r4,[r2,#4]
000016  ea400104          ORR      r1,r0,r4
;;;716      MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, TIM_BDTRInitStruct->OSSRState);
00001a  f4216000          BIC      r0,r1,#0x800
00001e  6814              LDR      r4,[r2,#0]
000020  ea400104          ORR      r1,r0,r4
;;;717      MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, TIM_BDTRInitStruct->BreakState);
000024  f4215080          BIC      r0,r1,#0x1000
000028  89d4              LDRH     r4,[r2,#0xe]
00002a  ea400104          ORR      r1,r0,r4
;;;718      MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, TIM_BDTRInitStruct->BreakPolarity);
00002e  f4215000          BIC      r0,r1,#0x2000
000032  6914              LDR      r4,[r2,#0x10]
000034  ea400104          ORR      r1,r0,r4
;;;719      MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, TIM_BDTRInitStruct->AutomaticOutput);
000038  f4214080          BIC      r0,r1,#0x4000
00003c  6954              LDR      r4,[r2,#0x14]
00003e  ea400104          ORR      r1,r0,r4
;;;720      MODIFY_REG(tmpbdtr, TIM_BDTR_MOE, TIM_BDTRInitStruct->AutomaticOutput);
000042  f4214000          BIC      r0,r1,#0x8000
000046  6954              LDR      r4,[r2,#0x14]
000048  ea400104          ORR      r1,r0,r4
;;;721    
;;;722      /* Set TIMx_BDTR */
;;;723      LL_TIM_WriteReg(TIMx, BDTR, tmpbdtr);
00004c  6459              STR      r1,[r3,#0x44]
;;;724    
;;;725      return SUCCESS;
00004e  2001              MOVS     r0,#1
;;;726    }
000050  bd10              POP      {r4,pc}
;;;727    /**
                          ENDP


                          AREA ||i.LL_TIM_BDTR_StructInit||, CODE, READONLY, ALIGN=1

                  LL_TIM_BDTR_StructInit PROC
;;;670      */
;;;671    void LL_TIM_BDTR_StructInit(LL_TIM_BDTR_InitTypeDef *TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;672    {
;;;673      /* Set the default configuration */
;;;674      TIM_BDTRInitStruct->OSSRState       = LL_TIM_OSSR_DISABLE;
000002  6001              STR      r1,[r0,#0]
;;;675      TIM_BDTRInitStruct->OSSIState       = LL_TIM_OSSI_DISABLE;
000004  6041              STR      r1,[r0,#4]
;;;676      TIM_BDTRInitStruct->LockLevel       = LL_TIM_LOCKLEVEL_OFF;
000006  6081              STR      r1,[r0,#8]
;;;677      TIM_BDTRInitStruct->DeadTime        = (uint8_t)0x00U;
000008  7301              STRB     r1,[r0,#0xc]
;;;678      TIM_BDTRInitStruct->BreakState      = LL_TIM_BREAK_DISABLE;
00000a  81c1              STRH     r1,[r0,#0xe]
;;;679      TIM_BDTRInitStruct->BreakPolarity   = LL_TIM_BREAK_POLARITY_LOW;
00000c  6101              STR      r1,[r0,#0x10]
;;;680      TIM_BDTRInitStruct->AutomaticOutput = LL_TIM_AUTOMATICOUTPUT_DISABLE;
00000e  6141              STR      r1,[r0,#0x14]
;;;681    }
000010  4770              BX       lr
;;;682    
                          ENDP


                          AREA ||i.LL_TIM_DeInit||, CODE, READONLY, ALIGN=2

                  LL_TIM_DeInit PROC
;;;184      */
;;;185    ErrorStatus LL_TIM_DeInit(TIM_TypeDef *TIMx)
000000  b570              PUSH     {r4-r6,lr}
;;;186    {
000002  4604              MOV      r4,r0
;;;187      ErrorStatus result = SUCCESS;
000004  2501              MOVS     r5,#1
;;;188    
;;;189      /* Check the parameters */
;;;190      assert_param(IS_TIM_INSTANCE(TIMx));
;;;191    
;;;192      if (TIMx == TIM1)
000006  484a              LDR      r0,|L11.304|
000008  4284              CMP      r4,r0
00000a  d106              BNE      |L11.26|
;;;193      {
;;;194        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM1);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       LL_APB2_GRP1_ForceReset
;;;195        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM1);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       LL_APB2_GRP1_ReleaseReset
000018  e088              B        |L11.300|
                  |L11.26|
;;;196      }
;;;197    #if defined(TIM2)
;;;198      else if (TIMx == TIM2)
00001a  f1b44f80          CMP      r4,#0x40000000
00001e  d106              BNE      |L11.46|
;;;199      {
;;;200        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM2);
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;201        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM2);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
00002c  e07e              B        |L11.300|
                  |L11.46|
;;;202      }
;;;203    #endif
;;;204    #if defined(TIM3)
;;;205      else if (TIMx == TIM3)
00002e  4841              LDR      r0,|L11.308|
000030  4284              CMP      r4,r0
000032  d106              BNE      |L11.66|
;;;206      {
;;;207        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM3);
000034  2002              MOVS     r0,#2
000036  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;208        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM3);
00003a  2002              MOVS     r0,#2
00003c  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
000040  e074              B        |L11.300|
                  |L11.66|
;;;209      }
;;;210    #endif
;;;211    #if defined(TIM4)
;;;212      else if (TIMx == TIM4)
000042  483d              LDR      r0,|L11.312|
000044  4284              CMP      r4,r0
000046  d106              BNE      |L11.86|
;;;213      {
;;;214        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM4);
000048  2004              MOVS     r0,#4
00004a  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;215        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM4);
00004e  2004              MOVS     r0,#4
000050  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
000054  e06a              B        |L11.300|
                  |L11.86|
;;;216      }
;;;217    #endif
;;;218    #if defined(TIM5)
;;;219      else if (TIMx == TIM5)
000056  4839              LDR      r0,|L11.316|
000058  4284              CMP      r4,r0
00005a  d106              BNE      |L11.106|
;;;220      {
;;;221        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM5);
00005c  2008              MOVS     r0,#8
00005e  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;222        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM5);
000062  2008              MOVS     r0,#8
000064  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
000068  e060              B        |L11.300|
                  |L11.106|
;;;223      }
;;;224    #endif
;;;225    #if defined(TIM6)
;;;226      else if (TIMx == TIM6)
00006a  4835              LDR      r0,|L11.320|
00006c  4284              CMP      r4,r0
00006e  d106              BNE      |L11.126|
;;;227      {
;;;228        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM6);
000070  2010              MOVS     r0,#0x10
000072  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;229        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM6);
000076  2010              MOVS     r0,#0x10
000078  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
00007c  e056              B        |L11.300|
                  |L11.126|
;;;230      }
;;;231    #endif
;;;232    #if defined (TIM7)
;;;233      else if (TIMx == TIM7)
00007e  4831              LDR      r0,|L11.324|
000080  4284              CMP      r4,r0
000082  d106              BNE      |L11.146|
;;;234      {
;;;235        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM7);
000084  2020              MOVS     r0,#0x20
000086  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;236        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM7);
00008a  2020              MOVS     r0,#0x20
00008c  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
000090  e04c              B        |L11.300|
                  |L11.146|
;;;237      }
;;;238    #endif
;;;239    #if defined(TIM8)
;;;240      else if (TIMx == TIM8)
000092  482d              LDR      r0,|L11.328|
000094  4284              CMP      r4,r0
000096  d106              BNE      |L11.166|
;;;241      {
;;;242        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM8);
000098  2002              MOVS     r0,#2
00009a  f7fffffe          BL       LL_APB2_GRP1_ForceReset
;;;243        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM8);
00009e  2002              MOVS     r0,#2
0000a0  f7fffffe          BL       LL_APB2_GRP1_ReleaseReset
0000a4  e042              B        |L11.300|
                  |L11.166|
;;;244      }
;;;245    #endif
;;;246    #if defined(TIM9)
;;;247      else if (TIMx == TIM9)
0000a6  4829              LDR      r0,|L11.332|
0000a8  4284              CMP      r4,r0
0000aa  d108              BNE      |L11.190|
;;;248      {
;;;249        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM9);
0000ac  f44f3080          MOV      r0,#0x10000
0000b0  f7fffffe          BL       LL_APB2_GRP1_ForceReset
;;;250        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM9);
0000b4  f44f3080          MOV      r0,#0x10000
0000b8  f7fffffe          BL       LL_APB2_GRP1_ReleaseReset
0000bc  e036              B        |L11.300|
                  |L11.190|
;;;251      }
;;;252    #endif
;;;253    #if defined(TIM10)
;;;254      else if (TIMx == TIM10)
0000be  4824              LDR      r0,|L11.336|
0000c0  4284              CMP      r4,r0
0000c2  d108              BNE      |L11.214|
;;;255      {
;;;256        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM10);
0000c4  f44f3000          MOV      r0,#0x20000
0000c8  f7fffffe          BL       LL_APB2_GRP1_ForceReset
;;;257        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM10);
0000cc  f44f3000          MOV      r0,#0x20000
0000d0  f7fffffe          BL       LL_APB2_GRP1_ReleaseReset
0000d4  e02a              B        |L11.300|
                  |L11.214|
;;;258      }
;;;259    #endif
;;;260    #if defined(TIM11)
;;;261      else if (TIMx == TIM11)
0000d6  481f              LDR      r0,|L11.340|
0000d8  4284              CMP      r4,r0
0000da  d108              BNE      |L11.238|
;;;262      {
;;;263        LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_TIM11);
0000dc  f44f2080          MOV      r0,#0x40000
0000e0  f7fffffe          BL       LL_APB2_GRP1_ForceReset
;;;264        LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_TIM11);
0000e4  f44f2080          MOV      r0,#0x40000
0000e8  f7fffffe          BL       LL_APB2_GRP1_ReleaseReset
0000ec  e01e              B        |L11.300|
                  |L11.238|
;;;265      }
;;;266    #endif
;;;267    #if defined(TIM12)
;;;268      else if (TIMx == TIM12)
0000ee  481a              LDR      r0,|L11.344|
0000f0  4284              CMP      r4,r0
0000f2  d106              BNE      |L11.258|
;;;269      {
;;;270        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM12);
0000f4  2040              MOVS     r0,#0x40
0000f6  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;271        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM12);
0000fa  2040              MOVS     r0,#0x40
0000fc  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
000100  e014              B        |L11.300|
                  |L11.258|
;;;272      }
;;;273    #endif
;;;274    #if defined(TIM13)
;;;275      else if (TIMx == TIM13)
000102  4816              LDR      r0,|L11.348|
000104  4284              CMP      r4,r0
000106  d106              BNE      |L11.278|
;;;276      {
;;;277        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM13);
000108  2080              MOVS     r0,#0x80
00010a  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;278        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM13);
00010e  2080              MOVS     r0,#0x80
000110  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
000114  e00a              B        |L11.300|
                  |L11.278|
;;;279      }
;;;280    #endif
;;;281    #if defined(TIM14)
;;;282      else if (TIMx == TIM14)
000116  4812              LDR      r0,|L11.352|
000118  4284              CMP      r4,r0
00011a  d106              BNE      |L11.298|
;;;283      {
;;;284        LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_TIM14);
00011c  1580              ASRS     r0,r0,#22
00011e  f7fffffe          BL       LL_APB1_GRP1_ForceReset
;;;285        LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_TIM14);
000122  15a0              ASRS     r0,r4,#22
000124  f7fffffe          BL       LL_APB1_GRP1_ReleaseReset
000128  e000              B        |L11.300|
                  |L11.298|
;;;286      }
;;;287    #endif
;;;288      else
;;;289      {
;;;290        result = ERROR;
00012a  2500              MOVS     r5,#0
                  |L11.300|
;;;291      }
;;;292    
;;;293      return result;
00012c  4628              MOV      r0,r5
;;;294    }
00012e  bd70              POP      {r4-r6,pc}
;;;295    
                          ENDP

                  |L11.304|
                          DCD      0x40010000
                  |L11.308|
                          DCD      0x40000400
                  |L11.312|
                          DCD      0x40000800
                  |L11.316|
                          DCD      0x40000c00
                  |L11.320|
                          DCD      0x40001000
                  |L11.324|
                          DCD      0x40001400
                  |L11.328|
                          DCD      0x40010400
                  |L11.332|
                          DCD      0x40014000
                  |L11.336|
                          DCD      0x40014400
                  |L11.340|
                          DCD      0x40014800
                  |L11.344|
                          DCD      0x40001800
                  |L11.348|
                          DCD      0x40001c00
                  |L11.352|
                          DCD      0x40002000

                          AREA ||i.LL_TIM_ENCODER_Init||, CODE, READONLY, ALIGN=1

                  LL_TIM_ENCODER_Init PROC
;;;501      */
;;;502    ErrorStatus LL_TIM_ENCODER_Init(TIM_TypeDef *TIMx, LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;503    {
000002  4602              MOV      r2,r0
;;;504      uint32_t tmpccmr1 = 0U;
000004  2300              MOVS     r3,#0
;;;505      uint32_t tmpccer = 0U;
000006  2400              MOVS     r4,#0
;;;506    
;;;507      /* Check the parameters */
;;;508      assert_param(IS_TIM_ENCODER_INTERFACE_INSTANCE(TIMx));
;;;509      assert_param(IS_LL_TIM_ENCODERMODE(TIM_EncoderInitStruct->EncoderMode));
;;;510      assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_EncoderInitStruct->IC1Polarity));
;;;511      assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_EncoderInitStruct->IC1ActiveInput));
;;;512      assert_param(IS_LL_TIM_ICPSC(TIM_EncoderInitStruct->IC1Prescaler));
;;;513      assert_param(IS_LL_TIM_IC_FILTER(TIM_EncoderInitStruct->IC1Filter));
;;;514      assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_EncoderInitStruct->IC2Polarity));
;;;515      assert_param(IS_LL_TIM_ACTIVEINPUT(TIM_EncoderInitStruct->IC2ActiveInput));
;;;516      assert_param(IS_LL_TIM_ICPSC(TIM_EncoderInitStruct->IC2Prescaler));
;;;517      assert_param(IS_LL_TIM_IC_FILTER(TIM_EncoderInitStruct->IC2Filter));
;;;518    
;;;519      /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */
;;;520      TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);
000008  6a10              LDR      r0,[r2,#0x20]
00000a  f0200011          BIC      r0,r0,#0x11
00000e  6210              STR      r0,[r2,#0x20]
;;;521    
;;;522      /* Get the TIMx CCMR1 register value */
;;;523      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
000010  6993              LDR      r3,[r2,#0x18]
;;;524    
;;;525      /* Get the TIMx CCER register value */
;;;526      tmpccer = LL_TIM_ReadReg(TIMx, CCER);
000012  6a14              LDR      r4,[r2,#0x20]
;;;527    
;;;528      /* Configure TI1 */
;;;529      tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);
000014  f02303ff          BIC      r3,r3,#0xff
;;;530      tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1ActiveInput >> 16U);
000018  6888              LDR      r0,[r1,#8]
00001a  ea434310          ORR      r3,r3,r0,LSR #16
;;;531      tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1Filter >> 16U);
00001e  6908              LDR      r0,[r1,#0x10]
000020  ea434310          ORR      r3,r3,r0,LSR #16
;;;532      tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC1Prescaler >> 16U);
000024  68c8              LDR      r0,[r1,#0xc]
000026  ea434310          ORR      r3,r3,r0,LSR #16
;;;533    
;;;534      /* Configure TI2 */
;;;535      tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC2S | TIM_CCMR1_IC2F  | TIM_CCMR1_IC2PSC);
00002a  f423437f          BIC      r3,r3,#0xff00
;;;536      tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2ActiveInput >> 8U);
00002e  6988              LDR      r0,[r1,#0x18]
000030  ea432310          ORR      r3,r3,r0,LSR #8
;;;537      tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2Filter >> 8U);
000034  6a08              LDR      r0,[r1,#0x20]
000036  ea432310          ORR      r3,r3,r0,LSR #8
;;;538      tmpccmr1 |= (uint32_t)(TIM_EncoderInitStruct->IC2Prescaler >> 8U);
00003a  69c8              LDR      r0,[r1,#0x1c]
00003c  ea432310          ORR      r3,r3,r0,LSR #8
;;;539    
;;;540      /* Set TI1 and TI2 polarity and enable TI1 and TI2 */
;;;541      tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP | TIM_CCER_CC2P | TIM_CCER_CC2NP);
000040  f02404aa          BIC      r4,r4,#0xaa
;;;542      tmpccer |= (uint32_t)(TIM_EncoderInitStruct->IC1Polarity);
000044  6848              LDR      r0,[r1,#4]
000046  4304              ORRS     r4,r4,r0
;;;543      tmpccer |= (uint32_t)(TIM_EncoderInitStruct->IC2Polarity << 4U);
000048  6948              LDR      r0,[r1,#0x14]
00004a  ea441400          ORR      r4,r4,r0,LSL #4
;;;544      tmpccer |= (uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E);
00004e  f0440411          ORR      r4,r4,#0x11
;;;545    
;;;546      /* Set encoder mode */
;;;547      LL_TIM_SetEncoderMode(TIMx, TIM_EncoderInitStruct->EncoderMode);
000052  6808              LDR      r0,[r1,#0]
000054  6895              LDR      r5,[r2,#8]
000056  f0250507          BIC      r5,r5,#7
00005a  4305              ORRS     r5,r5,r0
00005c  6095              STR      r5,[r2,#8]
00005e  bf00              NOP      
;;;548    
;;;549      /* Write to TIMx CCMR1 */
;;;550      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
000060  6193              STR      r3,[r2,#0x18]
;;;551    
;;;552      /* Write to TIMx CCER */
;;;553      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
000062  6214              STR      r4,[r2,#0x20]
;;;554    
;;;555      return SUCCESS;
000064  2001              MOVS     r0,#1
;;;556    }
000066  bd30              POP      {r4,r5,pc}
;;;557    
                          ENDP


                          AREA ||i.LL_TIM_ENCODER_StructInit||, CODE, READONLY, ALIGN=1

                  LL_TIM_ENCODER_StructInit PROC
;;;479      */
;;;480    void LL_TIM_ENCODER_StructInit(LL_TIM_ENCODER_InitTypeDef *TIM_EncoderInitStruct)
000000  2101              MOVS     r1,#1
;;;481    {
;;;482      /* Set the default configuration */
;;;483      TIM_EncoderInitStruct->EncoderMode    = LL_TIM_ENCODERMODE_X2_TI1;
000002  6001              STR      r1,[r0,#0]
;;;484      TIM_EncoderInitStruct->IC1Polarity    = LL_TIM_IC_POLARITY_RISING;
000004  2100              MOVS     r1,#0
000006  6041              STR      r1,[r0,#4]
;;;485      TIM_EncoderInitStruct->IC1ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
000008  f44f3180          MOV      r1,#0x10000
00000c  6081              STR      r1,[r0,#8]
;;;486      TIM_EncoderInitStruct->IC1Prescaler   = LL_TIM_ICPSC_DIV1;
00000e  2100              MOVS     r1,#0
000010  60c1              STR      r1,[r0,#0xc]
;;;487      TIM_EncoderInitStruct->IC1Filter      = LL_TIM_IC_FILTER_FDIV1;
000012  6101              STR      r1,[r0,#0x10]
;;;488      TIM_EncoderInitStruct->IC2Polarity    = LL_TIM_IC_POLARITY_RISING;
000014  6141              STR      r1,[r0,#0x14]
;;;489      TIM_EncoderInitStruct->IC2ActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
000016  f44f3180          MOV      r1,#0x10000
00001a  6181              STR      r1,[r0,#0x18]
;;;490      TIM_EncoderInitStruct->IC2Prescaler   = LL_TIM_ICPSC_DIV1;
00001c  2100              MOVS     r1,#0
00001e  61c1              STR      r1,[r0,#0x1c]
;;;491      TIM_EncoderInitStruct->IC2Filter      = LL_TIM_IC_FILTER_FDIV1;
000020  6201              STR      r1,[r0,#0x20]
;;;492    }
000022  4770              BX       lr
;;;493    
                          ENDP


                          AREA ||i.LL_TIM_HALLSENSOR_Init||, CODE, READONLY, ALIGN=1

                  LL_TIM_HALLSENSOR_Init PROC
;;;592      */
;;;593    ErrorStatus LL_TIM_HALLSENSOR_Init(TIM_TypeDef *TIMx, LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;594    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;595      uint32_t tmpcr2 = 0U;
000008  f04f0900          MOV      r9,#0
;;;596      uint32_t tmpccmr1 = 0U;
00000c  2500              MOVS     r5,#0
;;;597      uint32_t tmpccer = 0U;
00000e  2700              MOVS     r7,#0
;;;598      uint32_t tmpsmcr = 0U;
000010  46a8              MOV      r8,r5
;;;599    
;;;600      /* Check the parameters */
;;;601      assert_param(IS_TIM_HALL_SENSOR_INTERFACE_INSTANCE(TIMx));
;;;602      assert_param(IS_LL_TIM_IC_POLARITY_ENCODER(TIM_HallSensorInitStruct->IC1Polarity));
;;;603      assert_param(IS_LL_TIM_ICPSC(TIM_HallSensorInitStruct->IC1Prescaler));
;;;604      assert_param(IS_LL_TIM_IC_FILTER(TIM_HallSensorInitStruct->IC1Filter));
;;;605    
;;;606      /* Disable the CC1 and CC2: Reset the CC1E and CC2E Bits */
;;;607      TIMx->CCER &= (uint32_t)~(TIM_CCER_CC1E | TIM_CCER_CC2E);
000012  6a20              LDR      r0,[r4,#0x20]
000014  f0200011          BIC      r0,r0,#0x11
000018  6220              STR      r0,[r4,#0x20]
;;;608    
;;;609      /* Get the TIMx CR2 register value */
;;;610      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
00001a  f8d49004          LDR      r9,[r4,#4]
;;;611    
;;;612      /* Get the TIMx CCMR1 register value */
;;;613      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
00001e  69a5              LDR      r5,[r4,#0x18]
;;;614    
;;;615      /* Get the TIMx CCER register value */
;;;616      tmpccer = LL_TIM_ReadReg(TIMx, CCER);
000020  6a27              LDR      r7,[r4,#0x20]
;;;617    
;;;618      /* Get the TIMx SMCR register value */
;;;619      tmpsmcr = LL_TIM_ReadReg(TIMx, SMCR);
000022  f8d48008          LDR      r8,[r4,#8]
;;;620    
;;;621      /* Connect TIMx_CH1, CH2 and CH3 pins to the TI1 input */
;;;622      tmpcr2 |= TIM_CR2_TI1S;
000026  f0490980          ORR      r9,r9,#0x80
;;;623    
;;;624      /* OC2REF signal is used as trigger output (TRGO) */
;;;625      tmpcr2 |= LL_TIM_TRGO_OC2REF;
00002a  f0490950          ORR      r9,r9,#0x50
;;;626    
;;;627      /* Configure the slave mode controller */
;;;628      tmpsmcr &= (uint32_t)~(TIM_SMCR_TS | TIM_SMCR_SMS);
00002e  f0280877          BIC      r8,r8,#0x77
;;;629      tmpsmcr |= LL_TIM_TS_TI1F_ED;
000032  f0480840          ORR      r8,r8,#0x40
;;;630      tmpsmcr |= LL_TIM_SLAVEMODE_RESET;
000036  f0480804          ORR      r8,r8,#4
;;;631    
;;;632      /* Configure input channel 1 */
;;;633      tmpccmr1 &= (uint32_t)~(TIM_CCMR1_CC1S | TIM_CCMR1_IC1F  | TIM_CCMR1_IC1PSC);
00003a  f02505ff          BIC      r5,r5,#0xff
;;;634      tmpccmr1 |= (uint32_t)(LL_TIM_ACTIVEINPUT_TRC >> 16U);
00003e  f0450503          ORR      r5,r5,#3
;;;635      tmpccmr1 |= (uint32_t)(TIM_HallSensorInitStruct->IC1Filter >> 16U);
000042  68b0              LDR      r0,[r6,#8]
000044  ea454510          ORR      r5,r5,r0,LSR #16
;;;636      tmpccmr1 |= (uint32_t)(TIM_HallSensorInitStruct->IC1Prescaler >> 16U);
000048  6870              LDR      r0,[r6,#4]
00004a  ea454510          ORR      r5,r5,r0,LSR #16
;;;637    
;;;638      /* Configure input channel 2 */
;;;639      tmpccmr1 &= (uint32_t)~(TIM_CCMR1_OC2M | TIM_CCMR1_OC2FE  | TIM_CCMR1_OC2PE  | TIM_CCMR1_OC2CE);
00004e  f425457c          BIC      r5,r5,#0xfc00
;;;640      tmpccmr1 |= (uint32_t)(LL_TIM_OCMODE_PWM2 << 8U);
000052  f44545e0          ORR      r5,r5,#0x7000
;;;641    
;;;642      /* Set Channel 1 polarity and enable Channel 1 and Channel2 */
;;;643      tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP | TIM_CCER_CC2P | TIM_CCER_CC2NP);
000056  f02707aa          BIC      r7,r7,#0xaa
;;;644      tmpccer |= (uint32_t)(TIM_HallSensorInitStruct->IC1Polarity);
00005a  6830              LDR      r0,[r6,#0]
00005c  4307              ORRS     r7,r7,r0
;;;645      tmpccer |= (uint32_t)(TIM_CCER_CC1E | TIM_CCER_CC2E);
00005e  f0470711          ORR      r7,r7,#0x11
;;;646    
;;;647      /* Write to TIMx CR2 */
;;;648      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
000062  f8c49004          STR      r9,[r4,#4]
;;;649    
;;;650      /* Write to TIMx SMCR */
;;;651      LL_TIM_WriteReg(TIMx, SMCR, tmpsmcr);
000066  f8c48008          STR      r8,[r4,#8]
;;;652    
;;;653      /* Write to TIMx CCMR1 */
;;;654      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
00006a  61a5              STR      r5,[r4,#0x18]
;;;655    
;;;656      /* Write to TIMx CCER */
;;;657      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
00006c  6227              STR      r7,[r4,#0x20]
;;;658    
;;;659      /* Write to TIMx CCR2 */
;;;660      LL_TIM_OC_SetCompareCH2(TIMx, TIM_HallSensorInitStruct->CommutationDelay);
00006e  4620              MOV      r0,r4
000070  68f1              LDR      r1,[r6,#0xc]
000072  f7fffffe          BL       LL_TIM_OC_SetCompareCH2
;;;661    
;;;662      return SUCCESS;
000076  2001              MOVS     r0,#1
;;;663    }
000078  e8bd87f0          POP      {r4-r10,pc}
;;;664    
                          ENDP


                          AREA ||i.LL_TIM_HALLSENSOR_StructInit||, CODE, READONLY, ALIGN=1

                  LL_TIM_HALLSENSOR_StructInit PROC
;;;563      */
;;;564    void LL_TIM_HALLSENSOR_StructInit(LL_TIM_HALLSENSOR_InitTypeDef *TIM_HallSensorInitStruct)
000000  2100              MOVS     r1,#0
;;;565    {
;;;566      /* Set the default configuration */
;;;567      TIM_HallSensorInitStruct->IC1Polarity       = LL_TIM_IC_POLARITY_RISING;
000002  6001              STR      r1,[r0,#0]
;;;568      TIM_HallSensorInitStruct->IC1Prescaler      = LL_TIM_ICPSC_DIV1;
000004  6041              STR      r1,[r0,#4]
;;;569      TIM_HallSensorInitStruct->IC1Filter         = LL_TIM_IC_FILTER_FDIV1;
000006  6081              STR      r1,[r0,#8]
;;;570      TIM_HallSensorInitStruct->CommutationDelay  = 0U;
000008  60c1              STR      r1,[r0,#0xc]
;;;571    }
00000a  4770              BX       lr
;;;572    
                          ENDP


                          AREA ||i.LL_TIM_IC_Init||, CODE, READONLY, ALIGN=1

                  LL_TIM_IC_Init PROC
;;;449      */
;;;450    ErrorStatus LL_TIM_IC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_IC_InitTypeDef *TIM_IC_InitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;451    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;452      ErrorStatus result = ERROR;
00000a  2700              MOVS     r7,#0
;;;453    
;;;454      switch (Channel)
00000c  2c01              CMP      r4,#1
00000e  d008              BEQ      |L16.34|
000010  2c10              CMP      r4,#0x10
000012  d00c              BEQ      |L16.46|
000014  f5b47f80          CMP      r4,#0x100
000018  d00f              BEQ      |L16.58|
00001a  f5b45f80          CMP      r4,#0x1000
00001e  d118              BNE      |L16.82|
000020  e011              B        |L16.70|
                  |L16.34|
;;;455      {
;;;456        case LL_TIM_CHANNEL_CH1:
;;;457          result = IC1Config(TIMx, TIM_IC_InitStruct);
000022  4629              MOV      r1,r5
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       IC1Config
00002a  4607              MOV      r7,r0
;;;458          break;
00002c  e012              B        |L16.84|
                  |L16.46|
;;;459        case LL_TIM_CHANNEL_CH2:
;;;460          result = IC2Config(TIMx, TIM_IC_InitStruct);
00002e  4629              MOV      r1,r5
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       IC2Config
000036  4607              MOV      r7,r0
;;;461          break;
000038  e00c              B        |L16.84|
                  |L16.58|
;;;462        case LL_TIM_CHANNEL_CH3:
;;;463          result = IC3Config(TIMx, TIM_IC_InitStruct);
00003a  4629              MOV      r1,r5
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       IC3Config
000042  4607              MOV      r7,r0
;;;464          break;
000044  e006              B        |L16.84|
                  |L16.70|
;;;465        case LL_TIM_CHANNEL_CH4:
;;;466          result = IC4Config(TIMx, TIM_IC_InitStruct);
000046  4629              MOV      r1,r5
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       IC4Config
00004e  4607              MOV      r7,r0
;;;467          break;
000050  e000              B        |L16.84|
                  |L16.82|
;;;468        default:
;;;469          break;
000052  bf00              NOP      
                  |L16.84|
000054  bf00              NOP                            ;458
;;;470      }
;;;471    
;;;472      return result;
000056  4638              MOV      r0,r7
;;;473    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;474    
                          ENDP


                          AREA ||i.LL_TIM_IC_StructInit||, CODE, READONLY, ALIGN=1

                  LL_TIM_IC_StructInit PROC
;;;427      */
;;;428    void LL_TIM_IC_StructInit(LL_TIM_IC_InitTypeDef *TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;429    {
;;;430      /* Set the default configuration */
;;;431      TIM_ICInitStruct->ICPolarity    = LL_TIM_IC_POLARITY_RISING;
000002  6001              STR      r1,[r0,#0]
;;;432      TIM_ICInitStruct->ICActiveInput = LL_TIM_ACTIVEINPUT_DIRECTTI;
000004  f44f3180          MOV      r1,#0x10000
000008  6041              STR      r1,[r0,#4]
;;;433      TIM_ICInitStruct->ICPrescaler   = LL_TIM_ICPSC_DIV1;
00000a  2100              MOVS     r1,#0
00000c  6081              STR      r1,[r0,#8]
;;;434      TIM_ICInitStruct->ICFilter      = LL_TIM_IC_FILTER_FDIV1;
00000e  60c1              STR      r1,[r0,#0xc]
;;;435    }
000010  4770              BX       lr
;;;436    
                          ENDP


                          AREA ||i.LL_TIM_Init||, CODE, READONLY, ALIGN=2

                  LL_TIM_Init PROC
;;;319      */
;;;320    ErrorStatus LL_TIM_Init(TIM_TypeDef *TIMx, LL_TIM_InitTypeDef *TIM_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;321    {
000002  4602              MOV      r2,r0
;;;322      uint32_t tmpcr1 = 0U;
000004  2300              MOVS     r3,#0
;;;323    
;;;324      /* Check the parameters */
;;;325      assert_param(IS_TIM_INSTANCE(TIMx));
;;;326      assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
;;;327      assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));
;;;328    
;;;329      tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
000006  6813              LDR      r3,[r2,#0]
;;;330    
;;;331      if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
000008  482c              LDR      r0,|L18.188|
00000a  4282              CMP      r2,r0
00000c  d00e              BEQ      |L18.44|
00000e  f1b24f80          CMP      r2,#0x40000000
000012  d00b              BEQ      |L18.44|
000014  482a              LDR      r0,|L18.192|
000016  4282              CMP      r2,r0
000018  d008              BEQ      |L18.44|
00001a  482a              LDR      r0,|L18.196|
00001c  4282              CMP      r2,r0
00001e  d005              BEQ      |L18.44|
000020  4829              LDR      r0,|L18.200|
000022  4282              CMP      r2,r0
000024  d002              BEQ      |L18.44|
000026  4829              LDR      r0,|L18.204|
000028  4282              CMP      r2,r0
00002a  d104              BNE      |L18.54|
                  |L18.44|
;;;332      {
;;;333        /* Select the Counter Mode */
;;;334        MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
00002c  f0230070          BIC      r0,r3,#0x70
000030  684c              LDR      r4,[r1,#4]
000032  ea400304          ORR      r3,r0,r4
                  |L18.54|
;;;335      }
;;;336    
;;;337      if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
000036  4821              LDR      r0,|L18.188|
000038  4282              CMP      r2,r0
00003a  d020              BEQ      |L18.126|
00003c  f1b24f80          CMP      r2,#0x40000000
000040  d01d              BEQ      |L18.126|
000042  481f              LDR      r0,|L18.192|
000044  4282              CMP      r2,r0
000046  d01a              BEQ      |L18.126|
000048  481e              LDR      r0,|L18.196|
00004a  4282              CMP      r2,r0
00004c  d017              BEQ      |L18.126|
00004e  481e              LDR      r0,|L18.200|
000050  4282              CMP      r2,r0
000052  d014              BEQ      |L18.126|
000054  481d              LDR      r0,|L18.204|
000056  4282              CMP      r2,r0
000058  d011              BEQ      |L18.126|
00005a  481d              LDR      r0,|L18.208|
00005c  4282              CMP      r2,r0
00005e  d00e              BEQ      |L18.126|
000060  481c              LDR      r0,|L18.212|
000062  4282              CMP      r2,r0
000064  d00b              BEQ      |L18.126|
000066  481c              LDR      r0,|L18.216|
000068  4282              CMP      r2,r0
00006a  d008              BEQ      |L18.126|
00006c  481b              LDR      r0,|L18.220|
00006e  4282              CMP      r2,r0
000070  d005              BEQ      |L18.126|
000072  481b              LDR      r0,|L18.224|
000074  4282              CMP      r2,r0
000076  d002              BEQ      |L18.126|
000078  481a              LDR      r0,|L18.228|
00007a  4282              CMP      r2,r0
00007c  d104              BNE      |L18.136|
                  |L18.126|
;;;338      {
;;;339        /* Set the clock division */
;;;340        MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
00007e  f4237040          BIC      r0,r3,#0x300
000082  68cc              LDR      r4,[r1,#0xc]
000084  ea400304          ORR      r3,r0,r4
                  |L18.136|
;;;341      }
;;;342    
;;;343      /* Write to TIMx CR1 */
;;;344      LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
000088  6013              STR      r3,[r2,#0]
;;;345    
;;;346      /* Set the Autoreload value */
;;;347      LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
00008a  6888              LDR      r0,[r1,#8]
00008c  62d0              STR      r0,[r2,#0x2c]
00008e  bf00              NOP      
;;;348    
;;;349      /* Set the Prescaler value */
;;;350      LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
000090  8808              LDRH     r0,[r1,#0]
000092  6290              STR      r0,[r2,#0x28]
000094  bf00              NOP      
;;;351    
;;;352      if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
000096  4809              LDR      r0,|L18.188|
000098  4282              CMP      r2,r0
00009a  d002              BEQ      |L18.162|
00009c  480b              LDR      r0,|L18.204|
00009e  4282              CMP      r2,r0
0000a0  d103              BNE      |L18.170|
                  |L18.162|
;;;353      {
;;;354        /* Set the Repetition Counter value */
;;;355        LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
0000a2  7c08              LDRB     r0,[r1,#0x10]
0000a4  6310              STR      r0,[r2,#0x30]
0000a6  bf00              NOP      
0000a8  bf00              NOP      
                  |L18.170|
;;;356      }
;;;357    
;;;358      /* Generate an update event to reload the Prescaler
;;;359         and the repetition counter value (if applicable) immediately */
;;;360      LL_TIM_GenerateEvent_UPDATE(TIMx);
0000aa  bf00              NOP      
0000ac  6950              LDR      r0,[r2,#0x14]
0000ae  f0400001          ORR      r0,r0,#1
0000b2  6150              STR      r0,[r2,#0x14]
0000b4  bf00              NOP      
;;;361    
;;;362      return SUCCESS;
0000b6  2001              MOVS     r0,#1
;;;363    }
0000b8  bd10              POP      {r4,pc}
;;;364    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L18.188|
                          DCD      0x40010000
                  |L18.192|
                          DCD      0x40000400
                  |L18.196|
                          DCD      0x40000800
                  |L18.200|
                          DCD      0x40000c00
                  |L18.204|
                          DCD      0x40010400
                  |L18.208|
                          DCD      0x40014000
                  |L18.212|
                          DCD      0x40014400
                  |L18.216|
                          DCD      0x40014800
                  |L18.220|
                          DCD      0x40001800
                  |L18.224|
                          DCD      0x40001c00
                  |L18.228|
                          DCD      0x40002000

                          AREA ||i.LL_TIM_OC_Init||, CODE, READONLY, ALIGN=1

                  LL_TIM_OC_Init PROC
;;;396      */
;;;397    ErrorStatus LL_TIM_OC_Init(TIM_TypeDef *TIMx, uint32_t Channel, LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;398    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
;;;399      ErrorStatus result = ERROR;
00000a  2700              MOVS     r7,#0
;;;400    
;;;401      switch (Channel)
00000c  2c01              CMP      r4,#1
00000e  d008              BEQ      |L19.34|
000010  2c10              CMP      r4,#0x10
000012  d00c              BEQ      |L19.46|
000014  f5b47f80          CMP      r4,#0x100
000018  d00f              BEQ      |L19.58|
00001a  f5b45f80          CMP      r4,#0x1000
00001e  d118              BNE      |L19.82|
000020  e011              B        |L19.70|
                  |L19.34|
;;;402      {
;;;403        case LL_TIM_CHANNEL_CH1:
;;;404          result = OC1Config(TIMx, TIM_OC_InitStruct);
000022  4629              MOV      r1,r5
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       OC1Config
00002a  4607              MOV      r7,r0
;;;405          break;
00002c  e012              B        |L19.84|
                  |L19.46|
;;;406        case LL_TIM_CHANNEL_CH2:
;;;407          result = OC2Config(TIMx, TIM_OC_InitStruct);
00002e  4629              MOV      r1,r5
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       OC2Config
000036  4607              MOV      r7,r0
;;;408          break;
000038  e00c              B        |L19.84|
                  |L19.58|
;;;409        case LL_TIM_CHANNEL_CH3:
;;;410          result = OC3Config(TIMx, TIM_OC_InitStruct);
00003a  4629              MOV      r1,r5
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       OC3Config
000042  4607              MOV      r7,r0
;;;411          break;
000044  e006              B        |L19.84|
                  |L19.70|
;;;412        case LL_TIM_CHANNEL_CH4:
;;;413          result = OC4Config(TIMx, TIM_OC_InitStruct);
000046  4629              MOV      r1,r5
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       OC4Config
00004e  4607              MOV      r7,r0
;;;414          break;
000050  e000              B        |L19.84|
                  |L19.82|
;;;415        default:
;;;416          break;
000052  bf00              NOP      
                  |L19.84|
000054  bf00              NOP                            ;405
;;;417      }
;;;418    
;;;419      return result;
000056  4638              MOV      r0,r7
;;;420    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;421    
                          ENDP


                          AREA ||i.LL_TIM_OC_SetCompareCH2||, CODE, READONLY, ALIGN=1

                  LL_TIM_OC_SetCompareCH2 PROC
;;;2059     */
;;;2060   __STATIC_INLINE void LL_TIM_OC_SetCompareCH2(TIM_TypeDef *TIMx, uint32_t CompareValue)
000000  6381              STR      r1,[r0,#0x38]
;;;2061   {
;;;2062     WRITE_REG(TIMx->CCR2, CompareValue);
;;;2063   }
000002  4770              BX       lr
;;;2064   
                          ENDP


                          AREA ||i.LL_TIM_OC_StructInit||, CODE, READONLY, ALIGN=1

                  LL_TIM_OC_StructInit PROC
;;;370      */
;;;371    void LL_TIM_OC_StructInit(LL_TIM_OC_InitTypeDef *TIM_OC_InitStruct)
000000  2100              MOVS     r1,#0
;;;372    {
;;;373      /* Set the default configuration */
;;;374      TIM_OC_InitStruct->OCMode       = LL_TIM_OCMODE_FROZEN;
000002  6001              STR      r1,[r0,#0]
;;;375      TIM_OC_InitStruct->OCState      = LL_TIM_OCSTATE_DISABLE;
000004  6041              STR      r1,[r0,#4]
;;;376      TIM_OC_InitStruct->OCNState     = LL_TIM_OCSTATE_DISABLE;
000006  6081              STR      r1,[r0,#8]
;;;377      TIM_OC_InitStruct->CompareValue = 0x00000000U;
000008  60c1              STR      r1,[r0,#0xc]
;;;378      TIM_OC_InitStruct->OCPolarity   = LL_TIM_OCPOLARITY_HIGH;
00000a  6101              STR      r1,[r0,#0x10]
;;;379      TIM_OC_InitStruct->OCNPolarity  = LL_TIM_OCPOLARITY_HIGH;
00000c  6141              STR      r1,[r0,#0x14]
;;;380      TIM_OC_InitStruct->OCIdleState  = LL_TIM_OCIDLESTATE_LOW;
00000e  6181              STR      r1,[r0,#0x18]
;;;381      TIM_OC_InitStruct->OCNIdleState = LL_TIM_OCIDLESTATE_LOW;
000010  61c1              STR      r1,[r0,#0x1c]
;;;382    }
000012  4770              BX       lr
;;;383    
                          ENDP


                          AREA ||i.LL_TIM_StructInit||, CODE, READONLY, ALIGN=1

                  LL_TIM_StructInit PROC
;;;301      */
;;;302    void LL_TIM_StructInit(LL_TIM_InitTypeDef *TIM_InitStruct)
000000  2100              MOVS     r1,#0
;;;303    {
;;;304      /* Set the default configuration */
;;;305      TIM_InitStruct->Prescaler         = (uint16_t)0x0000U;
000002  8001              STRH     r1,[r0,#0]
;;;306      TIM_InitStruct->CounterMode       = LL_TIM_COUNTERMODE_UP;
000004  6041              STR      r1,[r0,#4]
;;;307      TIM_InitStruct->Autoreload        = 0xFFFFFFFFU;
000006  1e49              SUBS     r1,r1,#1
000008  6081              STR      r1,[r0,#8]
;;;308      TIM_InitStruct->ClockDivision     = LL_TIM_CLOCKDIVISION_DIV1;
00000a  2100              MOVS     r1,#0
00000c  60c1              STR      r1,[r0,#0xc]
;;;309      TIM_InitStruct->RepetitionCounter = (uint8_t)0x00U;
00000e  7401              STRB     r1,[r0,#0x10]
;;;310    }
000010  4770              BX       lr
;;;311    
                          ENDP


                          AREA ||i.OC1Config||, CODE, READONLY, ALIGN=2

                  OC1Config PROC
;;;746      */
;;;747    static ErrorStatus OC1Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;748    {
000002  4602              MOV      r2,r0
;;;749      uint32_t tmpccmr1 = 0U;
000004  2400              MOVS     r4,#0
;;;750      uint32_t tmpccer = 0U;
000006  2300              MOVS     r3,#0
;;;751      uint32_t tmpcr2 = 0U;
000008  2500              MOVS     r5,#0
;;;752    
;;;753      /* Check the parameters */
;;;754      assert_param(IS_TIM_CC1_INSTANCE(TIMx));
;;;755      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;756      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;757      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;758      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;759      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;760    
;;;761      /* Disable the Channel 1: Reset the CC1E Bit */
;;;762      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC1E);
00000a  6a10              LDR      r0,[r2,#0x20]
00000c  f0200001          BIC      r0,r0,#1
000010  6210              STR      r0,[r2,#0x20]
;;;763    
;;;764      /* Get the TIMx CCER register value */
;;;765      tmpccer = LL_TIM_ReadReg(TIMx, CCER);
000012  6a13              LDR      r3,[r2,#0x20]
;;;766    
;;;767      /* Get the TIMx CR2 register value */
;;;768      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
000014  6855              LDR      r5,[r2,#4]
;;;769    
;;;770      /* Get the TIMx CCMR1 register value */
;;;771      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
000016  6994              LDR      r4,[r2,#0x18]
;;;772    
;;;773      /* Reset Capture/Compare selection Bits */
;;;774      CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC1S);
000018  f0240403          BIC      r4,r4,#3
;;;775    
;;;776      /* Set the Output Compare Mode */
;;;777      MODIFY_REG(tmpccmr1, TIM_CCMR1_OC1M, TIM_OCInitStruct->OCMode);
00001c  f0240070          BIC      r0,r4,#0x70
000020  680e              LDR      r6,[r1,#0]
000022  ea400406          ORR      r4,r0,r6
;;;778    
;;;779      /* Set the Output Compare Polarity */
;;;780      MODIFY_REG(tmpccer, TIM_CCER_CC1P, TIM_OCInitStruct->OCPolarity);
000026  f0230002          BIC      r0,r3,#2
00002a  690e              LDR      r6,[r1,#0x10]
00002c  ea400306          ORR      r3,r0,r6
;;;781    
;;;782      /* Set the Output State */
;;;783      MODIFY_REG(tmpccer, TIM_CCER_CC1E, TIM_OCInitStruct->OCState);
000030  f0230001          BIC      r0,r3,#1
000034  684e              LDR      r6,[r1,#4]
000036  ea400306          ORR      r3,r0,r6
;;;784    
;;;785      if (IS_TIM_BREAK_INSTANCE(TIMx))
00003a  4811              LDR      r0,|L23.128|
00003c  4282              CMP      r2,r0
00003e  d002              BEQ      |L23.70|
000040  4810              LDR      r0,|L23.132|
000042  4282              CMP      r2,r0
000044  d113              BNE      |L23.110|
                  |L23.70|
;;;786      {
;;;787        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;788        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;789    
;;;790        /* Set the complementary output Polarity */
;;;791        MODIFY_REG(tmpccer, TIM_CCER_CC1NP, TIM_OCInitStruct->OCNPolarity << 2U);
000046  f0230008          BIC      r0,r3,#8
00004a  694e              LDR      r6,[r1,#0x14]
00004c  ea400386          ORR      r3,r0,r6,LSL #2
;;;792    
;;;793        /* Set the complementary output State */
;;;794        MODIFY_REG(tmpccer, TIM_CCER_CC1NE, TIM_OCInitStruct->OCNState << 2U);
000050  f0230004          BIC      r0,r3,#4
000054  688e              LDR      r6,[r1,#8]
000056  ea400386          ORR      r3,r0,r6,LSL #2
;;;795    
;;;796        /* Set the Output Idle state */
;;;797        MODIFY_REG(tmpcr2, TIM_CR2_OIS1, TIM_OCInitStruct->OCIdleState);
00005a  f4257080          BIC      r0,r5,#0x100
00005e  698e              LDR      r6,[r1,#0x18]
000060  ea400506          ORR      r5,r0,r6
;;;798    
;;;799        /* Set the complementary output Idle state */
;;;800        MODIFY_REG(tmpcr2, TIM_CR2_OIS1N, TIM_OCInitStruct->OCNIdleState << 1U);
000064  f4257000          BIC      r0,r5,#0x200
000068  69ce              LDR      r6,[r1,#0x1c]
00006a  ea400546          ORR      r5,r0,r6,LSL #1
                  |L23.110|
;;;801      }
;;;802    
;;;803      /* Write to TIMx CR2 */
;;;804      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
00006e  6055              STR      r5,[r2,#4]
;;;805    
;;;806      /* Write to TIMx CCMR1 */
;;;807      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
000070  6194              STR      r4,[r2,#0x18]
;;;808    
;;;809      /* Set the Capture Compare Register value */
;;;810      LL_TIM_OC_SetCompareCH1(TIMx, TIM_OCInitStruct->CompareValue);
000072  68c8              LDR      r0,[r1,#0xc]
000074  6350              STR      r0,[r2,#0x34]
000076  bf00              NOP      
;;;811    
;;;812      /* Write to TIMx CCER */
;;;813      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
000078  6213              STR      r3,[r2,#0x20]
;;;814    
;;;815      return SUCCESS;
00007a  2001              MOVS     r0,#1
;;;816    }
00007c  bd70              POP      {r4-r6,pc}
;;;817    
                          ENDP

00007e  0000              DCW      0x0000
                  |L23.128|
                          DCD      0x40010000
                  |L23.132|
                          DCD      0x40010400

                          AREA ||i.OC2Config||, CODE, READONLY, ALIGN=2

                  OC2Config PROC
;;;825      */
;;;826    static ErrorStatus OC2Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;827    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;828      uint32_t tmpccmr1 = 0U;
000008  2700              MOVS     r7,#0
;;;829      uint32_t tmpccer = 0U;
00000a  2600              MOVS     r6,#0
;;;830      uint32_t tmpcr2 = 0U;
00000c  46b0              MOV      r8,r6
;;;831    
;;;832      /* Check the parameters */
;;;833      assert_param(IS_TIM_CC2_INSTANCE(TIMx));
;;;834      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;835      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;836      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;837      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;838      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;839    
;;;840      /* Disable the Channel 2: Reset the CC2E Bit */
;;;841      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC2E);
00000e  6a20              LDR      r0,[r4,#0x20]
000010  f0200010          BIC      r0,r0,#0x10
000014  6220              STR      r0,[r4,#0x20]
;;;842    
;;;843      /* Get the TIMx CCER register value */
;;;844      tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
000016  6a26              LDR      r6,[r4,#0x20]
;;;845    
;;;846      /* Get the TIMx CR2 register value */
;;;847      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
000018  f8d48004          LDR      r8,[r4,#4]
;;;848    
;;;849      /* Get the TIMx CCMR1 register value */
;;;850      tmpccmr1 = LL_TIM_ReadReg(TIMx, CCMR1);
00001c  69a7              LDR      r7,[r4,#0x18]
;;;851    
;;;852      /* Reset Capture/Compare selection Bits */
;;;853      CLEAR_BIT(tmpccmr1, TIM_CCMR1_CC2S);
00001e  f4277740          BIC      r7,r7,#0x300
;;;854    
;;;855      /* Select the Output Compare Mode */
;;;856      MODIFY_REG(tmpccmr1, TIM_CCMR1_OC2M, TIM_OCInitStruct->OCMode << 8U);
000022  f42740e0          BIC      r0,r7,#0x7000
000026  6829              LDR      r1,[r5,#0]
000028  ea402701          ORR      r7,r0,r1,LSL #8
;;;857    
;;;858      /* Set the Output Compare Polarity */
;;;859      MODIFY_REG(tmpccer, TIM_CCER_CC2P, TIM_OCInitStruct->OCPolarity << 4U);
00002c  f0260020          BIC      r0,r6,#0x20
000030  6929              LDR      r1,[r5,#0x10]
000032  ea401601          ORR      r6,r0,r1,LSL #4
;;;860    
;;;861      /* Set the Output State */
;;;862      MODIFY_REG(tmpccer, TIM_CCER_CC2E, TIM_OCInitStruct->OCState << 4U);
000036  f0260010          BIC      r0,r6,#0x10
00003a  6869              LDR      r1,[r5,#4]
00003c  ea401601          ORR      r6,r0,r1,LSL #4
;;;863    
;;;864      if (IS_TIM_BREAK_INSTANCE(TIMx))
000040  4812              LDR      r0,|L24.140|
000042  4284              CMP      r4,r0
000044  d002              BEQ      |L24.76|
000046  4812              LDR      r0,|L24.144|
000048  4284              CMP      r4,r0
00004a  d113              BNE      |L24.116|
                  |L24.76|
;;;865      {
;;;866        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;867        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;868    
;;;869        /* Set the complementary output Polarity */
;;;870        MODIFY_REG(tmpccer, TIM_CCER_CC2NP, TIM_OCInitStruct->OCNPolarity << 6U);
00004c  f0260080          BIC      r0,r6,#0x80
000050  6969              LDR      r1,[r5,#0x14]
000052  ea401681          ORR      r6,r0,r1,LSL #6
;;;871    
;;;872        /* Set the complementary output State */
;;;873        MODIFY_REG(tmpccer, TIM_CCER_CC2NE, TIM_OCInitStruct->OCNState << 6U);
000056  f0260040          BIC      r0,r6,#0x40
00005a  68a9              LDR      r1,[r5,#8]
00005c  ea401681          ORR      r6,r0,r1,LSL #6
;;;874    
;;;875        /* Set the Output Idle state */
;;;876        MODIFY_REG(tmpcr2, TIM_CR2_OIS2, TIM_OCInitStruct->OCIdleState << 2U);
000060  f4286080          BIC      r0,r8,#0x400
000064  69a9              LDR      r1,[r5,#0x18]
000066  ea400881          ORR      r8,r0,r1,LSL #2
;;;877    
;;;878        /* Set the complementary output Idle state */
;;;879        MODIFY_REG(tmpcr2, TIM_CR2_OIS2N, TIM_OCInitStruct->OCNIdleState << 3U);
00006a  f4286000          BIC      r0,r8,#0x800
00006e  69e9              LDR      r1,[r5,#0x1c]
000070  ea4008c1          ORR      r8,r0,r1,LSL #3
                  |L24.116|
;;;880      }
;;;881    
;;;882      /* Write to TIMx CR2 */
;;;883      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
000074  f8c48004          STR      r8,[r4,#4]
;;;884    
;;;885      /* Write to TIMx CCMR1 */
;;;886      LL_TIM_WriteReg(TIMx, CCMR1, tmpccmr1);
000078  61a7              STR      r7,[r4,#0x18]
;;;887    
;;;888      /* Set the Capture Compare Register value */
;;;889      LL_TIM_OC_SetCompareCH2(TIMx, TIM_OCInitStruct->CompareValue);
00007a  4620              MOV      r0,r4
00007c  68e9              LDR      r1,[r5,#0xc]
00007e  f7fffffe          BL       LL_TIM_OC_SetCompareCH2
;;;890    
;;;891      /* Write to TIMx CCER */
;;;892      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
000082  6226              STR      r6,[r4,#0x20]
;;;893    
;;;894      return SUCCESS;
000084  2001              MOVS     r0,#1
;;;895    }
000086  e8bd81f0          POP      {r4-r8,pc}
;;;896    
                          ENDP

00008a  0000              DCW      0x0000
                  |L24.140|
                          DCD      0x40010000
                  |L24.144|
                          DCD      0x40010400

                          AREA ||i.OC3Config||, CODE, READONLY, ALIGN=2

                  OC3Config PROC
;;;904      */
;;;905    static ErrorStatus OC3Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;906    {
000002  4602              MOV      r2,r0
;;;907      uint32_t tmpccmr2 = 0U;
000004  2400              MOVS     r4,#0
;;;908      uint32_t tmpccer = 0U;
000006  2300              MOVS     r3,#0
;;;909      uint32_t tmpcr2 = 0U;
000008  2500              MOVS     r5,#0
;;;910    
;;;911      /* Check the parameters */
;;;912      assert_param(IS_TIM_CC3_INSTANCE(TIMx));
;;;913      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;914      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;915      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;916      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;917      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;918    
;;;919      /* Disable the Channel 3: Reset the CC3E Bit */
;;;920      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC3E);
00000a  6a10              LDR      r0,[r2,#0x20]
00000c  f4207080          BIC      r0,r0,#0x100
000010  6210              STR      r0,[r2,#0x20]
;;;921    
;;;922      /* Get the TIMx CCER register value */
;;;923      tmpccer =  LL_TIM_ReadReg(TIMx, CCER);
000012  6a13              LDR      r3,[r2,#0x20]
;;;924    
;;;925      /* Get the TIMx CR2 register value */
;;;926      tmpcr2 = LL_TIM_ReadReg(TIMx, CR2);
000014  6855              LDR      r5,[r2,#4]
;;;927    
;;;928      /* Get the TIMx CCMR2 register value */
;;;929      tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
000016  69d4              LDR      r4,[r2,#0x1c]
;;;930    
;;;931      /* Reset Capture/Compare selection Bits */
;;;932      CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC3S);
000018  f0240403          BIC      r4,r4,#3
;;;933    
;;;934      /* Select the Output Compare Mode */
;;;935      MODIFY_REG(tmpccmr2, TIM_CCMR2_OC3M, TIM_OCInitStruct->OCMode);
00001c  f0240070          BIC      r0,r4,#0x70
000020  680e              LDR      r6,[r1,#0]
000022  ea400406          ORR      r4,r0,r6
;;;936    
;;;937      /* Set the Output Compare Polarity */
;;;938      MODIFY_REG(tmpccer, TIM_CCER_CC3P, TIM_OCInitStruct->OCPolarity << 8U);
000026  f4237000          BIC      r0,r3,#0x200
00002a  690e              LDR      r6,[r1,#0x10]
00002c  ea402306          ORR      r3,r0,r6,LSL #8
;;;939    
;;;940      /* Set the Output State */
;;;941      MODIFY_REG(tmpccer, TIM_CCER_CC3E, TIM_OCInitStruct->OCState << 8U);
000030  f4237080          BIC      r0,r3,#0x100
000034  684e              LDR      r6,[r1,#4]
000036  ea402306          ORR      r3,r0,r6,LSL #8
;;;942    
;;;943      if (IS_TIM_BREAK_INSTANCE(TIMx))
00003a  4811              LDR      r0,|L25.128|
00003c  4282              CMP      r2,r0
00003e  d002              BEQ      |L25.70|
000040  4810              LDR      r0,|L25.132|
000042  4282              CMP      r2,r0
000044  d113              BNE      |L25.110|
                  |L25.70|
;;;944      {
;;;945        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;946        assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;947    
;;;948        /* Set the complementary output Polarity */
;;;949        MODIFY_REG(tmpccer, TIM_CCER_CC3NP, TIM_OCInitStruct->OCNPolarity << 10U);
000046  f4236000          BIC      r0,r3,#0x800
00004a  694e              LDR      r6,[r1,#0x14]
00004c  ea402386          ORR      r3,r0,r6,LSL #10
;;;950    
;;;951        /* Set the complementary output State */
;;;952        MODIFY_REG(tmpccer, TIM_CCER_CC3NE, TIM_OCInitStruct->OCNState << 10U);
000050  f4236080          BIC      r0,r3,#0x400
000054  688e              LDR      r6,[r1,#8]
000056  ea402386          ORR      r3,r0,r6,LSL #10
;;;953    
;;;954        /* Set the Output Idle state */
;;;955        MODIFY_REG(tmpcr2, TIM_CR2_OIS3, TIM_OCInitStruct->OCIdleState << 4U);
00005a  f4255080          BIC      r0,r5,#0x1000
00005e  698e              LDR      r6,[r1,#0x18]
000060  ea401506          ORR      r5,r0,r6,LSL #4
;;;956    
;;;957        /* Set the complementary output Idle state */
;;;958        MODIFY_REG(tmpcr2, TIM_CR2_OIS3N, TIM_OCInitStruct->OCNIdleState << 5U);
000064  f4255000          BIC      r0,r5,#0x2000
000068  69ce              LDR      r6,[r1,#0x1c]
00006a  ea401546          ORR      r5,r0,r6,LSL #5
                  |L25.110|
;;;959      }
;;;960    
;;;961      /* Write to TIMx CR2 */
;;;962      LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
00006e  6055              STR      r5,[r2,#4]
;;;963    
;;;964      /* Write to TIMx CCMR2 */
;;;965      LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
000070  61d4              STR      r4,[r2,#0x1c]
;;;966    
;;;967      /* Set the Capture Compare Register value */
;;;968      LL_TIM_OC_SetCompareCH3(TIMx, TIM_OCInitStruct->CompareValue);
000072  68c8              LDR      r0,[r1,#0xc]
000074  63d0              STR      r0,[r2,#0x3c]
000076  bf00              NOP      
;;;969    
;;;970      /* Write to TIMx CCER */
;;;971      LL_TIM_WriteReg(TIMx, CCER, tmpccer);
000078  6213              STR      r3,[r2,#0x20]
;;;972    
;;;973      return SUCCESS;
00007a  2001              MOVS     r0,#1
;;;974    }
00007c  bd70              POP      {r4-r6,pc}
;;;975    
                          ENDP

00007e  0000              DCW      0x0000
                  |L25.128|
                          DCD      0x40010000
                  |L25.132|
                          DCD      0x40010400

                          AREA ||i.OC4Config||, CODE, READONLY, ALIGN=2

                  OC4Config PROC
;;;983      */
;;;984    static ErrorStatus OC4Config(TIM_TypeDef *TIMx, LL_TIM_OC_InitTypeDef *TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;985    {
000002  4602              MOV      r2,r0
;;;986      uint32_t tmpccmr2 = 0U;
000004  2300              MOVS     r3,#0
;;;987      uint32_t tmpccer = 0U;
000006  2400              MOVS     r4,#0
;;;988      uint32_t tmpcr2 = 0U;
000008  2500              MOVS     r5,#0
;;;989    
;;;990      /* Check the parameters */
;;;991      assert_param(IS_TIM_CC4_INSTANCE(TIMx));
;;;992      assert_param(IS_LL_TIM_OCMODE(TIM_OCInitStruct->OCMode));
;;;993      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCState));
;;;994      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCPolarity));
;;;995      assert_param(IS_LL_TIM_OCPOLARITY(TIM_OCInitStruct->OCNPolarity));
;;;996      assert_param(IS_LL_TIM_OCSTATE(TIM_OCInitStruct->OCNState));
;;;997    
;;;998      /* Disable the Channel 4: Reset the CC4E Bit */
;;;999      CLEAR_BIT(TIMx->CCER, TIM_CCER_CC4E);
00000a  6a10              LDR      r0,[r2,#0x20]
00000c  f4205080          BIC      r0,r0,#0x1000
000010  6210              STR      r0,[r2,#0x20]
;;;1000   
;;;1001     /* Get the TIMx CCER register value */
;;;1002     tmpccer = LL_TIM_ReadReg(TIMx, CCER);
000012  6a14              LDR      r4,[r2,#0x20]
;;;1003   
;;;1004     /* Get the TIMx CR2 register value */
;;;1005     tmpcr2 =  LL_TIM_ReadReg(TIMx, CR2);
000014  6855              LDR      r5,[r2,#4]
;;;1006   
;;;1007     /* Get the TIMx CCMR2 register value */
;;;1008     tmpccmr2 = LL_TIM_ReadReg(TIMx, CCMR2);
000016  69d3              LDR      r3,[r2,#0x1c]
;;;1009   
;;;1010     /* Reset Capture/Compare selection Bits */
;;;1011     CLEAR_BIT(tmpccmr2, TIM_CCMR2_CC4S);
000018  f4237340          BIC      r3,r3,#0x300
;;;1012   
;;;1013     /* Select the Output Compare Mode */
;;;1014     MODIFY_REG(tmpccmr2, TIM_CCMR2_OC4M, TIM_OCInitStruct->OCMode << 8U);
00001c  f42340e0          BIC      r0,r3,#0x7000
000020  680e              LDR      r6,[r1,#0]
000022  ea402306          ORR      r3,r0,r6,LSL #8
;;;1015   
;;;1016     /* Set the Output Compare Polarity */
;;;1017     MODIFY_REG(tmpccer, TIM_CCER_CC4P, TIM_OCInitStruct->OCPolarity << 12U);
000026  f4245000          BIC      r0,r4,#0x2000
00002a  690e              LDR      r6,[r1,#0x10]
00002c  ea403406          ORR      r4,r0,r6,LSL #12
;;;1018   
;;;1019     /* Set the Output State */
;;;1020     MODIFY_REG(tmpccer, TIM_CCER_CC4E, TIM_OCInitStruct->OCState << 12U);
000030  f4245080          BIC      r0,r4,#0x1000
000034  684e              LDR      r6,[r1,#4]
000036  ea403406          ORR      r4,r0,r6,LSL #12
;;;1021   
;;;1022     if (IS_TIM_BREAK_INSTANCE(TIMx))
00003a  4809              LDR      r0,|L26.96|
00003c  4282              CMP      r2,r0
00003e  d002              BEQ      |L26.70|
000040  4808              LDR      r0,|L26.100|
000042  4282              CMP      r2,r0
000044  d104              BNE      |L26.80|
                  |L26.70|
;;;1023     {
;;;1024       assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCNIdleState));
;;;1025       assert_param(IS_LL_TIM_OCIDLESTATE(TIM_OCInitStruct->OCIdleState));
;;;1026   
;;;1027       /* Set the Output Idle state */
;;;1028       MODIFY_REG(tmpcr2, TIM_CR2_OIS4, TIM_OCInitStruct->OCIdleState << 6U);
000046  f4254080          BIC      r0,r5,#0x4000
00004a  698e              LDR      r6,[r1,#0x18]
00004c  ea401586          ORR      r5,r0,r6,LSL #6
                  |L26.80|
;;;1029     }
;;;1030   
;;;1031     /* Write to TIMx CR2 */
;;;1032     LL_TIM_WriteReg(TIMx, CR2, tmpcr2);
000050  6055              STR      r5,[r2,#4]
;;;1033   
;;;1034     /* Write to TIMx CCMR2 */
;;;1035     LL_TIM_WriteReg(TIMx, CCMR2, tmpccmr2);
000052  61d3              STR      r3,[r2,#0x1c]
;;;1036   
;;;1037     /* Set the Capture Compare Register value */
;;;1038     LL_TIM_OC_SetCompareCH4(TIMx, TIM_OCInitStruct->CompareValue);
000054  68c8              LDR      r0,[r1,#0xc]
000056  6410              STR      r0,[r2,#0x40]
000058  bf00              NOP      
;;;1039   
;;;1040     /* Write to TIMx CCER */
;;;1041     LL_TIM_WriteReg(TIMx, CCER, tmpccer);
00005a  6214              STR      r4,[r2,#0x20]
;;;1042   
;;;1043     return SUCCESS;
00005c  2001              MOVS     r0,#1
;;;1044   }
00005e  bd70              POP      {r4-r6,pc}
;;;1045   
                          ENDP

                  |L26.96|
                          DCD      0x40010000
                  |L26.100|
                          DCD      0x40010400

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OFFSET_TAB_CCMRx
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  040404            DCB      0x04,0x04,0x04
                  SHIFT_TAB_OCxx
000007  00                DCB      0x00
000008  00080000          DCB      0x00,0x08,0x00,0x00
00000c  0008              DCB      0x00,0x08
                  SHIFT_TAB_ICxx
00000e  0000              DCB      0x00,0x00
000010  08000000          DCB      0x08,0x00,0x00,0x00
000014  08                DCB      0x08
                  SHIFT_TAB_CCxP
000015  000204            DCB      0x00,0x02,0x04
000018  06080a0c          DCB      0x06,0x08,0x0a,0x0c
                  SHIFT_TAB_OISx
00001c  00010203          DCB      0x00,0x01,0x02,0x03
000020  040506            DCB      0x04,0x05,0x06

;*** Start embedded assembler ***

#line 1 "../Drivers/STM32F4xx_HAL_Driver/Src/stm32f4xx_ll_tim.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_tim_c_d1be445c____REV16|
#line 388 "../Drivers/CMSIS/Include/cmsis_armcc.h"
|__asm___18_stm32f4xx_ll_tim_c_d1be445c____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_tim_c_d1be445c____REVSH|
#line 402
|__asm___18_stm32f4xx_ll_tim_c_d1be445c____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_stm32f4xx_ll_tim_c_d1be445c____RRX|
#line 587
|__asm___18_stm32f4xx_ll_tim_c_d1be445c____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
